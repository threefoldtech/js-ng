<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>jumpscale.data.bcdb.bcdb API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>jumpscale.data.bcdb.bcdb</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from redis import Redis
import json
from jumpscale.data.bcdb import models as models
from .clients import RedisStorageClient, RedisIndexClient, SonicIndexTextClient, SQLiteIndexSetClient

class BCDB:
    def __init__(self, ns):
        self.ns = ns
        self.storage = RedisStorageClient(ns)
        self.indexer = RedisIndexClient(ns)
        self.indexer_set = SQLiteIndexSetClient(ns)
        self.indexer_text = SonicIndexTextClient(ns)
        self.models = {

        }
        self.loaded_models = {

        }
        self.detect_models()
        self.model_model = self.models[&#34;model&#34;](self)

    def detect_models(self):
        &#34;&#34;&#34;It scans all the models and store its classes for later use.&#34;&#34;&#34;
        for model_name in dir(models):
            model = getattr(models, model_name)
            if isinstance(model, type) and issubclass(model, models.ModelBase):
                self.models[model._name] = model

    def save_obj(self, model, obj):
        &#34;&#34;&#34;Saves the given objects which belongs to model in the db and update the indexes.

        Args:
            model (ModelObj): The model object that obj belongs to.
            obj (JSObjBase): The object that will be saved.
        &#34;&#34;&#34;
        self.indexer_set.set(model, obj)
        self.indexer_text.set(model, obj)
        for prop in model.schema.props.values():
            old_obj = model.get_by(&#39;id&#39;, obj.id)
            prop_name = prop.name
            index_prop = getattr(obj, prop.name)
            old_index = getattr(old_obj, prop.name) if old_obj else None
            if prop.index:
                self.indexer.set(model, prop_name, index_prop, obj.id, old_index)
        self.storage.set(model, obj.id, obj)

    def model_id_incr(self, model):
        &#34;&#34;&#34;Increment the id counter in the model and returns the new id.
        Used to assign unique id for each created object.

        Args:
            model (ModelObj): The model object.

        Returns:
            int: The new unique id
        &#34;&#34;&#34;
        return self.storage.incr_id(model)

    def get_item_by_id(self, model, id):
        &#34;&#34;&#34;Gets the object in the model with the given id.

        Args:
            model (ModelObj): The model to be searched in.
            id (int): The object&#39;s id.

        Returns:
            JSObjBase or None: The JSObject with the given id. None if none was found.
        &#34;&#34;&#34;
        return self.storage.get(model, id)

    def get_entry(self, model, key, val):
        &#34;&#34;&#34;Search for objects whose key equal val.
        1. It searches in the redis index if key is indexed.
        2. Else, It&#39;s searched for in the sqlite index if the key is indexed for range search.
        3. Else, All objects in the db belonging to the given model is scanned linearly to determine the matching object.

        Args:
            model (ModelObj): The model in which the key is searched for.
            key (str): The model property that is checked for.
            val (value): The value.

        Raises:
            RuntimeError: If the key is not a part of the schema.

        Returns:
            JSObjBase or None: The matched object (o: o.key == val). None if none matched.
        &#34;&#34;&#34;
        if key not in model.schema.props:
            raise RuntimeError(f&#34;{key} is not a part of {model.name}&#39;s schema&#34;)
        if model.schema.props[key].index:
            return self.get_item_from_index(model, key, val)
        elif model.schema.props[key].index_key:
            found = self.get_item_from_index_set(model, key, val, val)
            return found[0] if found else None
        else:
            for obj in self.storage.get_keys_in_model(model):
                if getattr(obj, key) == val:
                    return obj
        return None

    def get_range(self, model, key, min, max):
        &#34;&#34;&#34;Searches for objects whose key lies between min and max.
        It tries to search for it in the index. If the key is not indexed it loops through all the objects.

        Args:
            model (ModelObj): The model in which the key is searched for.
            key (str): The model property that is checked for.
            min (value): The minimum.
            max (value): The maximum.

        Raises:
            RuntimeError: If the key is not a part of the schema.

        Returns:
            List[JSObjBase]: A list of matched objects (o: o.key &gt;= min and o.key &lt;= max)
        &#34;&#34;&#34;
        if key not in model.schema.props:
            raise RuntimeError(f&#34;{key} is not a part of {model.name}&#39;s schema&#34;)
        if not model.schema.props[key].index_key:
            return self.get_item_from_index_set(model, key, min, max)
        else:
            result = []
            for obj in self.storage.get_keys_in_model(model):
                    obj_val = getattr(obj, key)
                    if obj_val &gt;= min and obj_val &lt;= max:
                        result.append(obj)
            return result


    def get_item_from_index(self, model, key, val):
        &#34;&#34;&#34;Search for objects whose key equal val. The key must be indexed for search.

        Args:
            model (ModelObj): The model in which the key is searched for.
            key (str): The model property that is checked for.
            val (value): The value.

        Raises:
            RuntimeError: If the key is not a part of the schema.
            RuntimeError: If the key is not indexed for search.

        Returns:
            List[JSObjBase]: A list of matched objects (o: o.key == val)
        &#34;&#34;&#34;
        if key not in model.schema.props:
            raise RuntimeError(f&#34;{key} is not a part of {model.name}&#39;s schema&#34;)
        if not model.schema.props[key].index:
            raise RuntimeError(f&#34;{key} is not indexed.&#34;)
        keyid = self.indexer.get(model, key, val)
        return self.get_item_by_id(model, keyid) if keyid else None

    def get_item_from_index_set(self, model, key, min, max):
        &#34;&#34;&#34;Searches for objects whose key lies between min and max. The key must be indexed for range search.

        Args:
            model (ModelObj): The model in which the key is searched for.
            key (str): The model property that is checked for.
            min (value): The minimum.
            max (value): The maximum.

        Raises:
            RuntimeError: If the key is not a part of the schema.
            RuntimeError: If the key is not indexed for range search.

        Returns:
            List[JSObjBase]: A list of matched objects (o: o.key &gt;= min and o.key &lt;= max)
        &#34;&#34;&#34;
        if key not in model.schema.props:
            raise RuntimeError(f&#34;{key} is not a part of {model.name}&#39;s schema&#34;)
        if not model.schema.props[key].index_key:
            raise RuntimeError(f&#34;{key} is not indexed.&#34;)
        return [self.get_item_by_id(model, x[0]) for x in self.indexer_set.get(model, key, min, max)]


    def get_item_from_index_text(self, model, key, pattern):
        &#34;&#34;&#34;Searches for objects whose key matches the given pattern inside model. The key must be registered in the text index.

        Args:
            model (Modelobj): The model object in which the pattern is searched.
            key (str): The model property that the pattern is searched for in.
            pattern (str): The pattern to be searched for.

        Notes:
            Currently sonic server matches for some patterns and doesn&#39;t for others.

        Raises:
            RuntimeError: If the key is not defined in the model.
            RuntimeError: If the key is not indexed for search

        Returns:
            list[JSObjBase]: List of matching objects (o: o.key matches pattern).
        &#34;&#34;&#34;
        if key not in model.schema.props:
            raise RuntimeError(f&#34;{key} is not a part of {model.name}&#39;s schema&#34;)
        if not model.schema.props[key].index_text:
            raise RuntimeError(f&#34;{key} is not indexed for search.&#34;)
        return [self.get_item_by_id(model, int(x)) for x in self.indexer_text.get(model, key, pattern)]

    def get_model_by_name(self, model_name):
        &#34;&#34;&#34;Returns a Model object given its name.

        Args:
            model_name (str): The name of the model.

        Raises:
            RuntimeError: Raised when no model exists with the given.

        Returns:
            ModelObj: The model object.
        &#34;&#34;&#34;
        if model_name not in self.loaded_models:
            if model_name not in self.models:
                raise RuntimeError(&#34;Model not registered&#34;)
            self.loaded_models[model_name] = self.models[model_name](self)
        return self.loaded_models[model_name]</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="jumpscale.data.bcdb.bcdb.BCDB"><code class="flex name class">
<span>class <span class="ident">BCDB</span></span>
<span>(</span><span>ns)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BCDB:
    def __init__(self, ns):
        self.ns = ns
        self.storage = RedisStorageClient(ns)
        self.indexer = RedisIndexClient(ns)
        self.indexer_set = SQLiteIndexSetClient(ns)
        self.indexer_text = SonicIndexTextClient(ns)
        self.models = {

        }
        self.loaded_models = {

        }
        self.detect_models()
        self.model_model = self.models[&#34;model&#34;](self)

    def detect_models(self):
        &#34;&#34;&#34;It scans all the models and store its classes for later use.&#34;&#34;&#34;
        for model_name in dir(models):
            model = getattr(models, model_name)
            if isinstance(model, type) and issubclass(model, models.ModelBase):
                self.models[model._name] = model

    def save_obj(self, model, obj):
        &#34;&#34;&#34;Saves the given objects which belongs to model in the db and update the indexes.

        Args:
            model (ModelObj): The model object that obj belongs to.
            obj (JSObjBase): The object that will be saved.
        &#34;&#34;&#34;
        self.indexer_set.set(model, obj)
        self.indexer_text.set(model, obj)
        for prop in model.schema.props.values():
            old_obj = model.get_by(&#39;id&#39;, obj.id)
            prop_name = prop.name
            index_prop = getattr(obj, prop.name)
            old_index = getattr(old_obj, prop.name) if old_obj else None
            if prop.index:
                self.indexer.set(model, prop_name, index_prop, obj.id, old_index)
        self.storage.set(model, obj.id, obj)

    def model_id_incr(self, model):
        &#34;&#34;&#34;Increment the id counter in the model and returns the new id.
        Used to assign unique id for each created object.

        Args:
            model (ModelObj): The model object.

        Returns:
            int: The new unique id
        &#34;&#34;&#34;
        return self.storage.incr_id(model)

    def get_item_by_id(self, model, id):
        &#34;&#34;&#34;Gets the object in the model with the given id.

        Args:
            model (ModelObj): The model to be searched in.
            id (int): The object&#39;s id.

        Returns:
            JSObjBase or None: The JSObject with the given id. None if none was found.
        &#34;&#34;&#34;
        return self.storage.get(model, id)

    def get_entry(self, model, key, val):
        &#34;&#34;&#34;Search for objects whose key equal val.
        1. It searches in the redis index if key is indexed.
        2. Else, It&#39;s searched for in the sqlite index if the key is indexed for range search.
        3. Else, All objects in the db belonging to the given model is scanned linearly to determine the matching object.

        Args:
            model (ModelObj): The model in which the key is searched for.
            key (str): The model property that is checked for.
            val (value): The value.

        Raises:
            RuntimeError: If the key is not a part of the schema.

        Returns:
            JSObjBase or None: The matched object (o: o.key == val). None if none matched.
        &#34;&#34;&#34;
        if key not in model.schema.props:
            raise RuntimeError(f&#34;{key} is not a part of {model.name}&#39;s schema&#34;)
        if model.schema.props[key].index:
            return self.get_item_from_index(model, key, val)
        elif model.schema.props[key].index_key:
            found = self.get_item_from_index_set(model, key, val, val)
            return found[0] if found else None
        else:
            for obj in self.storage.get_keys_in_model(model):
                if getattr(obj, key) == val:
                    return obj
        return None

    def get_range(self, model, key, min, max):
        &#34;&#34;&#34;Searches for objects whose key lies between min and max.
        It tries to search for it in the index. If the key is not indexed it loops through all the objects.

        Args:
            model (ModelObj): The model in which the key is searched for.
            key (str): The model property that is checked for.
            min (value): The minimum.
            max (value): The maximum.

        Raises:
            RuntimeError: If the key is not a part of the schema.

        Returns:
            List[JSObjBase]: A list of matched objects (o: o.key &gt;= min and o.key &lt;= max)
        &#34;&#34;&#34;
        if key not in model.schema.props:
            raise RuntimeError(f&#34;{key} is not a part of {model.name}&#39;s schema&#34;)
        if not model.schema.props[key].index_key:
            return self.get_item_from_index_set(model, key, min, max)
        else:
            result = []
            for obj in self.storage.get_keys_in_model(model):
                    obj_val = getattr(obj, key)
                    if obj_val &gt;= min and obj_val &lt;= max:
                        result.append(obj)
            return result


    def get_item_from_index(self, model, key, val):
        &#34;&#34;&#34;Search for objects whose key equal val. The key must be indexed for search.

        Args:
            model (ModelObj): The model in which the key is searched for.
            key (str): The model property that is checked for.
            val (value): The value.

        Raises:
            RuntimeError: If the key is not a part of the schema.
            RuntimeError: If the key is not indexed for search.

        Returns:
            List[JSObjBase]: A list of matched objects (o: o.key == val)
        &#34;&#34;&#34;
        if key not in model.schema.props:
            raise RuntimeError(f&#34;{key} is not a part of {model.name}&#39;s schema&#34;)
        if not model.schema.props[key].index:
            raise RuntimeError(f&#34;{key} is not indexed.&#34;)
        keyid = self.indexer.get(model, key, val)
        return self.get_item_by_id(model, keyid) if keyid else None

    def get_item_from_index_set(self, model, key, min, max):
        &#34;&#34;&#34;Searches for objects whose key lies between min and max. The key must be indexed for range search.

        Args:
            model (ModelObj): The model in which the key is searched for.
            key (str): The model property that is checked for.
            min (value): The minimum.
            max (value): The maximum.

        Raises:
            RuntimeError: If the key is not a part of the schema.
            RuntimeError: If the key is not indexed for range search.

        Returns:
            List[JSObjBase]: A list of matched objects (o: o.key &gt;= min and o.key &lt;= max)
        &#34;&#34;&#34;
        if key not in model.schema.props:
            raise RuntimeError(f&#34;{key} is not a part of {model.name}&#39;s schema&#34;)
        if not model.schema.props[key].index_key:
            raise RuntimeError(f&#34;{key} is not indexed.&#34;)
        return [self.get_item_by_id(model, x[0]) for x in self.indexer_set.get(model, key, min, max)]


    def get_item_from_index_text(self, model, key, pattern):
        &#34;&#34;&#34;Searches for objects whose key matches the given pattern inside model. The key must be registered in the text index.

        Args:
            model (Modelobj): The model object in which the pattern is searched.
            key (str): The model property that the pattern is searched for in.
            pattern (str): The pattern to be searched for.

        Notes:
            Currently sonic server matches for some patterns and doesn&#39;t for others.

        Raises:
            RuntimeError: If the key is not defined in the model.
            RuntimeError: If the key is not indexed for search

        Returns:
            list[JSObjBase]: List of matching objects (o: o.key matches pattern).
        &#34;&#34;&#34;
        if key not in model.schema.props:
            raise RuntimeError(f&#34;{key} is not a part of {model.name}&#39;s schema&#34;)
        if not model.schema.props[key].index_text:
            raise RuntimeError(f&#34;{key} is not indexed for search.&#34;)
        return [self.get_item_by_id(model, int(x)) for x in self.indexer_text.get(model, key, pattern)]

    def get_model_by_name(self, model_name):
        &#34;&#34;&#34;Returns a Model object given its name.

        Args:
            model_name (str): The name of the model.

        Raises:
            RuntimeError: Raised when no model exists with the given.

        Returns:
            ModelObj: The model object.
        &#34;&#34;&#34;
        if model_name not in self.loaded_models:
            if model_name not in self.models:
                raise RuntimeError(&#34;Model not registered&#34;)
            self.loaded_models[model_name] = self.models[model_name](self)
        return self.loaded_models[model_name]</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="jumpscale.data.bcdb.bcdb.BCDB.detect_models"><code class="name flex">
<span>def <span class="ident">detect_models</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>It scans all the models and store its classes for later use.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def detect_models(self):
    &#34;&#34;&#34;It scans all the models and store its classes for later use.&#34;&#34;&#34;
    for model_name in dir(models):
        model = getattr(models, model_name)
        if isinstance(model, type) and issubclass(model, models.ModelBase):
            self.models[model._name] = model</code></pre>
</details>
</dd>
<dt id="jumpscale.data.bcdb.bcdb.BCDB.get_entry"><code class="name flex">
<span>def <span class="ident">get_entry</span></span>(<span>self, model, key, val)</span>
</code></dt>
<dd>
<div class="desc"><p>Search for objects whose key equal val.
1. It searches in the redis index if key is indexed.
2. Else, It's searched for in the sqlite index if the key is indexed for range search.
3. Else, All objects in the db belonging to the given model is scanned linearly to determine the matching object.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>model</code></strong> :&ensp;<code>ModelObj</code></dt>
<dd>The model in which the key is searched for.</dd>
<dt><strong><code>key</code></strong> :&ensp;<code>str</code></dt>
<dd>The model property that is checked for.</dd>
<dt><strong><code>val</code></strong> :&ensp;<code>value</code></dt>
<dd>The value.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>RuntimeError</code></dt>
<dd>If the key is not a part of the schema.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>JSObjBase</code> or <code>None</code></dt>
<dd>The matched object (o: o.key == val). None if none matched.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_entry(self, model, key, val):
    &#34;&#34;&#34;Search for objects whose key equal val.
    1. It searches in the redis index if key is indexed.
    2. Else, It&#39;s searched for in the sqlite index if the key is indexed for range search.
    3. Else, All objects in the db belonging to the given model is scanned linearly to determine the matching object.

    Args:
        model (ModelObj): The model in which the key is searched for.
        key (str): The model property that is checked for.
        val (value): The value.

    Raises:
        RuntimeError: If the key is not a part of the schema.

    Returns:
        JSObjBase or None: The matched object (o: o.key == val). None if none matched.
    &#34;&#34;&#34;
    if key not in model.schema.props:
        raise RuntimeError(f&#34;{key} is not a part of {model.name}&#39;s schema&#34;)
    if model.schema.props[key].index:
        return self.get_item_from_index(model, key, val)
    elif model.schema.props[key].index_key:
        found = self.get_item_from_index_set(model, key, val, val)
        return found[0] if found else None
    else:
        for obj in self.storage.get_keys_in_model(model):
            if getattr(obj, key) == val:
                return obj
    return None</code></pre>
</details>
</dd>
<dt id="jumpscale.data.bcdb.bcdb.BCDB.get_item_by_id"><code class="name flex">
<span>def <span class="ident">get_item_by_id</span></span>(<span>self, model, id)</span>
</code></dt>
<dd>
<div class="desc"><p>Gets the object in the model with the given id.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>model</code></strong> :&ensp;<code>ModelObj</code></dt>
<dd>The model to be searched in.</dd>
<dt><strong><code>id</code></strong> :&ensp;<code>int</code></dt>
<dd>The object's id.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>JSObjBase</code> or <code>None</code></dt>
<dd>The JSObject with the given id. None if none was found.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_item_by_id(self, model, id):
    &#34;&#34;&#34;Gets the object in the model with the given id.

    Args:
        model (ModelObj): The model to be searched in.
        id (int): The object&#39;s id.

    Returns:
        JSObjBase or None: The JSObject with the given id. None if none was found.
    &#34;&#34;&#34;
    return self.storage.get(model, id)</code></pre>
</details>
</dd>
<dt id="jumpscale.data.bcdb.bcdb.BCDB.get_item_from_index"><code class="name flex">
<span>def <span class="ident">get_item_from_index</span></span>(<span>self, model, key, val)</span>
</code></dt>
<dd>
<div class="desc"><p>Search for objects whose key equal val. The key must be indexed for search.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>model</code></strong> :&ensp;<code>ModelObj</code></dt>
<dd>The model in which the key is searched for.</dd>
<dt><strong><code>key</code></strong> :&ensp;<code>str</code></dt>
<dd>The model property that is checked for.</dd>
<dt><strong><code>val</code></strong> :&ensp;<code>value</code></dt>
<dd>The value.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>RuntimeError</code></dt>
<dd>If the key is not a part of the schema.</dd>
<dt><code>RuntimeError</code></dt>
<dd>If the key is not indexed for search.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>List[JSObjBase]</code></dt>
<dd>A list of matched objects (o: o.key == val)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_item_from_index(self, model, key, val):
    &#34;&#34;&#34;Search for objects whose key equal val. The key must be indexed for search.

    Args:
        model (ModelObj): The model in which the key is searched for.
        key (str): The model property that is checked for.
        val (value): The value.

    Raises:
        RuntimeError: If the key is not a part of the schema.
        RuntimeError: If the key is not indexed for search.

    Returns:
        List[JSObjBase]: A list of matched objects (o: o.key == val)
    &#34;&#34;&#34;
    if key not in model.schema.props:
        raise RuntimeError(f&#34;{key} is not a part of {model.name}&#39;s schema&#34;)
    if not model.schema.props[key].index:
        raise RuntimeError(f&#34;{key} is not indexed.&#34;)
    keyid = self.indexer.get(model, key, val)
    return self.get_item_by_id(model, keyid) if keyid else None</code></pre>
</details>
</dd>
<dt id="jumpscale.data.bcdb.bcdb.BCDB.get_item_from_index_set"><code class="name flex">
<span>def <span class="ident">get_item_from_index_set</span></span>(<span>self, model, key, min, max)</span>
</code></dt>
<dd>
<div class="desc"><p>Searches for objects whose key lies between min and max. The key must be indexed for range search.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>model</code></strong> :&ensp;<code>ModelObj</code></dt>
<dd>The model in which the key is searched for.</dd>
<dt><strong><code>key</code></strong> :&ensp;<code>str</code></dt>
<dd>The model property that is checked for.</dd>
<dt><strong><code>min</code></strong> :&ensp;<code>value</code></dt>
<dd>The minimum.</dd>
<dt><strong><code>max</code></strong> :&ensp;<code>value</code></dt>
<dd>The maximum.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>RuntimeError</code></dt>
<dd>If the key is not a part of the schema.</dd>
<dt><code>RuntimeError</code></dt>
<dd>If the key is not indexed for range search.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>List[JSObjBase]</code></dt>
<dd>A list of matched objects (o: o.key &gt;= min and o.key &lt;= max)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_item_from_index_set(self, model, key, min, max):
    &#34;&#34;&#34;Searches for objects whose key lies between min and max. The key must be indexed for range search.

    Args:
        model (ModelObj): The model in which the key is searched for.
        key (str): The model property that is checked for.
        min (value): The minimum.
        max (value): The maximum.

    Raises:
        RuntimeError: If the key is not a part of the schema.
        RuntimeError: If the key is not indexed for range search.

    Returns:
        List[JSObjBase]: A list of matched objects (o: o.key &gt;= min and o.key &lt;= max)
    &#34;&#34;&#34;
    if key not in model.schema.props:
        raise RuntimeError(f&#34;{key} is not a part of {model.name}&#39;s schema&#34;)
    if not model.schema.props[key].index_key:
        raise RuntimeError(f&#34;{key} is not indexed.&#34;)
    return [self.get_item_by_id(model, x[0]) for x in self.indexer_set.get(model, key, min, max)]</code></pre>
</details>
</dd>
<dt id="jumpscale.data.bcdb.bcdb.BCDB.get_item_from_index_text"><code class="name flex">
<span>def <span class="ident">get_item_from_index_text</span></span>(<span>self, model, key, pattern)</span>
</code></dt>
<dd>
<div class="desc"><p>Searches for objects whose key matches the given pattern inside model. The key must be registered in the text index.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>model</code></strong> :&ensp;<code>Modelobj</code></dt>
<dd>The model object in which the pattern is searched.</dd>
<dt><strong><code>key</code></strong> :&ensp;<code>str</code></dt>
<dd>The model property that the pattern is searched for in.</dd>
<dt><strong><code>pattern</code></strong> :&ensp;<code>str</code></dt>
<dd>The pattern to be searched for.</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>Currently sonic server matches for some patterns and doesn't for others.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>RuntimeError</code></dt>
<dd>If the key is not defined in the model.</dd>
<dt><code>RuntimeError</code></dt>
<dd>If the key is not indexed for search</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list[JSObjBase]</code></dt>
<dd>List of matching objects (o: o.key matches pattern).</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_item_from_index_text(self, model, key, pattern):
    &#34;&#34;&#34;Searches for objects whose key matches the given pattern inside model. The key must be registered in the text index.

    Args:
        model (Modelobj): The model object in which the pattern is searched.
        key (str): The model property that the pattern is searched for in.
        pattern (str): The pattern to be searched for.

    Notes:
        Currently sonic server matches for some patterns and doesn&#39;t for others.

    Raises:
        RuntimeError: If the key is not defined in the model.
        RuntimeError: If the key is not indexed for search

    Returns:
        list[JSObjBase]: List of matching objects (o: o.key matches pattern).
    &#34;&#34;&#34;
    if key not in model.schema.props:
        raise RuntimeError(f&#34;{key} is not a part of {model.name}&#39;s schema&#34;)
    if not model.schema.props[key].index_text:
        raise RuntimeError(f&#34;{key} is not indexed for search.&#34;)
    return [self.get_item_by_id(model, int(x)) for x in self.indexer_text.get(model, key, pattern)]</code></pre>
</details>
</dd>
<dt id="jumpscale.data.bcdb.bcdb.BCDB.get_model_by_name"><code class="name flex">
<span>def <span class="ident">get_model_by_name</span></span>(<span>self, model_name)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a Model object given its name.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>model_name</code></strong> :&ensp;<code>str</code></dt>
<dd>The name of the model.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>RuntimeError</code></dt>
<dd>Raised when no model exists with the given.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>ModelObj</code></dt>
<dd>The model object.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_model_by_name(self, model_name):
    &#34;&#34;&#34;Returns a Model object given its name.

    Args:
        model_name (str): The name of the model.

    Raises:
        RuntimeError: Raised when no model exists with the given.

    Returns:
        ModelObj: The model object.
    &#34;&#34;&#34;
    if model_name not in self.loaded_models:
        if model_name not in self.models:
            raise RuntimeError(&#34;Model not registered&#34;)
        self.loaded_models[model_name] = self.models[model_name](self)
    return self.loaded_models[model_name]</code></pre>
</details>
</dd>
<dt id="jumpscale.data.bcdb.bcdb.BCDB.get_range"><code class="name flex">
<span>def <span class="ident">get_range</span></span>(<span>self, model, key, min, max)</span>
</code></dt>
<dd>
<div class="desc"><p>Searches for objects whose key lies between min and max.
It tries to search for it in the index. If the key is not indexed it loops through all the objects.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>model</code></strong> :&ensp;<code>ModelObj</code></dt>
<dd>The model in which the key is searched for.</dd>
<dt><strong><code>key</code></strong> :&ensp;<code>str</code></dt>
<dd>The model property that is checked for.</dd>
<dt><strong><code>min</code></strong> :&ensp;<code>value</code></dt>
<dd>The minimum.</dd>
<dt><strong><code>max</code></strong> :&ensp;<code>value</code></dt>
<dd>The maximum.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>RuntimeError</code></dt>
<dd>If the key is not a part of the schema.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>List[JSObjBase]</code></dt>
<dd>A list of matched objects (o: o.key &gt;= min and o.key &lt;= max)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_range(self, model, key, min, max):
    &#34;&#34;&#34;Searches for objects whose key lies between min and max.
    It tries to search for it in the index. If the key is not indexed it loops through all the objects.

    Args:
        model (ModelObj): The model in which the key is searched for.
        key (str): The model property that is checked for.
        min (value): The minimum.
        max (value): The maximum.

    Raises:
        RuntimeError: If the key is not a part of the schema.

    Returns:
        List[JSObjBase]: A list of matched objects (o: o.key &gt;= min and o.key &lt;= max)
    &#34;&#34;&#34;
    if key not in model.schema.props:
        raise RuntimeError(f&#34;{key} is not a part of {model.name}&#39;s schema&#34;)
    if not model.schema.props[key].index_key:
        return self.get_item_from_index_set(model, key, min, max)
    else:
        result = []
        for obj in self.storage.get_keys_in_model(model):
                obj_val = getattr(obj, key)
                if obj_val &gt;= min and obj_val &lt;= max:
                    result.append(obj)
        return result</code></pre>
</details>
</dd>
<dt id="jumpscale.data.bcdb.bcdb.BCDB.model_id_incr"><code class="name flex">
<span>def <span class="ident">model_id_incr</span></span>(<span>self, model)</span>
</code></dt>
<dd>
<div class="desc"><p>Increment the id counter in the model and returns the new id.
Used to assign unique id for each created object.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>model</code></strong> :&ensp;<code>ModelObj</code></dt>
<dd>The model object.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code></dt>
<dd>The new unique id</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def model_id_incr(self, model):
    &#34;&#34;&#34;Increment the id counter in the model and returns the new id.
    Used to assign unique id for each created object.

    Args:
        model (ModelObj): The model object.

    Returns:
        int: The new unique id
    &#34;&#34;&#34;
    return self.storage.incr_id(model)</code></pre>
</details>
</dd>
<dt id="jumpscale.data.bcdb.bcdb.BCDB.save_obj"><code class="name flex">
<span>def <span class="ident">save_obj</span></span>(<span>self, model, obj)</span>
</code></dt>
<dd>
<div class="desc"><p>Saves the given objects which belongs to model in the db and update the indexes.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>model</code></strong> :&ensp;<code>ModelObj</code></dt>
<dd>The model object that obj belongs to.</dd>
<dt><strong><code>obj</code></strong> :&ensp;<code>JSObjBase</code></dt>
<dd>The object that will be saved.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save_obj(self, model, obj):
    &#34;&#34;&#34;Saves the given objects which belongs to model in the db and update the indexes.

    Args:
        model (ModelObj): The model object that obj belongs to.
        obj (JSObjBase): The object that will be saved.
    &#34;&#34;&#34;
    self.indexer_set.set(model, obj)
    self.indexer_text.set(model, obj)
    for prop in model.schema.props.values():
        old_obj = model.get_by(&#39;id&#39;, obj.id)
        prop_name = prop.name
        index_prop = getattr(obj, prop.name)
        old_index = getattr(old_obj, prop.name) if old_obj else None
        if prop.index:
            self.indexer.set(model, prop_name, index_prop, obj.id, old_index)
    self.storage.set(model, obj.id, obj)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="jumpscale.data.bcdb" href="index.html">jumpscale.data.bcdb</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="jumpscale.data.bcdb.bcdb.BCDB" href="#jumpscale.data.bcdb.bcdb.BCDB">BCDB</a></code></h4>
<ul class="">
<li><code><a title="jumpscale.data.bcdb.bcdb.BCDB.detect_models" href="#jumpscale.data.bcdb.bcdb.BCDB.detect_models">detect_models</a></code></li>
<li><code><a title="jumpscale.data.bcdb.bcdb.BCDB.get_entry" href="#jumpscale.data.bcdb.bcdb.BCDB.get_entry">get_entry</a></code></li>
<li><code><a title="jumpscale.data.bcdb.bcdb.BCDB.get_item_by_id" href="#jumpscale.data.bcdb.bcdb.BCDB.get_item_by_id">get_item_by_id</a></code></li>
<li><code><a title="jumpscale.data.bcdb.bcdb.BCDB.get_item_from_index" href="#jumpscale.data.bcdb.bcdb.BCDB.get_item_from_index">get_item_from_index</a></code></li>
<li><code><a title="jumpscale.data.bcdb.bcdb.BCDB.get_item_from_index_set" href="#jumpscale.data.bcdb.bcdb.BCDB.get_item_from_index_set">get_item_from_index_set</a></code></li>
<li><code><a title="jumpscale.data.bcdb.bcdb.BCDB.get_item_from_index_text" href="#jumpscale.data.bcdb.bcdb.BCDB.get_item_from_index_text">get_item_from_index_text</a></code></li>
<li><code><a title="jumpscale.data.bcdb.bcdb.BCDB.get_model_by_name" href="#jumpscale.data.bcdb.bcdb.BCDB.get_model_by_name">get_model_by_name</a></code></li>
<li><code><a title="jumpscale.data.bcdb.bcdb.BCDB.get_range" href="#jumpscale.data.bcdb.bcdb.BCDB.get_range">get_range</a></code></li>
<li><code><a title="jumpscale.data.bcdb.bcdb.BCDB.model_id_incr" href="#jumpscale.data.bcdb.bcdb.BCDB.model_id_incr">model_id_incr</a></code></li>
<li><code><a title="jumpscale.data.bcdb.bcdb.BCDB.save_obj" href="#jumpscale.data.bcdb.bcdb.BCDB.save_obj">save_obj</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>
