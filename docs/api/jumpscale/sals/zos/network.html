<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.6.4" />
<title>jumpscale.sals.zos.network API documentation</title>
<meta name="description" content="" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase;cursor:pointer}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>jumpscale.sals.zos.network</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>Source code</summary>
<pre><code class="python">import random

import netaddr
from nacl import public
from nacl.encoding import Base64Encoder

from jumpscale.clients.explorer.models import NetworkResource, NextAction, WireguardPeer, WorkloadType
from jumpscale.core.exceptions import Input
from jumpscale.loader import j
from jumpscale.tools.wireguard import generate_zos_keys


class Network:
    class Info:
        def __init__(self):
            self.workload_type = WorkloadType.Network_resource

    def __init__(self, name, iprange):
        self.info = self.Info()
        self.name = name
        self.iprange = iprange
        self.network_resources = []


class NetworkGenerator:
    def __init__(self, identity):
        explorer = identity.explorer
        self._identity = identity
        self._nodes = explorer.nodes
        self._farms = explorer.farms
        self._workloads = explorer.workloads

    def _load_network(self, network):
        for nr in network.network_resources:
            nr.public_endpoints = get_endpoints(self._nodes.get(nr.info.node_id))

        network.access_points = extract_access_points(network)

    def _cleanup_network(self, network):
        for nr in network.network_resources:
            if hasattr(nr, &#34;public_endpoints&#34;):
                delattr(nr, &#34;public_endpoints&#34;)

        if hasattr(network, &#34;access_points&#34;):
            delattr(network, &#34;access_points&#34;)

    def create(self, ip_range: str, network_name: str = None) -&gt; Network:
        &#34;&#34;&#34;create a new network

        Args:
          ip_range(str): IP range (cidr) of the full network. The network mask must be /16
          network_name(str, optional): name of the network. If None, a random name will be generated, defaults to None

        Returns:
          Network: Network

        Raises:
          Input: if ip_range not a private range (RFC 1918)
          Input: if network mask of ip_range is not /16

        &#34;&#34;&#34;
        network = netaddr.IPNetwork(ip_range)
        if not is_private(network):
            raise Input(&#34;ip_range must be a private network range (RFC 1918)&#34;)
        if network.prefixlen != 16:
            raise Input(&#34;network mask of ip range must be a /16&#34;)
        network = Network(network_name, ip_range)
        return network

    def add_node(self, network: Network, node_id: str, ip_range: str, pool_id: int, wg_port: int = None):
        &#34;&#34;&#34;add a node into the network

        Args:
          network(Network): network object
          node_id(str): ID of the node to add to the network
          ip_range(str): IP range (cidr) to assign to the node inside the network. The network mask must be a /24
          pool_id(int): the capacity pool ID
          wg_port(int, optional

        Raises:
          Input: if mask of ip_range is not /24
          Input: If specified access node not part of the network
          Input: If access node point doesn&#39;t have a public endpoint
          Input: If access node point doesn&#39;t have pubic endpoint of requested type): wireguar port of the wireguard endpoint. If None it will be picked automatically, defaults to None

        Returns:

        &#34;&#34;&#34;
        node = self._nodes.get(node_id)

        if netaddr.IPNetwork(ip_range).prefixlen != 24:
            raise Input(&#34;ip_range should have a netmask of /24, not /%d&#34;, ip_range.prefixlen)

        if wg_port is None:
            wg_port = _find_free_wg_port(node)

        _, wg_private_encrypted, wg_public = generate_zos_keys(node.public_key_hex)

        nr = NetworkResource()
        nr.info.pool_id = pool_id
        nr.info.workload_type = WorkloadType.Network_resource
        nr.network_iprange = network.iprange
        nr.iprange = ip_range
        nr.info.node_id = node_id
        nr.wireguard_listen_port = wg_port
        nr.wireguard_public_key = wg_public
        nr.wireguard_private_key_encrypted = wg_private_encrypted
        nr.name = network.name
        network.network_resources.append(nr)
        try:
            self._load_network(network)
            generate_peers(network)
        finally:
            self._cleanup_network(network)

    def add_access(
        self, network: Network, node_id: str, ip_range: str, wg_public_key: str = None, ipv4: bool = False
    ) -&gt; str:
        &#34;&#34;&#34;add an external access to the network. use this function if you want to allow
        a peer to your network that is not a 0-OS node like User laptop, external server,...

        Args:
          network(Network): network object
          node_id(str): ID of the node to use as entrypoint to the network
          ip_range(str): IP range to allocate for this peer
          wg_public_key(str, optional): wireguard public key of the peer. If not specify a new key will be generated, defaults to None
          ipv4(bool, optional): If True, use an IPv4 address as endpoint to connect to the network otherwise use IPv6, defaults to False

        Returns:
          str: the wireguard configuration to be used by the peer to connect to the network

        &#34;&#34;&#34;
        if netaddr.IPNetwork(ip_range).prefixlen != 24:
            raise Input(&#34;ip_range should have a netmask of /24, not /%d&#34;, ip_range.prefixlen)

        try:
            self._load_network(network)

            access_point_nr = None
            for nr in network.network_resources:
                if node_id == nr.info.node_id:
                    access_point_nr = nr

            if access_point_nr is None:
                raise Input(&#34;can not add access through a node which is not in the network&#34;)

            if len(access_point_nr.public_endpoints) == 0:
                raise Input(&#34;access node must have at least 1 public endpoint&#34;)

            endpoint = &#34;&#34;
            wg_port = access_point_nr.wireguard_listen_port
            for ep in access_point_nr.public_endpoints:
                if ipv4 and ep.version == 4:
                    endpoint = f&#34;{str(ep.ip)}:{wg_port}&#34;
                    break
                if not ipv4 and ep.version == 6:
                    ip = str(ep.ip)
                    endpoint = f&#34;[{ip}]:{wg_port}&#34;
                    break

            if not endpoint:
                raise Input(&#34;access node has no public endpoint of the requested type&#34;)

            wg_private_key = &#34;&#34;
            if not wg_public_key:
                wg_private = public.PrivateKey.generate()
                wg_public = wg_private.public_key
                wg_private_key = wg_private.encode(Base64Encoder).decode()
                wg_public_key = wg_public.encode(Base64Encoder).decode()

            network.access_points.append(
                AccessPoint(node_id=node_id, subnet=ip_range, wg_public_key=wg_public_key, ip4=ipv4)
            )

            generate_peers(network)

        finally:
            self._cleanup_network(network)

        return generate_wg_quick(
            wg_private_key, ip_range, access_point_nr.wireguard_public_key, network.iprange, endpoint
        )

    def delete_access(self, network: Network, node_id: str, iprange: str) -&gt; Network:
        &#34;&#34;&#34;remove a peer that was added using add_access method
        use this is you want to revoke the access to the network from someone

        Args:
          network(Network): network object
          node_id(str): ID of the node to use as entrypoint to the network
          ip_range(str): IP range to allocate for this peer

        Returns:
          Network: Network

        &#34;&#34;&#34;
        node_workloads = {}
        node_ranges = set()
        for net_workload in network.network_resources:
            node_workloads[net_workload.info.node_id] = net_workload
            node_ranges.add(net_workload.iprange)
        if iprange in node_ranges:
            raise Input(&#34;Can&#39;t delete zos node peer&#34;)

        access_workload = node_workloads.get(node_id)
        if not access_workload:
            raise Input(f&#34;Node {node_id} is not part of network&#34;)
        # remove peer from access node
        new_peers = []
        for peer in access_workload.peers:
            if peer.iprange != iprange:
                new_peers.append(peer)
        access_workload.peers = new_peers
        # remove peer from allowed ips on all nodes
        access_node_range = node_workloads[node_id]
        routing_range = wg_routing_ip(iprange)
        for network_resource in node_workloads.values():
            for peer in network_resource.peers:
                if peer.iprange != access_node_range:
                    if iprange in peer.allowed_iprange:
                        peer.allowed_iprange.remove(iprange)
                    if routing_range in peer.allowed_iprange:
                        peer.allowed_iprange.remove(routing_range)
        return network

    def load_network(self, network_name: str) -&gt; Network:
        &#34;&#34;&#34;load network fetch all network resource belonging to the same network
        and re-create the full network object

        if make sure to only take the latest version of each network resource

        use this function if you need to modify and existing network

        Args:
          network_name(str): the name of the network to load
          network_name: str:

        Returns:
          Network: Network object

        &#34;&#34;&#34;
        tid = self._identity.tid
        nrs = {}
        # first gather all the latest version of each network resource for this network
        for w in self._workloads.iter(customer_tid=tid, next_action=NextAction.DEPLOY.name):
            if w.info.workload_type == WorkloadType.Network_resource and w.name == network_name:
                nrs[w.info.node_id] = w

        network = None
        for nr in nrs.values():
            # ensure all network resource have the same network iprange
            # if this is not the case, then we have an issue
            if network is None:
                network = Network(network_name, nr.network_iprange)
            else:
                if w.network_iprange != network.iprange:
                    raise j.exceptions.Value(
                        f&#34;found a network resource with IP range ({nr.network_iprange}) different from the network IP range ({network.iprange})&#34;
                    )

            nr.info.reference = &#34;&#34;  # just to handle possible migrated network
            network.network_resources.append(nr)

        return network


def generate_peers(network):
    &#34;&#34;&#34;Generate  peers in the network
    &#34;&#34;&#34;
    public_nr = None
    if has_hidden_nodes(network):
        public_nr = find_public_node(network.network_resources)

    # We also need to inform nodes how to route the external access subnets.
    # Working with the knowledge that these external subnets come in through
    # the network through a single access point, which is part of the network
    # and thus already routed, we can map the external subnets to the subnet
    # of the access point, and add these external subnets to all peers who also
    # have the associated internal subnet.

    # Map the network subnets to their respective node ids first for easy access later
    internal_subnets = {}
    for nr in network.network_resources:
        internal_subnets[nr.info.node_id] = nr.iprange

    external_subnet = {}
    for ap in network.access_points:
        internal_sub = internal_subnets[ap.node_id]
        if internal_sub not in external_subnet:
            external_subnet[internal_sub] = []
        external_subnet[internal_sub].append(ap.subnet)

    # Maintain a mapping of access point nodes to the subnet and wg key they give access
    # to, as these need to be added as peers as well for these nodes
    access_points = {}
    for ap in network.access_points:
        if ap.node_id not in access_points:
            access_points[ap.node_id] = []
        access_points[ap.node_id].append(ap)

    # Find all hidden nodes, and collect their subnets. Also collect the subnets
    # of public IPv6 only nodes, since hidden nodes need IPv4 to connect.
    hidden_subnets = {}
    # also maintain subnets from nodes who have only IPv6 since this will also
    # need to be routed for hidden nodes
    ipv6_only_subnets = {}
    for nr in network.network_resources:
        if len(nr.public_endpoints) == 0:
            hidden_subnets[nr.info.node_id] = nr.iprange
            continue

        if not has_ipv4(nr):
            ipv6_only_subnets[nr.info.node_id] = nr.iprange

    for nr in network.network_resources:
        nr.peers = []
        for onr in network.network_resources:
            # skip ourself
            if nr.info.node_id == onr.info.node_id:
                continue

            endpoint = &#34;&#34;
            allowed_ips = set()
            allowed_ips.add(onr.iprange)
            allowed_ips.add(wg_routing_ip(onr.iprange))

            if len(nr.public_endpoints) == 0:
                # If node is hidden, set only public peers (with IPv4), and set first public peer to
                # contain all hidden subnets, except for the one owned by the node
                if not has_ipv4(onr):
                    continue

                # Also add all other subnets if this is the pub node
                if public_nr and onr.info.node_id == public_nr.info.node_id:
                    for owner, subnet in hidden_subnets.items():
                        # Do not add our own subnet
                        if owner == nr.info.node_id:
                            continue

                        allowed_ips.add(subnet)
                        allowed_ips.add(wg_routing_ip(subnet))

                    for subnet in ipv6_only_subnets.values():
                        allowed_ips.add(subnet)
                        allowed_ips.add(wg_routing_ip(subnet))

                    for pep in onr.public_endpoints:
                        if pep.version == 4:
                            endpoint = f&#34;{str(pep.ip)}.{onr.wireguard_listen_port}&#34;
                            break

                # Endpoint must be IPv4
                for pep in onr.public_endpoints:
                    if pep.version == 4:
                        endpoint = f&#34;{str(pep.ip)}:{onr.wireguard_listen_port}&#34;
                        break

            elif len(onr.public_endpoints) == 0 and has_ipv4(nr):
                # if the peer is hidden but we have IPv4,  we can connect to it, but we don&#39;t know an endpoint.
                endpoint = &#34;&#34;
            else:
                # if we are not hidden, we add all other nodes, unless we don&#39;t
                # have IPv4, because then we also can&#39;t connect to hidden nodes.
                # Ignore hidden nodes if we don&#39;t have IPv4
                if not has_ipv4(nr) and len(onr.public_endpoints) == 0:
                    continue

                # both nodes are public therefore we can connect over IPv6

                # if this is the selected public_nr - also need to add allowedIPs for the hidden nodes
                if public_nr and onr.info.node_id == public_nr.info.node_id:
                    for subnet in hidden_subnets.values():
                        allowed_ips.add(subnet)
                        allowed_ips.add(wg_routing_ip(subnet))

                # Since the node is not hidden, we know that it MUST have at least 1 IPv6 address
                for pep in onr.public_endpoints:
                    if pep.version == 6:
                        endpoint = f&#34;[{str(pep.ip)}]:{onr.wireguard_listen_port}&#34;
                        break

                # as a fallback assign IPv4
                if endpoint == &#34;&#34;:
                    for pep in onr.public_endpoints:
                        if pep.version == 4:
                            endpoint = f&#34;{pep.ip}:{onr.wireguard_listen_port}&#34;
                            break

            # Add subnets for external access
            new_allowed_ips = set()
            for aip in allowed_ips:
                new_allowed_ips.add(aip)
                for subnet in external_subnet.get(aip, []):
                    new_allowed_ips.add(subnet)
                    new_allowed_ips.add(wg_routing_ip(subnet))
            allowed_ips = new_allowed_ips

            peer = WireguardPeer()
            peer.iprange = str(onr.iprange)
            peer.endpoint = endpoint
            peer.allowed_iprange = [str(x) for x in allowed_ips]
            peer.public_key = onr.wireguard_public_key
            nr.peers.append(peer)
        #  Add configured external access peers
        for ea in access_points.get(nr.info.node_id, []):
            allowed_ips = [str(ea.subnet), wg_routing_ip(ea.subnet)]

            peer = WireguardPeer()
            peer.iprange = ea.subnet
            peer.endpoint = &#34;&#34;
            peer.allowed_iprange = [str(x) for x in allowed_ips]
            peer.public_key = ea.wg_public_key if isinstance(ea.wg_public_key, str) else ea.wg_public_key.decode()
            nr.peers.append(peer)


def has_hidden_nodes(network):
    &#34;&#34;&#34;

    Args:
      network:

    Returns:

    &#34;&#34;&#34;
    for nr in network.network_resources:
        if len(nr.public_endpoints) &lt;= 0:
            return True
    return False


def find_public_node(network_resources):
    &#34;&#34;&#34;

    Args:
      network_resources:

    Returns:

    &#34;&#34;&#34;
    for nr in network_resources:
        if has_ipv4(nr):
            return nr
    return None


def has_ipv4(network_resource):
    &#34;&#34;&#34;

    Args:
      network_resource:

    Returns:

    &#34;&#34;&#34;
    for pep in network_resource.public_endpoints:
        if pep.version == 4:
            return True
    return False


def wg_routing_ip(ip_range):
    &#34;&#34;&#34;

    Args:
      ip_range:

    Returns:

    &#34;&#34;&#34;
    if not isinstance(ip_range, netaddr.IPNetwork):
        ip_range = netaddr.IPNetwork(ip_range)
    words = ip_range.ip.words
    return f&#34;100.64.{words[1]}.{words[2]}/32&#34;


def _find_free_wg_port(node):
    &#34;&#34;&#34;

    Args:
      node:

    Returns:

    &#34;&#34;&#34;
    ports = set(list(range(1000, 9000)))
    used = set(node.wg_ports)
    free = ports - used
    return random.choice(tuple(free))


# a node has either a public namespace with []ipv4 or/and []ipv6 -or-
# some interface has received a SLAAC addr
# which has been registered in BCDB
def get_endpoints(node):
    &#34;&#34;&#34;

    Args:
      node:

    Returns:

    &#34;&#34;&#34;
    ips = []
    if node.public_config and node.public_config.master:
        ips.append(netaddr.IPNetwork(node.public_config.ipv4))
        ips.append(netaddr.IPNetwork(node.public_config.ipv6))
    else:
        for iface in node.ifaces:
            for ip in iface.addrs:
                ips.append(netaddr.IPNetwork(ip))

    endpoints = []
    for ip in ips:
        if ip.is_unicast() and not is_private(ip):
            endpoints.append(ip)
    return endpoints


_private_networks = [
    netaddr.IPNetwork(&#34;127.0.0.0/8&#34;),  # IPv4 loopback
    netaddr.IPNetwork(&#34;10.0.0.0/8&#34;),  # RFC1918
    netaddr.IPNetwork(&#34;172.16.0.0/12&#34;),  # RFC1918
    netaddr.IPNetwork(&#34;192.168.0.0/16&#34;),  # RFC1918
    netaddr.IPNetwork(&#34;169.254.0.0/16&#34;),  # RFC3927 link-local
    netaddr.IPNetwork(&#34;::1/128&#34;),  # IPv6 loopback
    netaddr.IPNetwork(&#34;fe80::/10&#34;),  # IPv6 link-local
    netaddr.IPNetwork(&#34;fc00::/7&#34;),  # IPv6 unique local addr
    netaddr.IPNetwork(&#34;200::/7&#34;),  # IPv6 yggdrasil range
]


def is_private(ip):
    &#34;&#34;&#34;

    Args:
      ip:

    Returns:

    &#34;&#34;&#34;
    if not isinstance(ip, netaddr.IPNetwork):
        ip = netaddr.IPNetwork(ip)
    for network in _private_networks:
        if ip in network:
            return True
    return False


def extract_access_points(network):
    &#34;&#34;&#34;

    Args:
      network:

    Returns:

    &#34;&#34;&#34;
    # gather all actual nodes, using their wg pubkey as key in the map (NodeID
    # can&#39;t be seen in the actual peer struct)
    actual_nodes = {}
    for nr in network.network_resources:
        actual_nodes[nr.wireguard_public_key] = None

    aps = []
    for nr in network.network_resources:
        for peer in nr.peers:
            if peer.public_key not in actual_nodes:
                # peer is not a node so it must be external
                ap = AccessPoint(
                    node_id=nr.info.node_id,
                    subnet=peer.iprange,
                    wg_public_key=peer.public_key,
                    # we can&#39;t infer if we use IPv6 or IPv4
                )
                aps.append(ap)
    return aps


class AccessPoint:
    def __init__(self, node_id, subnet, wg_public_key, ip4=None):
        self.node_id = node_id
        self.subnet = subnet
        self.wg_public_key = wg_public_key
        self.ip4 = ip4


def generate_wg_quick(wg_private_key, subnet, peer_wg_pub_key, allowed_ip, endpoint):
    &#34;&#34;&#34;

    Args:
      wg_private_key:
      subnet:
      peer_wg_pub_key:
      allowed_ip:
      endpoint:

    Returns:

    &#34;&#34;&#34;
    address = wg_routing_ip(subnet)
    allowed_ips = [allowed_ip, wg_routing_ip(allowed_ip)]
    aip = &#34;, &#34;.join(allowed_ips)

    result = f&#34;&#34;&#34;
[Interface]
Address = {address}
PrivateKey = {wg_private_key}
[Peer]
PublicKey = {peer_wg_pub_key}
AllowedIPs = {aip}
PersistentKeepalive = 25
&#34;&#34;&#34;
    if endpoint:
        result += f&#34;Endpoint = {endpoint}&#34;

    return result</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="jumpscale.sals.zos.network.extract_access_points"><code class="name flex">
<span>def <span class="ident">extract_access_points</span></span>(<span>network)</span>
</code></dt>
<dd>
<section class="desc"><h2 id="args">Args</h2>
<p>network:
Returns:</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def extract_access_points(network):
    &#34;&#34;&#34;

    Args:
      network:

    Returns:

    &#34;&#34;&#34;
    # gather all actual nodes, using their wg pubkey as key in the map (NodeID
    # can&#39;t be seen in the actual peer struct)
    actual_nodes = {}
    for nr in network.network_resources:
        actual_nodes[nr.wireguard_public_key] = None

    aps = []
    for nr in network.network_resources:
        for peer in nr.peers:
            if peer.public_key not in actual_nodes:
                # peer is not a node so it must be external
                ap = AccessPoint(
                    node_id=nr.info.node_id,
                    subnet=peer.iprange,
                    wg_public_key=peer.public_key,
                    # we can&#39;t infer if we use IPv6 or IPv4
                )
                aps.append(ap)
    return aps</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.zos.network.find_public_node"><code class="name flex">
<span>def <span class="ident">find_public_node</span></span>(<span>network_resources)</span>
</code></dt>
<dd>
<section class="desc"><h2 id="args">Args</h2>
<p>network_resources:
Returns:</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def find_public_node(network_resources):
    &#34;&#34;&#34;

    Args:
      network_resources:

    Returns:

    &#34;&#34;&#34;
    for nr in network_resources:
        if has_ipv4(nr):
            return nr
    return None</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.zos.network.generate_peers"><code class="name flex">
<span>def <span class="ident">generate_peers</span></span>(<span>network)</span>
</code></dt>
<dd>
<section class="desc"><p>Generate
peers in the network</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def generate_peers(network):
    &#34;&#34;&#34;Generate  peers in the network
    &#34;&#34;&#34;
    public_nr = None
    if has_hidden_nodes(network):
        public_nr = find_public_node(network.network_resources)

    # We also need to inform nodes how to route the external access subnets.
    # Working with the knowledge that these external subnets come in through
    # the network through a single access point, which is part of the network
    # and thus already routed, we can map the external subnets to the subnet
    # of the access point, and add these external subnets to all peers who also
    # have the associated internal subnet.

    # Map the network subnets to their respective node ids first for easy access later
    internal_subnets = {}
    for nr in network.network_resources:
        internal_subnets[nr.info.node_id] = nr.iprange

    external_subnet = {}
    for ap in network.access_points:
        internal_sub = internal_subnets[ap.node_id]
        if internal_sub not in external_subnet:
            external_subnet[internal_sub] = []
        external_subnet[internal_sub].append(ap.subnet)

    # Maintain a mapping of access point nodes to the subnet and wg key they give access
    # to, as these need to be added as peers as well for these nodes
    access_points = {}
    for ap in network.access_points:
        if ap.node_id not in access_points:
            access_points[ap.node_id] = []
        access_points[ap.node_id].append(ap)

    # Find all hidden nodes, and collect their subnets. Also collect the subnets
    # of public IPv6 only nodes, since hidden nodes need IPv4 to connect.
    hidden_subnets = {}
    # also maintain subnets from nodes who have only IPv6 since this will also
    # need to be routed for hidden nodes
    ipv6_only_subnets = {}
    for nr in network.network_resources:
        if len(nr.public_endpoints) == 0:
            hidden_subnets[nr.info.node_id] = nr.iprange
            continue

        if not has_ipv4(nr):
            ipv6_only_subnets[nr.info.node_id] = nr.iprange

    for nr in network.network_resources:
        nr.peers = []
        for onr in network.network_resources:
            # skip ourself
            if nr.info.node_id == onr.info.node_id:
                continue

            endpoint = &#34;&#34;
            allowed_ips = set()
            allowed_ips.add(onr.iprange)
            allowed_ips.add(wg_routing_ip(onr.iprange))

            if len(nr.public_endpoints) == 0:
                # If node is hidden, set only public peers (with IPv4), and set first public peer to
                # contain all hidden subnets, except for the one owned by the node
                if not has_ipv4(onr):
                    continue

                # Also add all other subnets if this is the pub node
                if public_nr and onr.info.node_id == public_nr.info.node_id:
                    for owner, subnet in hidden_subnets.items():
                        # Do not add our own subnet
                        if owner == nr.info.node_id:
                            continue

                        allowed_ips.add(subnet)
                        allowed_ips.add(wg_routing_ip(subnet))

                    for subnet in ipv6_only_subnets.values():
                        allowed_ips.add(subnet)
                        allowed_ips.add(wg_routing_ip(subnet))

                    for pep in onr.public_endpoints:
                        if pep.version == 4:
                            endpoint = f&#34;{str(pep.ip)}.{onr.wireguard_listen_port}&#34;
                            break

                # Endpoint must be IPv4
                for pep in onr.public_endpoints:
                    if pep.version == 4:
                        endpoint = f&#34;{str(pep.ip)}:{onr.wireguard_listen_port}&#34;
                        break

            elif len(onr.public_endpoints) == 0 and has_ipv4(nr):
                # if the peer is hidden but we have IPv4,  we can connect to it, but we don&#39;t know an endpoint.
                endpoint = &#34;&#34;
            else:
                # if we are not hidden, we add all other nodes, unless we don&#39;t
                # have IPv4, because then we also can&#39;t connect to hidden nodes.
                # Ignore hidden nodes if we don&#39;t have IPv4
                if not has_ipv4(nr) and len(onr.public_endpoints) == 0:
                    continue

                # both nodes are public therefore we can connect over IPv6

                # if this is the selected public_nr - also need to add allowedIPs for the hidden nodes
                if public_nr and onr.info.node_id == public_nr.info.node_id:
                    for subnet in hidden_subnets.values():
                        allowed_ips.add(subnet)
                        allowed_ips.add(wg_routing_ip(subnet))

                # Since the node is not hidden, we know that it MUST have at least 1 IPv6 address
                for pep in onr.public_endpoints:
                    if pep.version == 6:
                        endpoint = f&#34;[{str(pep.ip)}]:{onr.wireguard_listen_port}&#34;
                        break

                # as a fallback assign IPv4
                if endpoint == &#34;&#34;:
                    for pep in onr.public_endpoints:
                        if pep.version == 4:
                            endpoint = f&#34;{pep.ip}:{onr.wireguard_listen_port}&#34;
                            break

            # Add subnets for external access
            new_allowed_ips = set()
            for aip in allowed_ips:
                new_allowed_ips.add(aip)
                for subnet in external_subnet.get(aip, []):
                    new_allowed_ips.add(subnet)
                    new_allowed_ips.add(wg_routing_ip(subnet))
            allowed_ips = new_allowed_ips

            peer = WireguardPeer()
            peer.iprange = str(onr.iprange)
            peer.endpoint = endpoint
            peer.allowed_iprange = [str(x) for x in allowed_ips]
            peer.public_key = onr.wireguard_public_key
            nr.peers.append(peer)
        #  Add configured external access peers
        for ea in access_points.get(nr.info.node_id, []):
            allowed_ips = [str(ea.subnet), wg_routing_ip(ea.subnet)]

            peer = WireguardPeer()
            peer.iprange = ea.subnet
            peer.endpoint = &#34;&#34;
            peer.allowed_iprange = [str(x) for x in allowed_ips]
            peer.public_key = ea.wg_public_key if isinstance(ea.wg_public_key, str) else ea.wg_public_key.decode()
            nr.peers.append(peer)</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.zos.network.generate_wg_quick"><code class="name flex">
<span>def <span class="ident">generate_wg_quick</span></span>(<span>wg_private_key, subnet, peer_wg_pub_key, allowed_ip, endpoint)</span>
</code></dt>
<dd>
<section class="desc"><h2 id="args">Args</h2>
<p>wg_private_key:
subnet:
peer_wg_pub_key:
allowed_ip:
endpoint:
Returns:</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def generate_wg_quick(wg_private_key, subnet, peer_wg_pub_key, allowed_ip, endpoint):
    &#34;&#34;&#34;

    Args:
      wg_private_key:
      subnet:
      peer_wg_pub_key:
      allowed_ip:
      endpoint:

    Returns:

    &#34;&#34;&#34;
    address = wg_routing_ip(subnet)
    allowed_ips = [allowed_ip, wg_routing_ip(allowed_ip)]
    aip = &#34;, &#34;.join(allowed_ips)

    result = f&#34;&#34;&#34;
[Interface]
Address = {address}
PrivateKey = {wg_private_key}
[Peer]
PublicKey = {peer_wg_pub_key}
AllowedIPs = {aip}
PersistentKeepalive = 25
&#34;&#34;&#34;
    if endpoint:
        result += f&#34;Endpoint = {endpoint}&#34;

    return result</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.zos.network.get_endpoints"><code class="name flex">
<span>def <span class="ident">get_endpoints</span></span>(<span>node)</span>
</code></dt>
<dd>
<section class="desc"><h2 id="args">Args</h2>
<p>node:
Returns:</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def get_endpoints(node):
    &#34;&#34;&#34;

    Args:
      node:

    Returns:

    &#34;&#34;&#34;
    ips = []
    if node.public_config and node.public_config.master:
        ips.append(netaddr.IPNetwork(node.public_config.ipv4))
        ips.append(netaddr.IPNetwork(node.public_config.ipv6))
    else:
        for iface in node.ifaces:
            for ip in iface.addrs:
                ips.append(netaddr.IPNetwork(ip))

    endpoints = []
    for ip in ips:
        if ip.is_unicast() and not is_private(ip):
            endpoints.append(ip)
    return endpoints</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.zos.network.has_hidden_nodes"><code class="name flex">
<span>def <span class="ident">has_hidden_nodes</span></span>(<span>network)</span>
</code></dt>
<dd>
<section class="desc"><h2 id="args">Args</h2>
<p>network:
Returns:</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def has_hidden_nodes(network):
    &#34;&#34;&#34;

    Args:
      network:

    Returns:

    &#34;&#34;&#34;
    for nr in network.network_resources:
        if len(nr.public_endpoints) &lt;= 0:
            return True
    return False</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.zos.network.has_ipv4"><code class="name flex">
<span>def <span class="ident">has_ipv4</span></span>(<span>network_resource)</span>
</code></dt>
<dd>
<section class="desc"><h2 id="args">Args</h2>
<p>network_resource:
Returns:</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def has_ipv4(network_resource):
    &#34;&#34;&#34;

    Args:
      network_resource:

    Returns:

    &#34;&#34;&#34;
    for pep in network_resource.public_endpoints:
        if pep.version == 4:
            return True
    return False</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.zos.network.is_private"><code class="name flex">
<span>def <span class="ident">is_private</span></span>(<span>ip)</span>
</code></dt>
<dd>
<section class="desc"><h2 id="args">Args</h2>
<p>ip:
Returns:</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def is_private(ip):
    &#34;&#34;&#34;

    Args:
      ip:

    Returns:

    &#34;&#34;&#34;
    if not isinstance(ip, netaddr.IPNetwork):
        ip = netaddr.IPNetwork(ip)
    for network in _private_networks:
        if ip in network:
            return True
    return False</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.zos.network.wg_routing_ip"><code class="name flex">
<span>def <span class="ident">wg_routing_ip</span></span>(<span>ip_range)</span>
</code></dt>
<dd>
<section class="desc"><h2 id="args">Args</h2>
<p>ip_range:
Returns:</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def wg_routing_ip(ip_range):
    &#34;&#34;&#34;

    Args:
      ip_range:

    Returns:

    &#34;&#34;&#34;
    if not isinstance(ip_range, netaddr.IPNetwork):
        ip_range = netaddr.IPNetwork(ip_range)
    words = ip_range.ip.words
    return f&#34;100.64.{words[1]}.{words[2]}/32&#34;</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="jumpscale.sals.zos.network.AccessPoint"><code class="flex name class">
<span>class <span class="ident">AccessPoint</span></span>
<span>(</span><span>node_id, subnet, wg_public_key, ip4=None)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">class AccessPoint:
    def __init__(self, node_id, subnet, wg_public_key, ip4=None):
        self.node_id = node_id
        self.subnet = subnet
        self.wg_public_key = wg_public_key
        self.ip4 = ip4</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.zos.network.Network"><code class="flex name class">
<span>class <span class="ident">Network</span></span>
<span>(</span><span>name, iprange)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">class Network:
    class Info:
        def __init__(self):
            self.workload_type = WorkloadType.Network_resource

    def __init__(self, name, iprange):
        self.info = self.Info()
        self.name = name
        self.iprange = iprange
        self.network_resources = []</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="jumpscale.sals.zos.network.Network.Info"><code class="name">var <span class="ident">Info</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
</dd>
<dt id="jumpscale.sals.zos.network.NetworkGenerator"><code class="flex name class">
<span>class <span class="ident">NetworkGenerator</span></span>
<span>(</span><span>identity)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">class NetworkGenerator:
    def __init__(self, identity):
        explorer = identity.explorer
        self._identity = identity
        self._nodes = explorer.nodes
        self._farms = explorer.farms
        self._workloads = explorer.workloads

    def _load_network(self, network):
        for nr in network.network_resources:
            nr.public_endpoints = get_endpoints(self._nodes.get(nr.info.node_id))

        network.access_points = extract_access_points(network)

    def _cleanup_network(self, network):
        for nr in network.network_resources:
            if hasattr(nr, &#34;public_endpoints&#34;):
                delattr(nr, &#34;public_endpoints&#34;)

        if hasattr(network, &#34;access_points&#34;):
            delattr(network, &#34;access_points&#34;)

    def create(self, ip_range: str, network_name: str = None) -&gt; Network:
        &#34;&#34;&#34;create a new network

        Args:
          ip_range(str): IP range (cidr) of the full network. The network mask must be /16
          network_name(str, optional): name of the network. If None, a random name will be generated, defaults to None

        Returns:
          Network: Network

        Raises:
          Input: if ip_range not a private range (RFC 1918)
          Input: if network mask of ip_range is not /16

        &#34;&#34;&#34;
        network = netaddr.IPNetwork(ip_range)
        if not is_private(network):
            raise Input(&#34;ip_range must be a private network range (RFC 1918)&#34;)
        if network.prefixlen != 16:
            raise Input(&#34;network mask of ip range must be a /16&#34;)
        network = Network(network_name, ip_range)
        return network

    def add_node(self, network: Network, node_id: str, ip_range: str, pool_id: int, wg_port: int = None):
        &#34;&#34;&#34;add a node into the network

        Args:
          network(Network): network object
          node_id(str): ID of the node to add to the network
          ip_range(str): IP range (cidr) to assign to the node inside the network. The network mask must be a /24
          pool_id(int): the capacity pool ID
          wg_port(int, optional

        Raises:
          Input: if mask of ip_range is not /24
          Input: If specified access node not part of the network
          Input: If access node point doesn&#39;t have a public endpoint
          Input: If access node point doesn&#39;t have pubic endpoint of requested type): wireguar port of the wireguard endpoint. If None it will be picked automatically, defaults to None

        Returns:

        &#34;&#34;&#34;
        node = self._nodes.get(node_id)

        if netaddr.IPNetwork(ip_range).prefixlen != 24:
            raise Input(&#34;ip_range should have a netmask of /24, not /%d&#34;, ip_range.prefixlen)

        if wg_port is None:
            wg_port = _find_free_wg_port(node)

        _, wg_private_encrypted, wg_public = generate_zos_keys(node.public_key_hex)

        nr = NetworkResource()
        nr.info.pool_id = pool_id
        nr.info.workload_type = WorkloadType.Network_resource
        nr.network_iprange = network.iprange
        nr.iprange = ip_range
        nr.info.node_id = node_id
        nr.wireguard_listen_port = wg_port
        nr.wireguard_public_key = wg_public
        nr.wireguard_private_key_encrypted = wg_private_encrypted
        nr.name = network.name
        network.network_resources.append(nr)
        try:
            self._load_network(network)
            generate_peers(network)
        finally:
            self._cleanup_network(network)

    def add_access(
        self, network: Network, node_id: str, ip_range: str, wg_public_key: str = None, ipv4: bool = False
    ) -&gt; str:
        &#34;&#34;&#34;add an external access to the network. use this function if you want to allow
        a peer to your network that is not a 0-OS node like User laptop, external server,...

        Args:
          network(Network): network object
          node_id(str): ID of the node to use as entrypoint to the network
          ip_range(str): IP range to allocate for this peer
          wg_public_key(str, optional): wireguard public key of the peer. If not specify a new key will be generated, defaults to None
          ipv4(bool, optional): If True, use an IPv4 address as endpoint to connect to the network otherwise use IPv6, defaults to False

        Returns:
          str: the wireguard configuration to be used by the peer to connect to the network

        &#34;&#34;&#34;
        if netaddr.IPNetwork(ip_range).prefixlen != 24:
            raise Input(&#34;ip_range should have a netmask of /24, not /%d&#34;, ip_range.prefixlen)

        try:
            self._load_network(network)

            access_point_nr = None
            for nr in network.network_resources:
                if node_id == nr.info.node_id:
                    access_point_nr = nr

            if access_point_nr is None:
                raise Input(&#34;can not add access through a node which is not in the network&#34;)

            if len(access_point_nr.public_endpoints) == 0:
                raise Input(&#34;access node must have at least 1 public endpoint&#34;)

            endpoint = &#34;&#34;
            wg_port = access_point_nr.wireguard_listen_port
            for ep in access_point_nr.public_endpoints:
                if ipv4 and ep.version == 4:
                    endpoint = f&#34;{str(ep.ip)}:{wg_port}&#34;
                    break
                if not ipv4 and ep.version == 6:
                    ip = str(ep.ip)
                    endpoint = f&#34;[{ip}]:{wg_port}&#34;
                    break

            if not endpoint:
                raise Input(&#34;access node has no public endpoint of the requested type&#34;)

            wg_private_key = &#34;&#34;
            if not wg_public_key:
                wg_private = public.PrivateKey.generate()
                wg_public = wg_private.public_key
                wg_private_key = wg_private.encode(Base64Encoder).decode()
                wg_public_key = wg_public.encode(Base64Encoder).decode()

            network.access_points.append(
                AccessPoint(node_id=node_id, subnet=ip_range, wg_public_key=wg_public_key, ip4=ipv4)
            )

            generate_peers(network)

        finally:
            self._cleanup_network(network)

        return generate_wg_quick(
            wg_private_key, ip_range, access_point_nr.wireguard_public_key, network.iprange, endpoint
        )

    def delete_access(self, network: Network, node_id: str, iprange: str) -&gt; Network:
        &#34;&#34;&#34;remove a peer that was added using add_access method
        use this is you want to revoke the access to the network from someone

        Args:
          network(Network): network object
          node_id(str): ID of the node to use as entrypoint to the network
          ip_range(str): IP range to allocate for this peer

        Returns:
          Network: Network

        &#34;&#34;&#34;
        node_workloads = {}
        node_ranges = set()
        for net_workload in network.network_resources:
            node_workloads[net_workload.info.node_id] = net_workload
            node_ranges.add(net_workload.iprange)
        if iprange in node_ranges:
            raise Input(&#34;Can&#39;t delete zos node peer&#34;)

        access_workload = node_workloads.get(node_id)
        if not access_workload:
            raise Input(f&#34;Node {node_id} is not part of network&#34;)
        # remove peer from access node
        new_peers = []
        for peer in access_workload.peers:
            if peer.iprange != iprange:
                new_peers.append(peer)
        access_workload.peers = new_peers
        # remove peer from allowed ips on all nodes
        access_node_range = node_workloads[node_id]
        routing_range = wg_routing_ip(iprange)
        for network_resource in node_workloads.values():
            for peer in network_resource.peers:
                if peer.iprange != access_node_range:
                    if iprange in peer.allowed_iprange:
                        peer.allowed_iprange.remove(iprange)
                    if routing_range in peer.allowed_iprange:
                        peer.allowed_iprange.remove(routing_range)
        return network

    def load_network(self, network_name: str) -&gt; Network:
        &#34;&#34;&#34;load network fetch all network resource belonging to the same network
        and re-create the full network object

        if make sure to only take the latest version of each network resource

        use this function if you need to modify and existing network

        Args:
          network_name(str): the name of the network to load
          network_name: str:

        Returns:
          Network: Network object

        &#34;&#34;&#34;
        tid = self._identity.tid
        nrs = {}
        # first gather all the latest version of each network resource for this network
        for w in self._workloads.iter(customer_tid=tid, next_action=NextAction.DEPLOY.name):
            if w.info.workload_type == WorkloadType.Network_resource and w.name == network_name:
                nrs[w.info.node_id] = w

        network = None
        for nr in nrs.values():
            # ensure all network resource have the same network iprange
            # if this is not the case, then we have an issue
            if network is None:
                network = Network(network_name, nr.network_iprange)
            else:
                if w.network_iprange != network.iprange:
                    raise j.exceptions.Value(
                        f&#34;found a network resource with IP range ({nr.network_iprange}) different from the network IP range ({network.iprange})&#34;
                    )

            nr.info.reference = &#34;&#34;  # just to handle possible migrated network
            network.network_resources.append(nr)

        return network</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="jumpscale.sals.zos.network.NetworkGenerator.add_access"><code class="name flex">
<span>def <span class="ident">add_access</span></span>(<span>self, network, node_id, ip_range, wg_public_key=None, ipv4=False)</span>
</code></dt>
<dd>
<section class="desc"><p>add an external access to the network. use this function if you want to allow
a peer to your network that is not a 0-OS node like User laptop, external server,&hellip;</p>
<h2 id="args">Args</h2>
<p>network(Network): network object
node_id(str): ID of the node to use as entrypoint to the network
ip_range(str): IP range to allocate for this peer
wg_public_key(str, optional): wireguard public key of the peer. If not specify a new key will be generated, defaults to None
ipv4(bool, optional): If True, use an IPv4 address as endpoint to connect to the network otherwise use IPv6, defaults to False</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>str</code></strong></dt>
<dd>the wireguard configuration to be used by the peer to connect to the network</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def add_access(
    self, network: Network, node_id: str, ip_range: str, wg_public_key: str = None, ipv4: bool = False
) -&gt; str:
    &#34;&#34;&#34;add an external access to the network. use this function if you want to allow
    a peer to your network that is not a 0-OS node like User laptop, external server,...

    Args:
      network(Network): network object
      node_id(str): ID of the node to use as entrypoint to the network
      ip_range(str): IP range to allocate for this peer
      wg_public_key(str, optional): wireguard public key of the peer. If not specify a new key will be generated, defaults to None
      ipv4(bool, optional): If True, use an IPv4 address as endpoint to connect to the network otherwise use IPv6, defaults to False

    Returns:
      str: the wireguard configuration to be used by the peer to connect to the network

    &#34;&#34;&#34;
    if netaddr.IPNetwork(ip_range).prefixlen != 24:
        raise Input(&#34;ip_range should have a netmask of /24, not /%d&#34;, ip_range.prefixlen)

    try:
        self._load_network(network)

        access_point_nr = None
        for nr in network.network_resources:
            if node_id == nr.info.node_id:
                access_point_nr = nr

        if access_point_nr is None:
            raise Input(&#34;can not add access through a node which is not in the network&#34;)

        if len(access_point_nr.public_endpoints) == 0:
            raise Input(&#34;access node must have at least 1 public endpoint&#34;)

        endpoint = &#34;&#34;
        wg_port = access_point_nr.wireguard_listen_port
        for ep in access_point_nr.public_endpoints:
            if ipv4 and ep.version == 4:
                endpoint = f&#34;{str(ep.ip)}:{wg_port}&#34;
                break
            if not ipv4 and ep.version == 6:
                ip = str(ep.ip)
                endpoint = f&#34;[{ip}]:{wg_port}&#34;
                break

        if not endpoint:
            raise Input(&#34;access node has no public endpoint of the requested type&#34;)

        wg_private_key = &#34;&#34;
        if not wg_public_key:
            wg_private = public.PrivateKey.generate()
            wg_public = wg_private.public_key
            wg_private_key = wg_private.encode(Base64Encoder).decode()
            wg_public_key = wg_public.encode(Base64Encoder).decode()

        network.access_points.append(
            AccessPoint(node_id=node_id, subnet=ip_range, wg_public_key=wg_public_key, ip4=ipv4)
        )

        generate_peers(network)

    finally:
        self._cleanup_network(network)

    return generate_wg_quick(
        wg_private_key, ip_range, access_point_nr.wireguard_public_key, network.iprange, endpoint
    )</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.zos.network.NetworkGenerator.add_node"><code class="name flex">
<span>def <span class="ident">add_node</span></span>(<span>self, network, node_id, ip_range, pool_id, wg_port=None)</span>
</code></dt>
<dd>
<section class="desc"><p>add a node into the network</p>
<h2 id="args">Args</h2>
<p>network(Network): network object
node_id(str): ID of the node to add to the network
ip_range(str): IP range (cidr) to assign to the node inside the network. The network mask must be a /24
pool_id(int): the capacity pool ID
wg_port(int, optional</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><strong><code>Input</code></strong></dt>
<dd>if mask of ip_range is not /24</dd>
<dt><strong><code>Input</code></strong></dt>
<dd>If specified access node not part of the network</dd>
<dt><strong><code>Input</code></strong></dt>
<dd>If access node point doesn't have a public endpoint</dd>
<dt><strong><code>Input</code></strong></dt>
<dd>If access node point doesn't have pubic endpoint of requested type): wireguar port of the wireguard endpoint. If None it will be picked automatically, defaults to None</dd>
<dt><code>Returns</code>:</dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def add_node(self, network: Network, node_id: str, ip_range: str, pool_id: int, wg_port: int = None):
    &#34;&#34;&#34;add a node into the network

    Args:
      network(Network): network object
      node_id(str): ID of the node to add to the network
      ip_range(str): IP range (cidr) to assign to the node inside the network. The network mask must be a /24
      pool_id(int): the capacity pool ID
      wg_port(int, optional

    Raises:
      Input: if mask of ip_range is not /24
      Input: If specified access node not part of the network
      Input: If access node point doesn&#39;t have a public endpoint
      Input: If access node point doesn&#39;t have pubic endpoint of requested type): wireguar port of the wireguard endpoint. If None it will be picked automatically, defaults to None

    Returns:

    &#34;&#34;&#34;
    node = self._nodes.get(node_id)

    if netaddr.IPNetwork(ip_range).prefixlen != 24:
        raise Input(&#34;ip_range should have a netmask of /24, not /%d&#34;, ip_range.prefixlen)

    if wg_port is None:
        wg_port = _find_free_wg_port(node)

    _, wg_private_encrypted, wg_public = generate_zos_keys(node.public_key_hex)

    nr = NetworkResource()
    nr.info.pool_id = pool_id
    nr.info.workload_type = WorkloadType.Network_resource
    nr.network_iprange = network.iprange
    nr.iprange = ip_range
    nr.info.node_id = node_id
    nr.wireguard_listen_port = wg_port
    nr.wireguard_public_key = wg_public
    nr.wireguard_private_key_encrypted = wg_private_encrypted
    nr.name = network.name
    network.network_resources.append(nr)
    try:
        self._load_network(network)
        generate_peers(network)
    finally:
        self._cleanup_network(network)</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.zos.network.NetworkGenerator.create"><code class="name flex">
<span>def <span class="ident">create</span></span>(<span>self, ip_range, network_name=None)</span>
</code></dt>
<dd>
<section class="desc"><p>create a new network</p>
<h2 id="args">Args</h2>
<p>ip_range(str): IP range (cidr) of the full network. The network mask must be /16
network_name(str, optional): name of the network. If None, a random name will be generated, defaults to None</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><a title="jumpscale.sals.zos.network.Network" href="#jumpscale.sals.zos.network.Network"><code>Network</code></a></strong></dt>
<dd>Network</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><strong><code>Input</code></strong></dt>
<dd>if ip_range not a private range (RFC 1918)</dd>
<dt><strong><code>Input</code></strong></dt>
<dd>if network mask of ip_range is not /16</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def create(self, ip_range: str, network_name: str = None) -&gt; Network:
    &#34;&#34;&#34;create a new network

    Args:
      ip_range(str): IP range (cidr) of the full network. The network mask must be /16
      network_name(str, optional): name of the network. If None, a random name will be generated, defaults to None

    Returns:
      Network: Network

    Raises:
      Input: if ip_range not a private range (RFC 1918)
      Input: if network mask of ip_range is not /16

    &#34;&#34;&#34;
    network = netaddr.IPNetwork(ip_range)
    if not is_private(network):
        raise Input(&#34;ip_range must be a private network range (RFC 1918)&#34;)
    if network.prefixlen != 16:
        raise Input(&#34;network mask of ip range must be a /16&#34;)
    network = Network(network_name, ip_range)
    return network</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.zos.network.NetworkGenerator.delete_access"><code class="name flex">
<span>def <span class="ident">delete_access</span></span>(<span>self, network, node_id, iprange)</span>
</code></dt>
<dd>
<section class="desc"><p>remove a peer that was added using add_access method
use this is you want to revoke the access to the network from someone</p>
<h2 id="args">Args</h2>
<p>network(Network): network object
node_id(str): ID of the node to use as entrypoint to the network
ip_range(str): IP range to allocate for this peer</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><a title="jumpscale.sals.zos.network.Network" href="#jumpscale.sals.zos.network.Network"><code>Network</code></a></strong></dt>
<dd>Network</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def delete_access(self, network: Network, node_id: str, iprange: str) -&gt; Network:
    &#34;&#34;&#34;remove a peer that was added using add_access method
    use this is you want to revoke the access to the network from someone

    Args:
      network(Network): network object
      node_id(str): ID of the node to use as entrypoint to the network
      ip_range(str): IP range to allocate for this peer

    Returns:
      Network: Network

    &#34;&#34;&#34;
    node_workloads = {}
    node_ranges = set()
    for net_workload in network.network_resources:
        node_workloads[net_workload.info.node_id] = net_workload
        node_ranges.add(net_workload.iprange)
    if iprange in node_ranges:
        raise Input(&#34;Can&#39;t delete zos node peer&#34;)

    access_workload = node_workloads.get(node_id)
    if not access_workload:
        raise Input(f&#34;Node {node_id} is not part of network&#34;)
    # remove peer from access node
    new_peers = []
    for peer in access_workload.peers:
        if peer.iprange != iprange:
            new_peers.append(peer)
    access_workload.peers = new_peers
    # remove peer from allowed ips on all nodes
    access_node_range = node_workloads[node_id]
    routing_range = wg_routing_ip(iprange)
    for network_resource in node_workloads.values():
        for peer in network_resource.peers:
            if peer.iprange != access_node_range:
                if iprange in peer.allowed_iprange:
                    peer.allowed_iprange.remove(iprange)
                if routing_range in peer.allowed_iprange:
                    peer.allowed_iprange.remove(routing_range)
    return network</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.zos.network.NetworkGenerator.load_network"><code class="name flex">
<span>def <span class="ident">load_network</span></span>(<span>self, network_name)</span>
</code></dt>
<dd>
<section class="desc"><p>load network fetch all network resource belonging to the same network
and re-create the full network object</p>
<p>if make sure to only take the latest version of each network resource</p>
<p>use this function if you need to modify and existing network</p>
<h2 id="args">Args</h2>
<dl>
<dt>network_name(str): the name of the network to load</dt>
<dt><strong><code>network_name</code></strong></dt>
<dd>str:</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><a title="jumpscale.sals.zos.network.Network" href="#jumpscale.sals.zos.network.Network"><code>Network</code></a></strong></dt>
<dd>Network object</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def load_network(self, network_name: str) -&gt; Network:
    &#34;&#34;&#34;load network fetch all network resource belonging to the same network
    and re-create the full network object

    if make sure to only take the latest version of each network resource

    use this function if you need to modify and existing network

    Args:
      network_name(str): the name of the network to load
      network_name: str:

    Returns:
      Network: Network object

    &#34;&#34;&#34;
    tid = self._identity.tid
    nrs = {}
    # first gather all the latest version of each network resource for this network
    for w in self._workloads.iter(customer_tid=tid, next_action=NextAction.DEPLOY.name):
        if w.info.workload_type == WorkloadType.Network_resource and w.name == network_name:
            nrs[w.info.node_id] = w

    network = None
    for nr in nrs.values():
        # ensure all network resource have the same network iprange
        # if this is not the case, then we have an issue
        if network is None:
            network = Network(network_name, nr.network_iprange)
        else:
            if w.network_iprange != network.iprange:
                raise j.exceptions.Value(
                    f&#34;found a network resource with IP range ({nr.network_iprange}) different from the network IP range ({network.iprange})&#34;
                )

        nr.info.reference = &#34;&#34;  # just to handle possible migrated network
        network.network_resources.append(nr)

    return network</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="jumpscale.sals.zos" href="index.html">jumpscale.sals.zos</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="jumpscale.sals.zos.network.extract_access_points" href="#jumpscale.sals.zos.network.extract_access_points">extract_access_points</a></code></li>
<li><code><a title="jumpscale.sals.zos.network.find_public_node" href="#jumpscale.sals.zos.network.find_public_node">find_public_node</a></code></li>
<li><code><a title="jumpscale.sals.zos.network.generate_peers" href="#jumpscale.sals.zos.network.generate_peers">generate_peers</a></code></li>
<li><code><a title="jumpscale.sals.zos.network.generate_wg_quick" href="#jumpscale.sals.zos.network.generate_wg_quick">generate_wg_quick</a></code></li>
<li><code><a title="jumpscale.sals.zos.network.get_endpoints" href="#jumpscale.sals.zos.network.get_endpoints">get_endpoints</a></code></li>
<li><code><a title="jumpscale.sals.zos.network.has_hidden_nodes" href="#jumpscale.sals.zos.network.has_hidden_nodes">has_hidden_nodes</a></code></li>
<li><code><a title="jumpscale.sals.zos.network.has_ipv4" href="#jumpscale.sals.zos.network.has_ipv4">has_ipv4</a></code></li>
<li><code><a title="jumpscale.sals.zos.network.is_private" href="#jumpscale.sals.zos.network.is_private">is_private</a></code></li>
<li><code><a title="jumpscale.sals.zos.network.wg_routing_ip" href="#jumpscale.sals.zos.network.wg_routing_ip">wg_routing_ip</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="jumpscale.sals.zos.network.AccessPoint" href="#jumpscale.sals.zos.network.AccessPoint">AccessPoint</a></code></h4>
</li>
<li>
<h4><code><a title="jumpscale.sals.zos.network.Network" href="#jumpscale.sals.zos.network.Network">Network</a></code></h4>
<ul class="">
<li><code><a title="jumpscale.sals.zos.network.Network.Info" href="#jumpscale.sals.zos.network.Network.Info">Info</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="jumpscale.sals.zos.network.NetworkGenerator" href="#jumpscale.sals.zos.network.NetworkGenerator">NetworkGenerator</a></code></h4>
<ul class="">
<li><code><a title="jumpscale.sals.zos.network.NetworkGenerator.add_access" href="#jumpscale.sals.zos.network.NetworkGenerator.add_access">add_access</a></code></li>
<li><code><a title="jumpscale.sals.zos.network.NetworkGenerator.add_node" href="#jumpscale.sals.zos.network.NetworkGenerator.add_node">add_node</a></code></li>
<li><code><a title="jumpscale.sals.zos.network.NetworkGenerator.create" href="#jumpscale.sals.zos.network.NetworkGenerator.create">create</a></code></li>
<li><code><a title="jumpscale.sals.zos.network.NetworkGenerator.delete_access" href="#jumpscale.sals.zos.network.NetworkGenerator.delete_access">delete_access</a></code></li>
<li><code><a title="jumpscale.sals.zos.network.NetworkGenerator.load_network" href="#jumpscale.sals.zos.network.NetworkGenerator.load_network">load_network</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.6.4</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>
