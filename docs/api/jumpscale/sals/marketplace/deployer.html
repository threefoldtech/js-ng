<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.6.4" />
<title>jumpscale.sals.marketplace.deployer API documentation</title>
<meta name="description" content="" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase;cursor:pointer}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>jumpscale.sals.marketplace.deployer</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>Source code</summary>
<pre><code class="python">import math
import random

from jumpscale.clients.explorer.models import NextAction, WorkloadType
from jumpscale.core.base import StoredFactory
from jumpscale.loader import j
from jumpscale.sals.chatflows.chatflows import StopChatFlow
from jumpscale.sals.reservation_chatflow import DeploymentFailed
from jumpscale.sals.reservation_chatflow.deployer import ChatflowDeployer, NetworkView

from requests.exceptions import HTTPError

from .models import UserPool

pool_factory = StoredFactory(UserPool)
pool_factory.always_reload = True


class MarketPlaceDeployer(ChatflowDeployer):

    WALLET_NAME = &#34;demos_wallet&#34;

    def list_user_pool_ids(self, username):
        user_pools = self.list_user_pools(username)
        user_pool_ids = [p.pool_id for p in user_pools]
        return user_pool_ids

    def list_user_pools(self, username):
        _, _, user_pools = pool_factory.find_many(owner=username)
        all_pools = [p for p in j.sals.zos.get().pools.list() if p.node_ids]
        user_pool_ids = [p.pool_id for p in user_pools]
        result = [p for p in all_pools if p.pool_id in user_pool_ids]
        return result

    def list_networks(self, username, next_action=NextAction.DEPLOY, sync=True):
        if sync:
            self.load_user_workloads(next_action=next_action)
        networks = {}  # name: last child network resource
        for pool_id in self.workloads[next_action][WorkloadType.Network_resource]:
            for workload in self.workloads[next_action][WorkloadType.Network_resource][pool_id]:
                metadata = j.data.serializers.json.loads(workload.info.metadata)
                if metadata.get(&#34;owner&#34;) == username:
                    networks[workload.name] = workload
        all_workloads = []
        workload_values = self.workloads[next_action].values()
        for pools_workloads in workload_values:
            for pool_id, workload_list in pools_workloads.items():
                for workload in workload_list:
                    metadata = j.data.serializers.json.loads(workload.info.metadata)
                    if metadata.get(&#34;owner&#34;) == username:
                        all_workloads.append(workload)
        network_views = {}
        if all_workloads:
            for network_name in networks:
                network_views[network_name] = NetworkView(network_name, all_workloads)
        return network_views

    def create_pool(self, username, bot):
        pool_info = super().create_pool(bot)
        user_pool = pool_factory.new(f&#34;pool_{username.replace(&#39;.3bot&#39;, &#39;&#39;)}_{pool_info.reservation_id}&#34;)
        user_pool.owner = username
        user_pool.pool_id = pool_info.reservation_id
        user_pool.save()
        return pool_info

    def show_payment(self, pool, bot):
        resv_id = pool.reservation_id
        resv_id_msg_text = f&#34;&#34;&#34;&lt;h3&gt;Make a Payment&lt;/h3&gt;
        Scan the QR code with your wallet (do not change the message) or enter the information below manually and proceed with the payment. Make sure to put p-{resv_id} as memo_text value.
        &#34;&#34;&#34;
        self.msg_payment_info, qr_code = self.get_qr_code_payment_info(pool)
        msg_text = resv_id_msg_text + self.msg_payment_info
        bot.qrcode_show(data=qr_code, msg=msg_text, scale=4, update=True, html=True, pool=pool)
        return qr_code

    def pay_for_pool(self, pool):
        info = self.get_payment_info(pool)
        WALLET_NAME = j.sals.marketplace.deployer.WALLET_NAME
        wallet = j.clients.stellar.get(name=WALLET_NAME)
        wallet.transfer(
            destination_address=info[&#34;escrow_address&#34;],
            amount=info[&#34;total_amount_dec&#34;],
            asset=info[&#34;escrow_asset&#34;],
            memo_text=f&#34;p-{info[&#39;resv_id&#39;]}&#34;,
        )

    def list_pools(self, username=None, cu=None, su=None):
        all_pools = self.list_user_pools(username)
        available_pools = {}
        for pool in all_pools:
            res = self.check_pool_capacity(pool, cu, su)
            available = res[0]
            if available:
                resources = res[1:]
                available_pools[pool.pool_id] = resources
        return available_pools

    def select_pool(
        self,
        username,
        bot,
        cu=None,
        su=None,
        sru=None,
        mru=None,
        hru=None,
        cru=None,
        available_pools=None,
        workload_name=None,
    ):
        user_pools = available_pools or self.list_pools(username, su=su, cu=cu)
        return super().select_pool(
            bot,
            cu=cu,
            su=su,
            sru=sru,
            mru=mru,
            hru=hru,
            cru=cru,
            available_pools=user_pools,
            workload_name=workload_name,
        )

    def select_network(self, username, bot):
        network_views = self.list_networks(username)
        network_names = [n[len(username) + 1 :] for n in network_views.keys()]
        if not network_views:
            raise StopChatFlow(f&#34;You don&#39;t have any deployed network.&#34;)
        network_name = bot.single_choice(&#34;Please select a network&#34;, network_names, required=True)
        return network_views[f&#34;{username}_{network_name}&#34;]

    def _check_pool_factory_owner(self, instance_name):
        pool_instance = pool_factory.get(instance_name)
        pool_id = pool_instance.pool_id
        pool_tid = j.sals.zos.get().pools.get(pool_id).customer_tid
        pool_explorer_url = pool_instance.explorer_url
        me = j.core.identity.me
        try:
            return pool_tid == me.tid and pool_explorer_url == me.explorer_url
        except HTTPError:
            return False

    def _get_gateways_pools(self, farm_name):
        &#34;&#34;&#34;
        Returns:
            List : will return pool ids for pools on farms with gateways
        &#34;&#34;&#34;
        gateways_pools_ids = []
        farms_ids_with_gateways = [
            gateway_farm.farm_id for gateway_farm in deployer._explorer.gateway.list() if gateway_farm.farm_id &gt; 0
        ]
        farms_names_with_gateways = set(
            map(lambda farm_id: deployer._explorer.farms.get(farm_id=farm_id).name, farms_ids_with_gateways)
        )

        for farm_name in farms_names_with_gateways:
            gw_pool_name = f&#34;marketplace_gateway_{farm_name}&#34;
            if gw_pool_name not in pool_factory.list_all() or not self._check_pool_factory_owner(gw_pool_name):
                gateways_pool_info = deployer.create_gateway_emptypool(gw_pool_name, farm_name)
                gateways_pools_ids.append(gateways_pool_info.reservation_id)
            else:
                pool_id = pool_factory.get(gw_pool_name).pool_id
                gateways_pools_ids.append(pool_id)
        return gateways_pools_ids

    def list_all_gateways(self, username, farm_name=None):
        pool_ids = self.list_user_pool_ids(username)
        gateways_pools = self._get_gateways_pools(farm_name)  # Empty pools contains the gateways only
        pool_ids.extend(gateways_pools)
        return super().list_all_gateways(pool_ids=pool_ids)

    def select_gateway(self, username, bot):
        &#34;&#34;&#34;
        Args:
            pool_ids: if specified it will only list gateways inside these pools

        Returns:
            gateway, pool_objects
        &#34;&#34;&#34;
        gateways = self.list_all_gateways(username)
        selected = bot.single_choice(&#34;Please select a gateway&#34;, list(gateways.keys()), required=True)
        return gateways[selected][&#34;gateway&#34;], gateways[selected][&#34;pool&#34;]

    def ask_multi_pool_placement(
        self, username, bot, number_of_nodes, resource_query_list=None, pool_ids=None, workload_names=None
    ):
        &#34;&#34;&#34;
        Ask and schedule workloads accross multiple pools

        Args:
            bot: chatflow object
            number_of_nodes: number of required nodes for deployment
            resource_query_list: list of query dicts {&#34;cru&#34;: 1, &#34;sru&#34;: 2, &#34;mru&#34;: 1, &#34;hru&#34;: 1}. if specified it must be same length as number_of_nodes
            pool_ids: if specfied it will limit the pools shown in the chatflow to only these pools
            workload_names: if specified they will shown when asking the user for node selection for each workload. if specified it must be same length as number_of_nodes

        Returns:
            ([], []): first list contains the selected node objects. second list contains selected pool ids
        &#34;&#34;&#34;
        resource_query_list = resource_query_list or [dict()] * number_of_nodes
        workload_names = workload_names or [None] * number_of_nodes
        if len(resource_query_list) != number_of_nodes:
            raise StopChatFlow(&#34;resource query_list must be same length as number of nodes&#34;)
        if len(workload_names) != number_of_nodes:
            raise StopChatFlow(&#34;workload_names must be same length as number of nodes&#34;)

        pools = self.list_pools(username)
        if pool_ids:
            filtered_pools = {}
            for pool_id in pools:
                if pool_id in pool_ids:
                    filtered_pools[pool_id] = pools[pool_id]
            pools = filtered_pools
        selected_nodes = []
        selected_pool_ids = []
        for i in range(number_of_nodes):
            cu, su = self.calculate_capacity_units(**resource_query_list[i])
            pool_choices = {}
            for p in pools:
                if pools[p][0] &lt; cu or pools[p][1] &lt; su:
                    continue
                nodes = j.sals.zos.get().nodes_finder.nodes_by_capacity(pool_id=p, **resource_query_list[i])
                if not nodes:
                    continue
                pool_choices[p] = pools[p]
            pool_id = self.select_pool(
                username, bot, available_pools=pool_choices, workload_name=workload_names[i], cu=cu, su=su
            )
            node = self.ask_container_placement(bot, pool_id, workload_name=workload_names[i], **resource_query_list[i])
            if not node:
                node = self.schedule_container(pool_id, **resource_query_list[i])
            selected_nodes.append(node)
            selected_pool_ids.append(pool_id)
        return selected_nodes, selected_pool_ids

    def ask_multi_pool_distribution(
        self, username, bot, number_of_nodes, resource_query=None, pool_ids=None, workload_name=None
    ):
        &#34;&#34;&#34;
        Choose multiple pools to distribute workload automatically

        Args:
            bot: chatflow object
            resource_query: query dict {&#34;cru&#34;: 1, &#34;sru&#34;: 2, &#34;mru&#34;: 1, &#34;hru&#34;: 1}.
            pool_ids: if specfied it will limit the pools shown in the chatflow to only these pools
            workload_name: name shown in the message
        Returns:
            ([], []): first list contains the selected node objects. second list contains selected pool ids
        &#34;&#34;&#34;
        resource_query = resource_query or {}
        cu, su = self.calculate_capacity_units(**resource_query)
        pools = self.list_pools(username, cu, su)
        if pool_ids:
            filtered_pools = {}
            for pool_id in pools:
                if pool_id in pool_ids:
                    filtered_pools[pool_id] = pools[pool_id]
            pools = filtered_pools

        workload_name = workload_name or &#34;workloads&#34;
        messages = {f&#34;Pool: {p} CU: {pools[p][0]} SU: {pools[p][1]}&#34;: p for p in pools}
        while True:
            pool_choices = bot.multi_list_choice(
                f&#34;Please select the pools you wish to distribute your {workload_name} on&#34;,
                options=list(messages.keys()),
                required=True,
            )
            if not pool_choices:
                bot.md_show(&#34;You must select at least one pool. please click next to try again.&#34;)
            else:
                break

        pool_ids = {}
        node_to_pool = {}
        for p in pool_choices:
            pool = pool_ids.get(messages[p], j.sals.zos.get().pools.get(messages[p]))
            pool_ids[messages[p]] = pool.pool_id
            for node_id in pool.node_ids:
                node_to_pool[node_id] = pool

        nodes = j.sals.reservation_chatflow.reservation_chatflow.get_nodes(
            number_of_nodes, pool_ids=list(pool_ids.values()), **resource_query
        )
        selected_nodes = []
        selected_pool_ids = []
        for node in nodes:
            selected_nodes.append(node)
            pool = node_to_pool[node.node_id]
            selected_pool_ids.append(pool.pool_id)
        return selected_nodes, selected_pool_ids

    def extend_solution_pool(self, bot, pool_id, expiration, currency, **resources):
        cu, su = self.calculate_capacity_units(**resources)
        cu = math.ceil(cu * expiration)
        su = math.ceil(su * expiration)

        # guard in case of negative results
        cu = max(cu, 0)
        su = max(su, 0)

        if not isinstance(currency, list):
            currency = [currency]
        if cu &gt; 0 or su &gt; 0:
            pool_info = j.sals.zos.get().pools.extend(pool_id, cu, su, currency)
            qr_code = self.show_payment(pool_info, bot)
            return pool_info, qr_code
        else:
            return None, None

    def create_solution_pool(self, bot, username, farm_name, expiration, currency, **resources):
        cu, su = self.calculate_capacity_units(**resources)
        pool_info = j.sals.zos.get().pools.create(int(cu * expiration), int(su * expiration), farm_name, [currency])
        user_pool = pool_factory.new(f&#34;pool_{username.replace(&#39;.3bot&#39;, &#39;&#39;)}_{pool_info.reservation_id}&#34;)
        user_pool.owner = username
        user_pool.pool_id = pool_info.reservation_id
        user_pool.save()
        return pool_info

    def create_gateway_emptypool(self, gwpool_name, farm_name):
        pool_info = j.sals.zos.get().pools.create(0, 0, farm_name, [&#34;TFT&#34;])
        user_pool = pool_factory.get(gwpool_name)
        user_pool.owner = gwpool_name
        user_pool.pool_id = pool_info.reservation_id
        user_pool.explorer_url = j.core.identity.me.explorer_url
        user_pool.save()
        return pool_info

    def get_free_pools(
        self, username, workload_types=None, free_to_use=False, cru=0, mru=0, sru=0, hru=0, ip_version=&#34;IPv6&#34;
    ):
        def is_pool_free(pool, nodes_dict):
            for node_id in pool.node_ids:
                node = nodes_dict.get(node_id)
                if node and not node.free_to_use:
                    return False
            return True

        user_pools = self.list_user_pools(username)
        j.sals.reservation_chatflow.deployer.load_user_workloads()
        free_pools = []
        workload_types = workload_types or [WorkloadType.Container]
        nodes = {}
        if free_to_use:
            nodes = {node.node_id: node for node in j.sals.zos.get()._explorer.nodes.list()}
        for pool in user_pools:
            valid = True
            try:
                j.sals.reservation_chatflow.reservation_chatflow.get_nodes(
                    1, cru=cru, mru=mru, sru=sru, hru=hru, ip_version=ip_version, pool_ids=[pool.pool_id],
                )
            except StopChatFlow as e:
                j.logger.warning(
                    f&#34;Failed to find resources for this reservation in this pool: {pool}, {e}. We will use another one.&#34;
                )
                continue

            if free_to_use and not is_pool_free(pool, nodes):
                continue
            for wokrkload_type in workload_types:
                if j.sals.reservation_chatflow.deployer.workloads[NextAction.DEPLOY][wokrkload_type][pool.pool_id]:
                    valid = False
                    break
            if not valid:
                continue
            if (pool.cus == 0 and pool.sus == 0) or pool.empty_at &lt; j.data.time.now().timestamp:
                continue

            free_pools.append(pool)
        return free_pools

    def get_best_fit_pool(self, pools, expiration, cru=0, mru=0, sru=0, hru=0):

        cu, su = self.calculate_capacity_units(cru, mru, sru, hru)
        required_cu = cu * expiration
        required_su = su * expiration
        exact_fit_pools = []  # contains pools that are exact match of the required resources
        over_fit_pools = []  # contains pools that have higher cus AND sus than the required resources
        under_fit_pools = []  # contains pools that have lower cus OR sus than the required resources
        for pool in pools:
            if pool.cus == required_cu and pool.sus == required_su:
                exact_fit_pools.append(pool)
            else:
                if pool.cus &lt; required_cu or pool.sus &lt; required_su:
                    under_fit_pools.append(pool)
                else:
                    over_fit_pools.append(pool)
        if exact_fit_pools:
            return random.choice(exact_fit_pools), 0, 0

        if over_fit_pools:
            # sort overfit_pools ascending according to the sum of extra cus and sus
            for pool in over_fit_pools:
                pool.unit_diff = pool.cus + pool.sus - required_cu - required_su
            sorted_result = sorted(over_fit_pools, key=lambda x: x.unit_diff)
            result_pool = sorted_result[0]
            return result_pool, result_pool.cus - required_cu, result_pool.sus - required_su
        else:
            # sort underfit pools descending according to the sum of diff cus and sus
            for pool in under_fit_pools:
                pool.unit_diff = pool.cus + pool.sus - required_cu - required_su
            sorted_result = sorted(under_fit_pools, key=lambda x: x.unit_diff, reverse=True)
            result_pool = sorted_result[0]
            return result_pool, result_pool.cus - required_cu, result_pool.sus - required_su

    def init_new_user_network(self, bot, username, pool_id, ip_version=&#34;IPv4&#34;):
        access_node = j.sals.reservation_chatflow.reservation_chatflow.get_nodes(
            1, pool_ids=[pool_id], ip_version=ip_version
        )[0]

        result = self.deploy_network(
            name=f&#34;{username}_apps&#34;,
            access_node=access_node,
            ip_range=&#34;10.100.0.0/16&#34;,
            ip_version=&#34;IPv4&#34;,
            pool_id=pool_id,
            owner=username,
        )
        for wid in result[&#34;ids&#34;]:
            try:
                success = self.wait_workload(wid, bot=bot)
            except StopChatFlow as e:
                for sol_wid in result[&#34;ids&#34;]:
                    j.sals.zos.get().workloads.decomission(sol_wid)
                raise e
            if not success:
                for sol_wid in result[&#34;ids&#34;]:
                    j.sals.zos.get().workloads.decomission(sol_wid)
                raise DeploymentFailed(
                    f&#34;Failed to deploy apps network in workload {wid}. The resources you paid for will be re-used in your upcoming deployments.&#34;,
                    wid=wid,
                )
        wgcfg = result[&#34;wg&#34;]
        return wgcfg

    def init_new_user(self, bot, username, farm_name, expiration, currency, **resources):
        pool_info = self.create_solution_pool(bot, username, farm_name, expiration, currency, **resources)
        qr_code = self.show_payment(pool_info, bot)
        result = self.wait_pool_payment(bot, pool_info.reservation_id, qr_code=qr_code)
        if not result:
            raise StopChatFlow(f&#34;Waiting for pool payment timedout. pool_id: {pool_info.reservation_id}&#34;)

        wgcfg = self.init_new_user_network(bot, username, pool_info.reservation_id)
        return pool_info, wgcfg

    def ask_expiration(self, bot, default=None, msg=&#34;&#34;, min=None, pool_empty_at=None):
        default = default or j.data.time.utcnow().timestamp + 3900
        min = min or 3600
        timestamp_now = j.data.time.utcnow().timestamp
        min_message = f&#34;Date/time should be at least {j.data.time.get(timestamp_now+min).humanize()} from now&#34;
        self.expiration = bot.datetime_picker(
            &#34;Please enter the solution&#39;s expiration time&#34; if not msg else msg,
            required=True,
            min_time=[min, min_message],
            default=default,
        )
        current_pool_expiration = pool_empty_at or j.data.time.utcnow().timestamp
        return self.expiration - current_pool_expiration


deployer = MarketPlaceDeployer()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="jumpscale.sals.marketplace.deployer.MarketPlaceDeployer"><code class="flex name class">
<span>class <span class="ident">MarketPlaceDeployer</span></span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">class MarketPlaceDeployer(ChatflowDeployer):

    WALLET_NAME = &#34;demos_wallet&#34;

    def list_user_pool_ids(self, username):
        user_pools = self.list_user_pools(username)
        user_pool_ids = [p.pool_id for p in user_pools]
        return user_pool_ids

    def list_user_pools(self, username):
        _, _, user_pools = pool_factory.find_many(owner=username)
        all_pools = [p for p in j.sals.zos.get().pools.list() if p.node_ids]
        user_pool_ids = [p.pool_id for p in user_pools]
        result = [p for p in all_pools if p.pool_id in user_pool_ids]
        return result

    def list_networks(self, username, next_action=NextAction.DEPLOY, sync=True):
        if sync:
            self.load_user_workloads(next_action=next_action)
        networks = {}  # name: last child network resource
        for pool_id in self.workloads[next_action][WorkloadType.Network_resource]:
            for workload in self.workloads[next_action][WorkloadType.Network_resource][pool_id]:
                metadata = j.data.serializers.json.loads(workload.info.metadata)
                if metadata.get(&#34;owner&#34;) == username:
                    networks[workload.name] = workload
        all_workloads = []
        workload_values = self.workloads[next_action].values()
        for pools_workloads in workload_values:
            for pool_id, workload_list in pools_workloads.items():
                for workload in workload_list:
                    metadata = j.data.serializers.json.loads(workload.info.metadata)
                    if metadata.get(&#34;owner&#34;) == username:
                        all_workloads.append(workload)
        network_views = {}
        if all_workloads:
            for network_name in networks:
                network_views[network_name] = NetworkView(network_name, all_workloads)
        return network_views

    def create_pool(self, username, bot):
        pool_info = super().create_pool(bot)
        user_pool = pool_factory.new(f&#34;pool_{username.replace(&#39;.3bot&#39;, &#39;&#39;)}_{pool_info.reservation_id}&#34;)
        user_pool.owner = username
        user_pool.pool_id = pool_info.reservation_id
        user_pool.save()
        return pool_info

    def show_payment(self, pool, bot):
        resv_id = pool.reservation_id
        resv_id_msg_text = f&#34;&#34;&#34;&lt;h3&gt;Make a Payment&lt;/h3&gt;
        Scan the QR code with your wallet (do not change the message) or enter the information below manually and proceed with the payment. Make sure to put p-{resv_id} as memo_text value.
        &#34;&#34;&#34;
        self.msg_payment_info, qr_code = self.get_qr_code_payment_info(pool)
        msg_text = resv_id_msg_text + self.msg_payment_info
        bot.qrcode_show(data=qr_code, msg=msg_text, scale=4, update=True, html=True, pool=pool)
        return qr_code

    def pay_for_pool(self, pool):
        info = self.get_payment_info(pool)
        WALLET_NAME = j.sals.marketplace.deployer.WALLET_NAME
        wallet = j.clients.stellar.get(name=WALLET_NAME)
        wallet.transfer(
            destination_address=info[&#34;escrow_address&#34;],
            amount=info[&#34;total_amount_dec&#34;],
            asset=info[&#34;escrow_asset&#34;],
            memo_text=f&#34;p-{info[&#39;resv_id&#39;]}&#34;,
        )

    def list_pools(self, username=None, cu=None, su=None):
        all_pools = self.list_user_pools(username)
        available_pools = {}
        for pool in all_pools:
            res = self.check_pool_capacity(pool, cu, su)
            available = res[0]
            if available:
                resources = res[1:]
                available_pools[pool.pool_id] = resources
        return available_pools

    def select_pool(
        self,
        username,
        bot,
        cu=None,
        su=None,
        sru=None,
        mru=None,
        hru=None,
        cru=None,
        available_pools=None,
        workload_name=None,
    ):
        user_pools = available_pools or self.list_pools(username, su=su, cu=cu)
        return super().select_pool(
            bot,
            cu=cu,
            su=su,
            sru=sru,
            mru=mru,
            hru=hru,
            cru=cru,
            available_pools=user_pools,
            workload_name=workload_name,
        )

    def select_network(self, username, bot):
        network_views = self.list_networks(username)
        network_names = [n[len(username) + 1 :] for n in network_views.keys()]
        if not network_views:
            raise StopChatFlow(f&#34;You don&#39;t have any deployed network.&#34;)
        network_name = bot.single_choice(&#34;Please select a network&#34;, network_names, required=True)
        return network_views[f&#34;{username}_{network_name}&#34;]

    def _check_pool_factory_owner(self, instance_name):
        pool_instance = pool_factory.get(instance_name)
        pool_id = pool_instance.pool_id
        pool_tid = j.sals.zos.get().pools.get(pool_id).customer_tid
        pool_explorer_url = pool_instance.explorer_url
        me = j.core.identity.me
        try:
            return pool_tid == me.tid and pool_explorer_url == me.explorer_url
        except HTTPError:
            return False

    def _get_gateways_pools(self, farm_name):
        &#34;&#34;&#34;
        Returns:
            List : will return pool ids for pools on farms with gateways
        &#34;&#34;&#34;
        gateways_pools_ids = []
        farms_ids_with_gateways = [
            gateway_farm.farm_id for gateway_farm in deployer._explorer.gateway.list() if gateway_farm.farm_id &gt; 0
        ]
        farms_names_with_gateways = set(
            map(lambda farm_id: deployer._explorer.farms.get(farm_id=farm_id).name, farms_ids_with_gateways)
        )

        for farm_name in farms_names_with_gateways:
            gw_pool_name = f&#34;marketplace_gateway_{farm_name}&#34;
            if gw_pool_name not in pool_factory.list_all() or not self._check_pool_factory_owner(gw_pool_name):
                gateways_pool_info = deployer.create_gateway_emptypool(gw_pool_name, farm_name)
                gateways_pools_ids.append(gateways_pool_info.reservation_id)
            else:
                pool_id = pool_factory.get(gw_pool_name).pool_id
                gateways_pools_ids.append(pool_id)
        return gateways_pools_ids

    def list_all_gateways(self, username, farm_name=None):
        pool_ids = self.list_user_pool_ids(username)
        gateways_pools = self._get_gateways_pools(farm_name)  # Empty pools contains the gateways only
        pool_ids.extend(gateways_pools)
        return super().list_all_gateways(pool_ids=pool_ids)

    def select_gateway(self, username, bot):
        &#34;&#34;&#34;
        Args:
            pool_ids: if specified it will only list gateways inside these pools

        Returns:
            gateway, pool_objects
        &#34;&#34;&#34;
        gateways = self.list_all_gateways(username)
        selected = bot.single_choice(&#34;Please select a gateway&#34;, list(gateways.keys()), required=True)
        return gateways[selected][&#34;gateway&#34;], gateways[selected][&#34;pool&#34;]

    def ask_multi_pool_placement(
        self, username, bot, number_of_nodes, resource_query_list=None, pool_ids=None, workload_names=None
    ):
        &#34;&#34;&#34;
        Ask and schedule workloads accross multiple pools

        Args:
            bot: chatflow object
            number_of_nodes: number of required nodes for deployment
            resource_query_list: list of query dicts {&#34;cru&#34;: 1, &#34;sru&#34;: 2, &#34;mru&#34;: 1, &#34;hru&#34;: 1}. if specified it must be same length as number_of_nodes
            pool_ids: if specfied it will limit the pools shown in the chatflow to only these pools
            workload_names: if specified they will shown when asking the user for node selection for each workload. if specified it must be same length as number_of_nodes

        Returns:
            ([], []): first list contains the selected node objects. second list contains selected pool ids
        &#34;&#34;&#34;
        resource_query_list = resource_query_list or [dict()] * number_of_nodes
        workload_names = workload_names or [None] * number_of_nodes
        if len(resource_query_list) != number_of_nodes:
            raise StopChatFlow(&#34;resource query_list must be same length as number of nodes&#34;)
        if len(workload_names) != number_of_nodes:
            raise StopChatFlow(&#34;workload_names must be same length as number of nodes&#34;)

        pools = self.list_pools(username)
        if pool_ids:
            filtered_pools = {}
            for pool_id in pools:
                if pool_id in pool_ids:
                    filtered_pools[pool_id] = pools[pool_id]
            pools = filtered_pools
        selected_nodes = []
        selected_pool_ids = []
        for i in range(number_of_nodes):
            cu, su = self.calculate_capacity_units(**resource_query_list[i])
            pool_choices = {}
            for p in pools:
                if pools[p][0] &lt; cu or pools[p][1] &lt; su:
                    continue
                nodes = j.sals.zos.get().nodes_finder.nodes_by_capacity(pool_id=p, **resource_query_list[i])
                if not nodes:
                    continue
                pool_choices[p] = pools[p]
            pool_id = self.select_pool(
                username, bot, available_pools=pool_choices, workload_name=workload_names[i], cu=cu, su=su
            )
            node = self.ask_container_placement(bot, pool_id, workload_name=workload_names[i], **resource_query_list[i])
            if not node:
                node = self.schedule_container(pool_id, **resource_query_list[i])
            selected_nodes.append(node)
            selected_pool_ids.append(pool_id)
        return selected_nodes, selected_pool_ids

    def ask_multi_pool_distribution(
        self, username, bot, number_of_nodes, resource_query=None, pool_ids=None, workload_name=None
    ):
        &#34;&#34;&#34;
        Choose multiple pools to distribute workload automatically

        Args:
            bot: chatflow object
            resource_query: query dict {&#34;cru&#34;: 1, &#34;sru&#34;: 2, &#34;mru&#34;: 1, &#34;hru&#34;: 1}.
            pool_ids: if specfied it will limit the pools shown in the chatflow to only these pools
            workload_name: name shown in the message
        Returns:
            ([], []): first list contains the selected node objects. second list contains selected pool ids
        &#34;&#34;&#34;
        resource_query = resource_query or {}
        cu, su = self.calculate_capacity_units(**resource_query)
        pools = self.list_pools(username, cu, su)
        if pool_ids:
            filtered_pools = {}
            for pool_id in pools:
                if pool_id in pool_ids:
                    filtered_pools[pool_id] = pools[pool_id]
            pools = filtered_pools

        workload_name = workload_name or &#34;workloads&#34;
        messages = {f&#34;Pool: {p} CU: {pools[p][0]} SU: {pools[p][1]}&#34;: p for p in pools}
        while True:
            pool_choices = bot.multi_list_choice(
                f&#34;Please select the pools you wish to distribute your {workload_name} on&#34;,
                options=list(messages.keys()),
                required=True,
            )
            if not pool_choices:
                bot.md_show(&#34;You must select at least one pool. please click next to try again.&#34;)
            else:
                break

        pool_ids = {}
        node_to_pool = {}
        for p in pool_choices:
            pool = pool_ids.get(messages[p], j.sals.zos.get().pools.get(messages[p]))
            pool_ids[messages[p]] = pool.pool_id
            for node_id in pool.node_ids:
                node_to_pool[node_id] = pool

        nodes = j.sals.reservation_chatflow.reservation_chatflow.get_nodes(
            number_of_nodes, pool_ids=list(pool_ids.values()), **resource_query
        )
        selected_nodes = []
        selected_pool_ids = []
        for node in nodes:
            selected_nodes.append(node)
            pool = node_to_pool[node.node_id]
            selected_pool_ids.append(pool.pool_id)
        return selected_nodes, selected_pool_ids

    def extend_solution_pool(self, bot, pool_id, expiration, currency, **resources):
        cu, su = self.calculate_capacity_units(**resources)
        cu = math.ceil(cu * expiration)
        su = math.ceil(su * expiration)

        # guard in case of negative results
        cu = max(cu, 0)
        su = max(su, 0)

        if not isinstance(currency, list):
            currency = [currency]
        if cu &gt; 0 or su &gt; 0:
            pool_info = j.sals.zos.get().pools.extend(pool_id, cu, su, currency)
            qr_code = self.show_payment(pool_info, bot)
            return pool_info, qr_code
        else:
            return None, None

    def create_solution_pool(self, bot, username, farm_name, expiration, currency, **resources):
        cu, su = self.calculate_capacity_units(**resources)
        pool_info = j.sals.zos.get().pools.create(int(cu * expiration), int(su * expiration), farm_name, [currency])
        user_pool = pool_factory.new(f&#34;pool_{username.replace(&#39;.3bot&#39;, &#39;&#39;)}_{pool_info.reservation_id}&#34;)
        user_pool.owner = username
        user_pool.pool_id = pool_info.reservation_id
        user_pool.save()
        return pool_info

    def create_gateway_emptypool(self, gwpool_name, farm_name):
        pool_info = j.sals.zos.get().pools.create(0, 0, farm_name, [&#34;TFT&#34;])
        user_pool = pool_factory.get(gwpool_name)
        user_pool.owner = gwpool_name
        user_pool.pool_id = pool_info.reservation_id
        user_pool.explorer_url = j.core.identity.me.explorer_url
        user_pool.save()
        return pool_info

    def get_free_pools(
        self, username, workload_types=None, free_to_use=False, cru=0, mru=0, sru=0, hru=0, ip_version=&#34;IPv6&#34;
    ):
        def is_pool_free(pool, nodes_dict):
            for node_id in pool.node_ids:
                node = nodes_dict.get(node_id)
                if node and not node.free_to_use:
                    return False
            return True

        user_pools = self.list_user_pools(username)
        j.sals.reservation_chatflow.deployer.load_user_workloads()
        free_pools = []
        workload_types = workload_types or [WorkloadType.Container]
        nodes = {}
        if free_to_use:
            nodes = {node.node_id: node for node in j.sals.zos.get()._explorer.nodes.list()}
        for pool in user_pools:
            valid = True
            try:
                j.sals.reservation_chatflow.reservation_chatflow.get_nodes(
                    1, cru=cru, mru=mru, sru=sru, hru=hru, ip_version=ip_version, pool_ids=[pool.pool_id],
                )
            except StopChatFlow as e:
                j.logger.warning(
                    f&#34;Failed to find resources for this reservation in this pool: {pool}, {e}. We will use another one.&#34;
                )
                continue

            if free_to_use and not is_pool_free(pool, nodes):
                continue
            for wokrkload_type in workload_types:
                if j.sals.reservation_chatflow.deployer.workloads[NextAction.DEPLOY][wokrkload_type][pool.pool_id]:
                    valid = False
                    break
            if not valid:
                continue
            if (pool.cus == 0 and pool.sus == 0) or pool.empty_at &lt; j.data.time.now().timestamp:
                continue

            free_pools.append(pool)
        return free_pools

    def get_best_fit_pool(self, pools, expiration, cru=0, mru=0, sru=0, hru=0):

        cu, su = self.calculate_capacity_units(cru, mru, sru, hru)
        required_cu = cu * expiration
        required_su = su * expiration
        exact_fit_pools = []  # contains pools that are exact match of the required resources
        over_fit_pools = []  # contains pools that have higher cus AND sus than the required resources
        under_fit_pools = []  # contains pools that have lower cus OR sus than the required resources
        for pool in pools:
            if pool.cus == required_cu and pool.sus == required_su:
                exact_fit_pools.append(pool)
            else:
                if pool.cus &lt; required_cu or pool.sus &lt; required_su:
                    under_fit_pools.append(pool)
                else:
                    over_fit_pools.append(pool)
        if exact_fit_pools:
            return random.choice(exact_fit_pools), 0, 0

        if over_fit_pools:
            # sort overfit_pools ascending according to the sum of extra cus and sus
            for pool in over_fit_pools:
                pool.unit_diff = pool.cus + pool.sus - required_cu - required_su
            sorted_result = sorted(over_fit_pools, key=lambda x: x.unit_diff)
            result_pool = sorted_result[0]
            return result_pool, result_pool.cus - required_cu, result_pool.sus - required_su
        else:
            # sort underfit pools descending according to the sum of diff cus and sus
            for pool in under_fit_pools:
                pool.unit_diff = pool.cus + pool.sus - required_cu - required_su
            sorted_result = sorted(under_fit_pools, key=lambda x: x.unit_diff, reverse=True)
            result_pool = sorted_result[0]
            return result_pool, result_pool.cus - required_cu, result_pool.sus - required_su

    def init_new_user_network(self, bot, username, pool_id, ip_version=&#34;IPv4&#34;):
        access_node = j.sals.reservation_chatflow.reservation_chatflow.get_nodes(
            1, pool_ids=[pool_id], ip_version=ip_version
        )[0]

        result = self.deploy_network(
            name=f&#34;{username}_apps&#34;,
            access_node=access_node,
            ip_range=&#34;10.100.0.0/16&#34;,
            ip_version=&#34;IPv4&#34;,
            pool_id=pool_id,
            owner=username,
        )
        for wid in result[&#34;ids&#34;]:
            try:
                success = self.wait_workload(wid, bot=bot)
            except StopChatFlow as e:
                for sol_wid in result[&#34;ids&#34;]:
                    j.sals.zos.get().workloads.decomission(sol_wid)
                raise e
            if not success:
                for sol_wid in result[&#34;ids&#34;]:
                    j.sals.zos.get().workloads.decomission(sol_wid)
                raise DeploymentFailed(
                    f&#34;Failed to deploy apps network in workload {wid}. The resources you paid for will be re-used in your upcoming deployments.&#34;,
                    wid=wid,
                )
        wgcfg = result[&#34;wg&#34;]
        return wgcfg

    def init_new_user(self, bot, username, farm_name, expiration, currency, **resources):
        pool_info = self.create_solution_pool(bot, username, farm_name, expiration, currency, **resources)
        qr_code = self.show_payment(pool_info, bot)
        result = self.wait_pool_payment(bot, pool_info.reservation_id, qr_code=qr_code)
        if not result:
            raise StopChatFlow(f&#34;Waiting for pool payment timedout. pool_id: {pool_info.reservation_id}&#34;)

        wgcfg = self.init_new_user_network(bot, username, pool_info.reservation_id)
        return pool_info, wgcfg

    def ask_expiration(self, bot, default=None, msg=&#34;&#34;, min=None, pool_empty_at=None):
        default = default or j.data.time.utcnow().timestamp + 3900
        min = min or 3600
        timestamp_now = j.data.time.utcnow().timestamp
        min_message = f&#34;Date/time should be at least {j.data.time.get(timestamp_now+min).humanize()} from now&#34;
        self.expiration = bot.datetime_picker(
            &#34;Please enter the solution&#39;s expiration time&#34; if not msg else msg,
            required=True,
            min_time=[min, min_message],
            default=default,
        )
        current_pool_expiration = pool_empty_at or j.data.time.utcnow().timestamp
        return self.expiration - current_pool_expiration</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="jumpscale.sals.reservation_chatflow.deployer.ChatflowDeployer" href="../reservation_chatflow/deployer.html#jumpscale.sals.reservation_chatflow.deployer.ChatflowDeployer">ChatflowDeployer</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="jumpscale.sals.marketplace.deployer.MarketPlaceDeployer.WALLET_NAME"><code class="name">var <span class="ident">WALLET_NAME</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="jumpscale.sals.marketplace.deployer.MarketPlaceDeployer.ask_expiration"><code class="name flex">
<span>def <span class="ident">ask_expiration</span></span>(<span>self, bot, default=None, msg=&#39;&#39;, min=None, pool_empty_at=None)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def ask_expiration(self, bot, default=None, msg=&#34;&#34;, min=None, pool_empty_at=None):
    default = default or j.data.time.utcnow().timestamp + 3900
    min = min or 3600
    timestamp_now = j.data.time.utcnow().timestamp
    min_message = f&#34;Date/time should be at least {j.data.time.get(timestamp_now+min).humanize()} from now&#34;
    self.expiration = bot.datetime_picker(
        &#34;Please enter the solution&#39;s expiration time&#34; if not msg else msg,
        required=True,
        min_time=[min, min_message],
        default=default,
    )
    current_pool_expiration = pool_empty_at or j.data.time.utcnow().timestamp
    return self.expiration - current_pool_expiration</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.marketplace.deployer.MarketPlaceDeployer.create_gateway_emptypool"><code class="name flex">
<span>def <span class="ident">create_gateway_emptypool</span></span>(<span>self, gwpool_name, farm_name)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def create_gateway_emptypool(self, gwpool_name, farm_name):
    pool_info = j.sals.zos.get().pools.create(0, 0, farm_name, [&#34;TFT&#34;])
    user_pool = pool_factory.get(gwpool_name)
    user_pool.owner = gwpool_name
    user_pool.pool_id = pool_info.reservation_id
    user_pool.explorer_url = j.core.identity.me.explorer_url
    user_pool.save()
    return pool_info</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.marketplace.deployer.MarketPlaceDeployer.create_pool"><code class="name flex">
<span>def <span class="ident">create_pool</span></span>(<span>self, username, bot)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def create_pool(self, username, bot):
    pool_info = super().create_pool(bot)
    user_pool = pool_factory.new(f&#34;pool_{username.replace(&#39;.3bot&#39;, &#39;&#39;)}_{pool_info.reservation_id}&#34;)
    user_pool.owner = username
    user_pool.pool_id = pool_info.reservation_id
    user_pool.save()
    return pool_info</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.marketplace.deployer.MarketPlaceDeployer.create_solution_pool"><code class="name flex">
<span>def <span class="ident">create_solution_pool</span></span>(<span>self, bot, username, farm_name, expiration, currency, **resources)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def create_solution_pool(self, bot, username, farm_name, expiration, currency, **resources):
    cu, su = self.calculate_capacity_units(**resources)
    pool_info = j.sals.zos.get().pools.create(int(cu * expiration), int(su * expiration), farm_name, [currency])
    user_pool = pool_factory.new(f&#34;pool_{username.replace(&#39;.3bot&#39;, &#39;&#39;)}_{pool_info.reservation_id}&#34;)
    user_pool.owner = username
    user_pool.pool_id = pool_info.reservation_id
    user_pool.save()
    return pool_info</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.marketplace.deployer.MarketPlaceDeployer.extend_solution_pool"><code class="name flex">
<span>def <span class="ident">extend_solution_pool</span></span>(<span>self, bot, pool_id, expiration, currency, **resources)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def extend_solution_pool(self, bot, pool_id, expiration, currency, **resources):
    cu, su = self.calculate_capacity_units(**resources)
    cu = math.ceil(cu * expiration)
    su = math.ceil(su * expiration)

    # guard in case of negative results
    cu = max(cu, 0)
    su = max(su, 0)

    if not isinstance(currency, list):
        currency = [currency]
    if cu &gt; 0 or su &gt; 0:
        pool_info = j.sals.zos.get().pools.extend(pool_id, cu, su, currency)
        qr_code = self.show_payment(pool_info, bot)
        return pool_info, qr_code
    else:
        return None, None</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.marketplace.deployer.MarketPlaceDeployer.get_best_fit_pool"><code class="name flex">
<span>def <span class="ident">get_best_fit_pool</span></span>(<span>self, pools, expiration, cru=0, mru=0, sru=0, hru=0)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def get_best_fit_pool(self, pools, expiration, cru=0, mru=0, sru=0, hru=0):

    cu, su = self.calculate_capacity_units(cru, mru, sru, hru)
    required_cu = cu * expiration
    required_su = su * expiration
    exact_fit_pools = []  # contains pools that are exact match of the required resources
    over_fit_pools = []  # contains pools that have higher cus AND sus than the required resources
    under_fit_pools = []  # contains pools that have lower cus OR sus than the required resources
    for pool in pools:
        if pool.cus == required_cu and pool.sus == required_su:
            exact_fit_pools.append(pool)
        else:
            if pool.cus &lt; required_cu or pool.sus &lt; required_su:
                under_fit_pools.append(pool)
            else:
                over_fit_pools.append(pool)
    if exact_fit_pools:
        return random.choice(exact_fit_pools), 0, 0

    if over_fit_pools:
        # sort overfit_pools ascending according to the sum of extra cus and sus
        for pool in over_fit_pools:
            pool.unit_diff = pool.cus + pool.sus - required_cu - required_su
        sorted_result = sorted(over_fit_pools, key=lambda x: x.unit_diff)
        result_pool = sorted_result[0]
        return result_pool, result_pool.cus - required_cu, result_pool.sus - required_su
    else:
        # sort underfit pools descending according to the sum of diff cus and sus
        for pool in under_fit_pools:
            pool.unit_diff = pool.cus + pool.sus - required_cu - required_su
        sorted_result = sorted(under_fit_pools, key=lambda x: x.unit_diff, reverse=True)
        result_pool = sorted_result[0]
        return result_pool, result_pool.cus - required_cu, result_pool.sus - required_su</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.marketplace.deployer.MarketPlaceDeployer.get_free_pools"><code class="name flex">
<span>def <span class="ident">get_free_pools</span></span>(<span>self, username, workload_types=None, free_to_use=False, cru=0, mru=0, sru=0, hru=0, ip_version=&#39;IPv6&#39;)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def get_free_pools(
    self, username, workload_types=None, free_to_use=False, cru=0, mru=0, sru=0, hru=0, ip_version=&#34;IPv6&#34;
):
    def is_pool_free(pool, nodes_dict):
        for node_id in pool.node_ids:
            node = nodes_dict.get(node_id)
            if node and not node.free_to_use:
                return False
        return True

    user_pools = self.list_user_pools(username)
    j.sals.reservation_chatflow.deployer.load_user_workloads()
    free_pools = []
    workload_types = workload_types or [WorkloadType.Container]
    nodes = {}
    if free_to_use:
        nodes = {node.node_id: node for node in j.sals.zos.get()._explorer.nodes.list()}
    for pool in user_pools:
        valid = True
        try:
            j.sals.reservation_chatflow.reservation_chatflow.get_nodes(
                1, cru=cru, mru=mru, sru=sru, hru=hru, ip_version=ip_version, pool_ids=[pool.pool_id],
            )
        except StopChatFlow as e:
            j.logger.warning(
                f&#34;Failed to find resources for this reservation in this pool: {pool}, {e}. We will use another one.&#34;
            )
            continue

        if free_to_use and not is_pool_free(pool, nodes):
            continue
        for wokrkload_type in workload_types:
            if j.sals.reservation_chatflow.deployer.workloads[NextAction.DEPLOY][wokrkload_type][pool.pool_id]:
                valid = False
                break
        if not valid:
            continue
        if (pool.cus == 0 and pool.sus == 0) or pool.empty_at &lt; j.data.time.now().timestamp:
            continue

        free_pools.append(pool)
    return free_pools</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.marketplace.deployer.MarketPlaceDeployer.init_new_user"><code class="name flex">
<span>def <span class="ident">init_new_user</span></span>(<span>self, bot, username, farm_name, expiration, currency, **resources)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def init_new_user(self, bot, username, farm_name, expiration, currency, **resources):
    pool_info = self.create_solution_pool(bot, username, farm_name, expiration, currency, **resources)
    qr_code = self.show_payment(pool_info, bot)
    result = self.wait_pool_payment(bot, pool_info.reservation_id, qr_code=qr_code)
    if not result:
        raise StopChatFlow(f&#34;Waiting for pool payment timedout. pool_id: {pool_info.reservation_id}&#34;)

    wgcfg = self.init_new_user_network(bot, username, pool_info.reservation_id)
    return pool_info, wgcfg</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.marketplace.deployer.MarketPlaceDeployer.init_new_user_network"><code class="name flex">
<span>def <span class="ident">init_new_user_network</span></span>(<span>self, bot, username, pool_id, ip_version=&#39;IPv4&#39;)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def init_new_user_network(self, bot, username, pool_id, ip_version=&#34;IPv4&#34;):
    access_node = j.sals.reservation_chatflow.reservation_chatflow.get_nodes(
        1, pool_ids=[pool_id], ip_version=ip_version
    )[0]

    result = self.deploy_network(
        name=f&#34;{username}_apps&#34;,
        access_node=access_node,
        ip_range=&#34;10.100.0.0/16&#34;,
        ip_version=&#34;IPv4&#34;,
        pool_id=pool_id,
        owner=username,
    )
    for wid in result[&#34;ids&#34;]:
        try:
            success = self.wait_workload(wid, bot=bot)
        except StopChatFlow as e:
            for sol_wid in result[&#34;ids&#34;]:
                j.sals.zos.get().workloads.decomission(sol_wid)
            raise e
        if not success:
            for sol_wid in result[&#34;ids&#34;]:
                j.sals.zos.get().workloads.decomission(sol_wid)
            raise DeploymentFailed(
                f&#34;Failed to deploy apps network in workload {wid}. The resources you paid for will be re-used in your upcoming deployments.&#34;,
                wid=wid,
            )
    wgcfg = result[&#34;wg&#34;]
    return wgcfg</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.marketplace.deployer.MarketPlaceDeployer.list_networks"><code class="name flex">
<span>def <span class="ident">list_networks</span></span>(<span>self, username, next_action=&lt;NextAction.DEPLOY: 3&gt;, sync=True)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def list_networks(self, username, next_action=NextAction.DEPLOY, sync=True):
    if sync:
        self.load_user_workloads(next_action=next_action)
    networks = {}  # name: last child network resource
    for pool_id in self.workloads[next_action][WorkloadType.Network_resource]:
        for workload in self.workloads[next_action][WorkloadType.Network_resource][pool_id]:
            metadata = j.data.serializers.json.loads(workload.info.metadata)
            if metadata.get(&#34;owner&#34;) == username:
                networks[workload.name] = workload
    all_workloads = []
    workload_values = self.workloads[next_action].values()
    for pools_workloads in workload_values:
        for pool_id, workload_list in pools_workloads.items():
            for workload in workload_list:
                metadata = j.data.serializers.json.loads(workload.info.metadata)
                if metadata.get(&#34;owner&#34;) == username:
                    all_workloads.append(workload)
    network_views = {}
    if all_workloads:
        for network_name in networks:
            network_views[network_name] = NetworkView(network_name, all_workloads)
    return network_views</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.marketplace.deployer.MarketPlaceDeployer.list_pools"><code class="name flex">
<span>def <span class="ident">list_pools</span></span>(<span>self, username=None, cu=None, su=None)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def list_pools(self, username=None, cu=None, su=None):
    all_pools = self.list_user_pools(username)
    available_pools = {}
    for pool in all_pools:
        res = self.check_pool_capacity(pool, cu, su)
        available = res[0]
        if available:
            resources = res[1:]
            available_pools[pool.pool_id] = resources
    return available_pools</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.marketplace.deployer.MarketPlaceDeployer.list_user_pool_ids"><code class="name flex">
<span>def <span class="ident">list_user_pool_ids</span></span>(<span>self, username)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def list_user_pool_ids(self, username):
    user_pools = self.list_user_pools(username)
    user_pool_ids = [p.pool_id for p in user_pools]
    return user_pool_ids</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.marketplace.deployer.MarketPlaceDeployer.list_user_pools"><code class="name flex">
<span>def <span class="ident">list_user_pools</span></span>(<span>self, username)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def list_user_pools(self, username):
    _, _, user_pools = pool_factory.find_many(owner=username)
    all_pools = [p for p in j.sals.zos.get().pools.list() if p.node_ids]
    user_pool_ids = [p.pool_id for p in user_pools]
    result = [p for p in all_pools if p.pool_id in user_pool_ids]
    return result</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.marketplace.deployer.MarketPlaceDeployer.pay_for_pool"><code class="name flex">
<span>def <span class="ident">pay_for_pool</span></span>(<span>self, pool)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def pay_for_pool(self, pool):
    info = self.get_payment_info(pool)
    WALLET_NAME = j.sals.marketplace.deployer.WALLET_NAME
    wallet = j.clients.stellar.get(name=WALLET_NAME)
    wallet.transfer(
        destination_address=info[&#34;escrow_address&#34;],
        amount=info[&#34;total_amount_dec&#34;],
        asset=info[&#34;escrow_asset&#34;],
        memo_text=f&#34;p-{info[&#39;resv_id&#39;]}&#34;,
    )</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.marketplace.deployer.MarketPlaceDeployer.select_network"><code class="name flex">
<span>def <span class="ident">select_network</span></span>(<span>self, username, bot)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def select_network(self, username, bot):
    network_views = self.list_networks(username)
    network_names = [n[len(username) + 1 :] for n in network_views.keys()]
    if not network_views:
        raise StopChatFlow(f&#34;You don&#39;t have any deployed network.&#34;)
    network_name = bot.single_choice(&#34;Please select a network&#34;, network_names, required=True)
    return network_views[f&#34;{username}_{network_name}&#34;]</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.marketplace.deployer.MarketPlaceDeployer.select_pool"><code class="name flex">
<span>def <span class="ident">select_pool</span></span>(<span>self, username, bot, cu=None, su=None, sru=None, mru=None, hru=None, cru=None, available_pools=None, workload_name=None)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def select_pool(
    self,
    username,
    bot,
    cu=None,
    su=None,
    sru=None,
    mru=None,
    hru=None,
    cru=None,
    available_pools=None,
    workload_name=None,
):
    user_pools = available_pools or self.list_pools(username, su=su, cu=cu)
    return super().select_pool(
        bot,
        cu=cu,
        su=su,
        sru=sru,
        mru=mru,
        hru=hru,
        cru=cru,
        available_pools=user_pools,
        workload_name=workload_name,
    )</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.marketplace.deployer.MarketPlaceDeployer.show_payment"><code class="name flex">
<span>def <span class="ident">show_payment</span></span>(<span>self, pool, bot)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def show_payment(self, pool, bot):
    resv_id = pool.reservation_id
    resv_id_msg_text = f&#34;&#34;&#34;&lt;h3&gt;Make a Payment&lt;/h3&gt;
    Scan the QR code with your wallet (do not change the message) or enter the information below manually and proceed with the payment. Make sure to put p-{resv_id} as memo_text value.
    &#34;&#34;&#34;
    self.msg_payment_info, qr_code = self.get_qr_code_payment_info(pool)
    msg_text = resv_id_msg_text + self.msg_payment_info
    bot.qrcode_show(data=qr_code, msg=msg_text, scale=4, update=True, html=True, pool=pool)
    return qr_code</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="jumpscale.sals.reservation_chatflow.deployer.ChatflowDeployer" href="../reservation_chatflow/deployer.html#jumpscale.sals.reservation_chatflow.deployer.ChatflowDeployer">ChatflowDeployer</a></b></code>:
<ul class="hlist">
<li><code><a title="jumpscale.sals.reservation_chatflow.deployer.ChatflowDeployer.ask_multi_pool_distribution" href="../reservation_chatflow/deployer.html#jumpscale.sals.reservation_chatflow.deployer.ChatflowDeployer.ask_multi_pool_distribution">ask_multi_pool_distribution</a></code></li>
<li><code><a title="jumpscale.sals.reservation_chatflow.deployer.ChatflowDeployer.ask_multi_pool_placement" href="../reservation_chatflow/deployer.html#jumpscale.sals.reservation_chatflow.deployer.ChatflowDeployer.ask_multi_pool_placement">ask_multi_pool_placement</a></code></li>
<li><code><a title="jumpscale.sals.reservation_chatflow.deployer.ChatflowDeployer.calculate_capacity_units" href="../reservation_chatflow/deployer.html#jumpscale.sals.reservation_chatflow.deployer.ChatflowDeployer.calculate_capacity_units">calculate_capacity_units</a></code></li>
<li><code><a title="jumpscale.sals.reservation_chatflow.deployer.ChatflowDeployer.create_proxy" href="../reservation_chatflow/deployer.html#jumpscale.sals.reservation_chatflow.deployer.ChatflowDeployer.create_proxy">create_proxy</a></code></li>
<li><code><a title="jumpscale.sals.reservation_chatflow.deployer.ChatflowDeployer.create_subdomain" href="../reservation_chatflow/deployer.html#jumpscale.sals.reservation_chatflow.deployer.ChatflowDeployer.create_subdomain">create_subdomain</a></code></li>
<li><code><a title="jumpscale.sals.reservation_chatflow.deployer.ChatflowDeployer.deploy_container" href="../reservation_chatflow/deployer.html#jumpscale.sals.reservation_chatflow.deployer.ChatflowDeployer.deploy_container">deploy_container</a></code></li>
<li><code><a title="jumpscale.sals.reservation_chatflow.deployer.ChatflowDeployer.deploy_kubernetes_cluster" href="../reservation_chatflow/deployer.html#jumpscale.sals.reservation_chatflow.deployer.ChatflowDeployer.deploy_kubernetes_cluster">deploy_kubernetes_cluster</a></code></li>
<li><code><a title="jumpscale.sals.reservation_chatflow.deployer.ChatflowDeployer.deploy_minio_zdb" href="../reservation_chatflow/deployer.html#jumpscale.sals.reservation_chatflow.deployer.ChatflowDeployer.deploy_minio_zdb">deploy_minio_zdb</a></code></li>
<li><code><a title="jumpscale.sals.reservation_chatflow.deployer.ChatflowDeployer.expose_and_create_certificate" href="../reservation_chatflow/deployer.html#jumpscale.sals.reservation_chatflow.deployer.ChatflowDeployer.expose_and_create_certificate">expose_and_create_certificate</a></code></li>
<li><code><a title="jumpscale.sals.reservation_chatflow.deployer.ChatflowDeployer.list_all_gateways" href="../reservation_chatflow/deployer.html#jumpscale.sals.reservation_chatflow.deployer.ChatflowDeployer.list_all_gateways">list_all_gateways</a></code></li>
<li><code><a title="jumpscale.sals.reservation_chatflow.deployer.ChatflowDeployer.list_pool_gateways" href="../reservation_chatflow/deployer.html#jumpscale.sals.reservation_chatflow.deployer.ChatflowDeployer.list_pool_gateways">list_pool_gateways</a></code></li>
<li><code><a title="jumpscale.sals.reservation_chatflow.deployer.ChatflowDeployer.select_gateway" href="../reservation_chatflow/deployer.html#jumpscale.sals.reservation_chatflow.deployer.ChatflowDeployer.select_gateway">select_gateway</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="jumpscale.sals.marketplace" href="index.html">jumpscale.sals.marketplace</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="jumpscale.sals.marketplace.deployer.MarketPlaceDeployer" href="#jumpscale.sals.marketplace.deployer.MarketPlaceDeployer">MarketPlaceDeployer</a></code></h4>
<ul class="">
<li><code><a title="jumpscale.sals.marketplace.deployer.MarketPlaceDeployer.WALLET_NAME" href="#jumpscale.sals.marketplace.deployer.MarketPlaceDeployer.WALLET_NAME">WALLET_NAME</a></code></li>
<li><code><a title="jumpscale.sals.marketplace.deployer.MarketPlaceDeployer.ask_expiration" href="#jumpscale.sals.marketplace.deployer.MarketPlaceDeployer.ask_expiration">ask_expiration</a></code></li>
<li><code><a title="jumpscale.sals.marketplace.deployer.MarketPlaceDeployer.create_gateway_emptypool" href="#jumpscale.sals.marketplace.deployer.MarketPlaceDeployer.create_gateway_emptypool">create_gateway_emptypool</a></code></li>
<li><code><a title="jumpscale.sals.marketplace.deployer.MarketPlaceDeployer.create_pool" href="#jumpscale.sals.marketplace.deployer.MarketPlaceDeployer.create_pool">create_pool</a></code></li>
<li><code><a title="jumpscale.sals.marketplace.deployer.MarketPlaceDeployer.create_solution_pool" href="#jumpscale.sals.marketplace.deployer.MarketPlaceDeployer.create_solution_pool">create_solution_pool</a></code></li>
<li><code><a title="jumpscale.sals.marketplace.deployer.MarketPlaceDeployer.extend_solution_pool" href="#jumpscale.sals.marketplace.deployer.MarketPlaceDeployer.extend_solution_pool">extend_solution_pool</a></code></li>
<li><code><a title="jumpscale.sals.marketplace.deployer.MarketPlaceDeployer.get_best_fit_pool" href="#jumpscale.sals.marketplace.deployer.MarketPlaceDeployer.get_best_fit_pool">get_best_fit_pool</a></code></li>
<li><code><a title="jumpscale.sals.marketplace.deployer.MarketPlaceDeployer.get_free_pools" href="#jumpscale.sals.marketplace.deployer.MarketPlaceDeployer.get_free_pools">get_free_pools</a></code></li>
<li><code><a title="jumpscale.sals.marketplace.deployer.MarketPlaceDeployer.init_new_user" href="#jumpscale.sals.marketplace.deployer.MarketPlaceDeployer.init_new_user">init_new_user</a></code></li>
<li><code><a title="jumpscale.sals.marketplace.deployer.MarketPlaceDeployer.init_new_user_network" href="#jumpscale.sals.marketplace.deployer.MarketPlaceDeployer.init_new_user_network">init_new_user_network</a></code></li>
<li><code><a title="jumpscale.sals.marketplace.deployer.MarketPlaceDeployer.list_networks" href="#jumpscale.sals.marketplace.deployer.MarketPlaceDeployer.list_networks">list_networks</a></code></li>
<li><code><a title="jumpscale.sals.marketplace.deployer.MarketPlaceDeployer.list_pools" href="#jumpscale.sals.marketplace.deployer.MarketPlaceDeployer.list_pools">list_pools</a></code></li>
<li><code><a title="jumpscale.sals.marketplace.deployer.MarketPlaceDeployer.list_user_pool_ids" href="#jumpscale.sals.marketplace.deployer.MarketPlaceDeployer.list_user_pool_ids">list_user_pool_ids</a></code></li>
<li><code><a title="jumpscale.sals.marketplace.deployer.MarketPlaceDeployer.list_user_pools" href="#jumpscale.sals.marketplace.deployer.MarketPlaceDeployer.list_user_pools">list_user_pools</a></code></li>
<li><code><a title="jumpscale.sals.marketplace.deployer.MarketPlaceDeployer.pay_for_pool" href="#jumpscale.sals.marketplace.deployer.MarketPlaceDeployer.pay_for_pool">pay_for_pool</a></code></li>
<li><code><a title="jumpscale.sals.marketplace.deployer.MarketPlaceDeployer.select_network" href="#jumpscale.sals.marketplace.deployer.MarketPlaceDeployer.select_network">select_network</a></code></li>
<li><code><a title="jumpscale.sals.marketplace.deployer.MarketPlaceDeployer.select_pool" href="#jumpscale.sals.marketplace.deployer.MarketPlaceDeployer.select_pool">select_pool</a></code></li>
<li><code><a title="jumpscale.sals.marketplace.deployer.MarketPlaceDeployer.show_payment" href="#jumpscale.sals.marketplace.deployer.MarketPlaceDeployer.show_payment">show_payment</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.6.4</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>
