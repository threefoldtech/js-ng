<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.6.4" />
<title>jumpscale.sals.process API documentation</title>
<meta name="description" content="This module execute process on system and manage them â€¦" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase;cursor:pointer}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>jumpscale.sals.process</code></h1>
</header>
<section id="section-intro">
<p>This module execute process on system and manage them</p>
<p>below are some examples of the functions included in this module (not all inclusive.):</p>
<h2 id="examples">Examples</h2>
<p>```</p>
<blockquote>
<blockquote>
<blockquote>
<p>from jumpscale.loader import j
import signal</p>
</blockquote>
</blockquote>
</blockquote>
<h1 id="to-create-a-process">to create a process</h1>
<pre><code>&gt;&gt;&gt; rc, out, err = j.sals.process.execute("ls", cwd="/tmp", showout=True)
# this executes ls command on dir "/tmp" showing output from stdout
</code></pre>
<h1 id="rc-contains-exit-status">rc -&gt; contains exit status</h1>
<h1 id="out-the-actual-output">out -&gt; the actual output</h1>
<h1 id="err-in-case-an-error-happened-this-var-will-contains-the-error-msg">err -&gt; in case an error happened this var will contains the error msg</h1>
<h1 id="checks-if-a-process-with-this-pid-is-exists-in-the-current-process-list">checks if a process with this pid is exists in the current process list</h1>
<pre><code>&gt;&gt;&gt; j.sals.process.is_alive(10022)
</code></pre>
<h1 id="checks-if-a-specific-command-is-available-on-the-system">Checks if a specific command is available on the system</h1>
<pre><code>&gt;&gt;&gt; j.sals.process.is_installed('top')
</code></pre>
<h1 id="kill-a-process-with-pid-10022-with-sigterm">kill a process with pid 10022 with SIGTERM</h1>
<pre><code>&gt;&gt;&gt; j.sals.process.kill(10022)
</code></pre>
<h1 id="kill-a-process-with-pid-10022-with-sigterm-wait-3-seconds-for-it-to-disappear-then-if-still-alive-kill-it-with-sigkill">kill a process with pid 10022 with SIGTERM, wait 3 seconds for it to disappear, then if still alive kill it with SIGKILL</h1>
<pre><code>&gt;&gt;&gt; j.sals.process.kill(10022, timeout=3, sure_kill=True)
</code></pre>
<h1 id="check-if-there-is-any-running-process-that-match-the-given-name">Check if there is any running process that match the given name.</h1>
<pre><code>&gt;&gt;&gt; j.sals.process.ps_find('python3')
</code></pre>
<h1 id="gets-pid-of-the-process-listenning-on-port-tcp-8000-ipv4-localhost-address">gets pid of the process listenning on port TCP 8000 ipv4 localhost address</h1>
<pre><code>&gt;&gt;&gt; j.sals.process.get_pid_by_port(8000)
</code></pre>
<h1 id="gets-pid-of-the-process-listenning-on-port-udp-8000-ipv6-localhost-address">gets pid of the process listenning on port UDP 8000 ipv6 localhost address</h1>
<pre><code>&gt;&gt;&gt; j.sals.process.get_pid_by_port(8000, ipv6=True, udp=True)
</code></pre>
<h1 id="returns-the-psutilprocess-object-that-is-listening-on-the-given-port">Returns the psutil.Process object that is listening on the given port</h1>
<pre><code>&gt;&gt;&gt; j.sals.process.get_process_by_port(8000, ipv6=True, udp=True)
</code></pre>
<h1 id="get-pids-of-process-by-a-filter-string-and-sort-by-cpu-utilization-descendingly">Get pids of process by a filter string and sort by cpu utilization descendingly</h1>
<pre><code>&gt;&gt;&gt; j.sals.process.get_pids_filtered_sorted('chrome', sort='%cpu', desc=True)
</code></pre>
<h1 id="return-a-list-of-processes-ids-matching-the-given-name">Return a list of processes ID(s) matching the given name.</h1>
<pre><code>&gt;&gt;&gt; j.sals.process.get_pids('code')
</code></pre>
<h1 id="return-a-list-of-processes-ids-matching-the-given-name-including-the-result-of-matching-againest-the-full-command-line">Return a list of processes ID(s) matching the given name, including the result of matching againest the full command line.</h1>
<pre><code>&gt;&gt;&gt; j.sals.process.get_pids('http.server', full_cmd_line=True)
</code></pre>
<h1 id="return-a-list-of-processes-ids-matching-the-given-name-including-any-zombie-processes">Return a list of processes ID(s) matching the given name, including any zombie processes</h1>
<pre><code>&gt;&gt;&gt; j.sals.process.get_pids('python3', include_zombie=False)
</code></pre>
<h1 id="get-processes-info-about-top-3-processes-which-consumed-the-most-memory">get processes info about top 3 processes which consumed the most memory</h1>
<pre><code>&gt;&gt;&gt; j.sals.process.get_processes_info(limit=3)
</code></pre>
<h1 id="get-processes-info-about-top-3-processes-which-consumed-the-most-cpu-time">get processes info about top 3 processes which consumed the most cpu time</h1>
<pre><code>&gt;&gt;&gt; j.sals.process.get_processes_info(sort='cpu_time', limit=3)
</code></pre>
<h1 id="get-processes-info-about-last-process-started">get processes info about last process started</h1>
<pre><code>&gt;&gt;&gt; j.sals.process.get_processes_info(sort='create_time', limit=1)
</code></pre>
<h1 id="get-processes-info-sorted-by-pid-ascending-limited-to-10-processes">get processes info sorted by pid ascending limited to 10 processes</h1>
<pre><code>&gt;&gt;&gt; j.sals.process.get_processes_info(sort='pid', limit=10, desc=False)
</code></pre>
<h1 id="kill-a-process-and-its-children-including-grandchildren-with-sigterm-and-fallback-to-sigkill-when-needed">Kill a process and its children (including grandchildren) with SIGTERM and fallback to SIGKILL when needed</h1>
<pre><code>&gt;&gt;&gt; j.sals.process.kill_proc_tree(20778, sure_kill=True)
</code></pre>
<h1 id="send-sigterm-to-all-processes-spawned-by-a-given-process-but-leave-the-process-itself">send SIGTERM to all processes spawned by a given process, but leave the process itself.</h1>
<pre><code>&gt;&gt;&gt; j.sals.process.kill_proc_tree(20778, include_parent=False)
</code></pre>
<h1 id="terminate-a-list-of-processes-with-a-given-list-of-pids-fallback-to-sigkill-after-1-seconds">Terminate a list of processes with a given list of pids, fallback to SIGKILL after 1 seconds.</h1>
<pre><code>&gt;&gt;&gt; j.sals.process.kill_all_pids([3067, 7888, 10221], timeout=1, sure_kill=True)
</code></pre>
<h1 id="terminate-a-process-that-listen-to-a-given-tcp-port-on-ipv4-address">terminate a process that listen to a given tcp port on ipv4 address</h1>
<pre><code>&gt;&gt;&gt; j.sals.process.kill_process_by_port(8000)
</code></pre>
<h1 id="terminate-a-process-that-listen-to-a-given-udp-port-on-ipv6-address-fallback-to-sigkill-after-3-sec">terminate a process that listen to a given udp port on ipv6 address, fallback to SIGKILL after 3 sec</h1>
<pre><code>&gt;&gt;&gt; j.sals.process.kill_process_by_port(8000, udp=True, ipv6=True, timeout=3, sure_kill=True)
</code></pre>
<h1 id="terminate-all-processes-owned-by-a-given-user-name-fallback-to-sigkill-when-needed">Terminate all processes owned by a given user name, fallback to SIGKILL when needed</h1>
<pre><code>&gt;&gt;&gt; j.sals.process.kill_user_processes('sameh', sure_kill=True)
```
</code></pre>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">&#34;&#34;&#34;This module execute process on system and manage them

below are some examples of the functions included in this module (not all inclusive.):

Examples:
    ```
    &gt;&gt;&gt; from jumpscale.loader import j
    &gt;&gt;&gt; import signal

    #to create a process
    &gt;&gt;&gt; rc, out, err = j.sals.process.execute(&#34;ls&#34;, cwd=&#34;/tmp&#34;, showout=True)
    # this executes ls command on dir &#34;/tmp&#34; showing output from stdout
    # rc -&gt; contains exit status
    # out -&gt; the actual output
    # err -&gt; in case an error happened this var will contains the error msg

    # checks if a process with this pid is exists in the current process list
    &gt;&gt;&gt; j.sals.process.is_alive(10022)

    # Checks if a specific command is available on the system
    &gt;&gt;&gt; j.sals.process.is_installed(&#39;top&#39;)

    # kill a process with pid 10022 with SIGTERM
    &gt;&gt;&gt; j.sals.process.kill(10022)

    # kill a process with pid 10022 with SIGTERM, wait 3 seconds for it to disappear, then if still alive kill it with SIGKILL
    &gt;&gt;&gt; j.sals.process.kill(10022, timeout=3, sure_kill=True)

    # Check if there is any running process that match the given name.
    &gt;&gt;&gt; j.sals.process.ps_find(&#39;python3&#39;)

    # gets pid of the process listenning on port TCP 8000 ipv4 localhost address
    &gt;&gt;&gt; j.sals.process.get_pid_by_port(8000)

    # gets pid of the process listenning on port UDP 8000 ipv6 localhost address
    &gt;&gt;&gt; j.sals.process.get_pid_by_port(8000, ipv6=True, udp=True)

    # Returns the psutil.Process object that is listening on the given port
    &gt;&gt;&gt; j.sals.process.get_process_by_port(8000, ipv6=True, udp=True)

    # Get pids of process by a filter string and sort by cpu utilization descendingly
    &gt;&gt;&gt; j.sals.process.get_pids_filtered_sorted(&#39;chrome&#39;, sort=&#39;%cpu&#39;, desc=True)

    # Return a list of processes ID(s) matching the given name.
    &gt;&gt;&gt; j.sals.process.get_pids(&#39;code&#39;)

    # Return a list of processes ID(s) matching the given name, including the result of matching againest the full command line.
    &gt;&gt;&gt; j.sals.process.get_pids(&#39;http.server&#39;, full_cmd_line=True)

    # Return a list of processes ID(s) matching the given name, including any zombie processes
    &gt;&gt;&gt; j.sals.process.get_pids(&#39;python3&#39;, include_zombie=False)

    # get processes info about top 3 processes which consumed the most memory
    &gt;&gt;&gt; j.sals.process.get_processes_info(limit=3)

    # get processes info about top 3 processes which consumed the most cpu time
    &gt;&gt;&gt; j.sals.process.get_processes_info(sort=&#39;cpu_time&#39;, limit=3)

    # get processes info about last process started
    &gt;&gt;&gt; j.sals.process.get_processes_info(sort=&#39;create_time&#39;, limit=1)

    # get processes info sorted by pid ascending limited to 10 processes
    &gt;&gt;&gt; j.sals.process.get_processes_info(sort=&#39;pid&#39;, limit=10, desc=False)

    # Kill a process and its children (including grandchildren) with SIGTERM and fallback to SIGKILL when needed
    &gt;&gt;&gt; j.sals.process.kill_proc_tree(20778, sure_kill=True)

    # send SIGTERM to all processes spawned by a given process, but leave the process itself.
    &gt;&gt;&gt; j.sals.process.kill_proc_tree(20778, include_parent=False)

    # Terminate a list of processes with a given list of pids, fallback to SIGKILL after 1 seconds.
    &gt;&gt;&gt; j.sals.process.kill_all_pids([3067, 7888, 10221], timeout=1, sure_kill=True)

    # terminate a process that listen to a given tcp port on ipv4 address
    &gt;&gt;&gt; j.sals.process.kill_process_by_port(8000)

    # terminate a process that listen to a given udp port on ipv6 address, fallback to SIGKILL after 3 sec
    &gt;&gt;&gt; j.sals.process.kill_process_by_port(8000, udp=True, ipv6=True, timeout=3, sure_kill=True)

    # Terminate all processes owned by a given user name, fallback to SIGKILL when needed
    &gt;&gt;&gt; j.sals.process.kill_user_processes(&#39;sameh&#39;, sure_kill=True)
    ```
&#34;&#34;&#34;


import math
import os
import re
import shlex
import signal
import subprocess
import time
from collections import defaultdict

import psutil
from jumpscale.loader import j


def execute(
    cmd,
    showout=False,
    cwd=None,
    shell=&#34;/bin/bash&#34;,
    timeout=600,
    asynchronous=False,
    env=None,
    replace_env=False,
    die=False,
):
    &#34;&#34;&#34;Execute a command.

    Accepts command as a list too, with auto-escaping.

    Args:
        cmd (str or list of str): Command to be executed, e.g. &#34;ls -la&#34; or [&#34;ls&#34;, &#34;-la&#34;]
        showout (bool, optional): Whether to show stdout of the command or not. Defaults to False.
        cwd (str, optional): Path to `cd` into before running command. Defaults to None.
        shell (str, optional): Specify a working directory for the command. Defaults to &#34;/bin/bash&#34;.
        timeout (int, optional): Timeout before kill the process. Defaults to 600.
        asynchronous (bool, optional): Whether to execute in asynchronous mode or not. Defaults to False.
        env (dict, optional): Add environment variables here. Defaults to None.
        replace_env (bool, optional): Whether to replace the entire environment with env. Defaults to False.
        die (bool, optional): Whether to raise exception if command failed or not. Defaults to False.

    Returns:
        tuple: tuple[return_code: int, stdout: str, stderr: str]
    &#34;&#34;&#34;
    return j.core.executors.run_local(
        cmd=cmd,
        hide=not showout,
        cwd=cwd,
        shell=shell,
        timeout=timeout,
        asynchronous=asynchronous,
        env=env or {},
        replace_env=replace_env,
        warn=not die,
    )


def is_alive(pid):
    &#34;&#34;&#34;Check whether the given PID exists in the current process list.

    Args:
        pid (int): Process ID (PID) to be checked.

    Returns:
        bool: True if the given PID exists in the current process list, False otherwise.
    &#34;&#34;&#34;
    return psutil.pid_exists(pid)


def is_installed(cmd):
    &#34;&#34;&#34;Checks if a specific command is available on system e.g. curl.

    Args:
        cmd (str): Command to be checked.

    Returns:
        bool: True if command is available, False otherwise.
    &#34;&#34;&#34;
    rc, _, _ = execute(f&#34;which {cmd}&#34;, die=False)
    return rc == 0


def kill(proc, sig=signal.SIGTERM, timeout=5, sure_kill=False):
    &#34;&#34;&#34;Kill a process with a specified signal.

    Args:
        proc (int or psutil.Process): Target process ID (PID) or psutil.Process object.
        sig (signal, optional): See signal module constants. Defaults to signal.SIGTERM.
        timeout (int, optional): How long to wait for a process to terminate (seconds) before raise exception
            or, if sure_kill=True, send a SIGKILL. Defaults to 5.
        sure_kill (bool, optional): Whether to fallback to SIGKILL if the timeout exceeded for the terminate operation or not. Defaults to False.

    Raises:
        j.exceptions.Runtime: In case killing the process failed.
        j.exceptions.Permission: In case the permission to perform this action is denied.
    &#34;&#34;&#34;
    try:
        if isinstance(proc, int):
            proc = get_process_object(proc, die=True)
        if proc.status() == psutil.STATUS_ZOMBIE:
            return
        proc.send_signal(sig)
        # Wait for a process to terminate
        # If PID no longer exists return None immediately
        # If timeout exceeded and the process is still alive raise TimeoutExpired exception
        proc.wait(timeout=timeout)
        # the process with PID {proc.pid} was terminated with sig {sig}
    except psutil.TimeoutExpired as e:
        # timeout expires and process is still alive.
        if sure_kill and sig != signal.SIGKILL and os.name != &#34;nt&#34;:
            # SIGKILL not supported in windows
            # If a process gets this signal it must quit immediately and will not perform any clean-up operations
            proc.kill()
            # SIGKILL signal sent
            try:
                proc.wait(1)
                # the process with PID {proc.pid} was terminated with sig {signal.SIGKILL}
            except psutil.TimeoutExpired as e:
                if proc.status() == psutil.STATUS_ZOMBIE:
                    # the process with PID: {proc.pid} becomes a zombie and should be considered a dead.
                    return
                # the process may be in an uninterruptible sleep
                j.logger.warning(f&#34;Could not kill the process with pid: {proc.pid} with {sig}. Timeout: {timeout}&#34;)
                raise j.exceptions.Runtime(f&#34;Could not kill process with pid {proc.pid}, {proc.status()}&#34;) from e
        else:
            raise j.exceptions.Runtime(f&#34;Could not kill process with pid {proc.pid}&#34;) from e
    except psutil.AccessDenied as e:
        # permission to perform an action is denied
        raise j.exceptions.Permission(&#34;Permission to perform this action is denied!&#34;) from e
    except psutil.NoSuchProcess:
        # Process no longer exists or Zombie (already dead)
        pass


def ps_find(process_name):
    &#34;&#34;&#34;Check if there is any running process that match the given name.

    Args:
        process_name (str): The target process name. will match against against Process.name(), Process.exe() and Process.cmdline()

    Returns:
        bool: True if process is found, False otherwise.
    &#34;&#34;&#34;
    return len(get_pids(process_name, limit=1)) == 1


def get_pids_filtered_sorted(filterstr, sortkey=None, desc=False):
    &#34;&#34;&#34;Get pids of process by a filter string and optionally sort by sortkey

    Args:
        filterstr (str): filter string.
        sortkey (str, optional): Defaults to None. (if no sortkey used it will sort by pid(s) in ascending order).
            sortkey can be one of the following:
            %cpu           cpu utilization of the process in
            %mem           ratio of the process&#39;s resident set size  to the physical memory on the machine, expressed as a percentage.
            cputime        cumulative CPU time, &#34;[DD-]hh:mm:ss&#34; format.  (alias time).
            egid           effective group ID number of the process as a decimal integer.  (alias gid).
            egroup         effective group ID of the process. This will be the textual group ID, if it can be obtained and the field width permits, or a decimal representation otherwise.  (alias group).
            euid           effective user ID (alias uid).
            euser          effective user name.
            gid            see egid. (alias egid).
            pid            a number representing the process ID (alias tgid).
            ppid           parent process ID.
            psr            processor that process is currently assigned to.
            start_time     starting time or date of the process.
        desc: (bool, optional): Whether to sort the processes in descending order or not(asc). Defaults to False (asc).

    Returns:
        list of int: list of the processes IDs
    &#34;&#34;&#34;
    ps_to_psutil_map = {
        &#34;%cpu&#34;: &#34;cpu_percent&#34;,
        &#34;%mem&#34;: &#34;memory_percent&#34;,
        &#34;cputime&#34;: &#34;cpu_time&#34;,
        &#34;psr&#34;: &#34;cpu_num&#34;,
        &#34;start_time&#34;: &#34;create_time&#34;,
        &#34;egid&#34;: &#34;egid&#34;,
        &#34;gid&#34;: &#34;egid&#34;,
        &#34;euid&#34;: &#34;euid&#34;,
        &#34;uid&#34;: &#34;euid&#34;,
        &#34;euser&#34;: &#34;username&#34;,
        &#34;pid&#34;: &#34;pid&#34;,
        &#34;ppid&#34;: &#34;ppid&#34;,
    }
    if sortkey is None:  # mimic default ps commnad sorting behavior
        sortkey = &#34;pid&#34;
    # return pids from process objects
    return [p[&#34;pid&#34;] for p in get_processes_info(sort=ps_to_psutil_map[sortkey], filterstr=filterstr, desc=desc)]


def get_filtered_pids(filterstr, excludes=None):
    &#34;&#34;&#34;Get pids filtered by filterstr and excludes, matching against the full command line used to start the process.

    Args:
        filterstr (str): the String to filter based on.
        excludes (list[str]): exclude list. Defaults to None.

    Returns:
        list of int: List of the processes IDs
    &#34;&#34;&#34;
    pids = []
    for proc in psutil.process_iter([&#34;name&#34;, &#34;cmdline&#34;]):
        cmd_line = &#34; &#34;.join(proc.info[&#34;cmdline&#34;])
        if proc.info[&#34;cmdline&#34;] and filterstr in cmd_line:
            # found filter string: {filterstr} in command line: {cmd_line}
            if excludes:
                for exclude in excludes:
                    if exclude in cmd_line:
                        # we excluded this because it contain exclude string
                        break
                else:  # intended `for/else` meaning for loop finished normally with no break
                    pids.append(proc.pid)  # may yield proc instead
                continue
            else:
                pids.append(proc.pid)  # may yield proc instead
    # if pids is empty root could be needed
    return pids


def get_pids_filtered_by_regex(regex_list):
    &#34;&#34;&#34;Get pids of a process filtered by Regex list, matching against the full command line used to start the process.

    Args:
        regex_list (list[str]): List of regex expressions.

    Returns:
        list of int: List of the processes IDs.
    &#34;&#34;&#34;
    res = []
    for process in psutil.process_iter(attrs=[&#34;cmdline&#34;]):
        if process.info[&#34;cmdline&#34;]:
            cmdline = &#34; &#34;.join(process.info[&#34;cmdline&#34;])
            for r in regex_list:
                if re.match(r, cmdline):
                    res.append(process.pid)
    return res


def check_start(cmd, filterstr, n_instances=1, retry=1, timeout=2, delay=0.5):
    &#34;&#34;&#34;Run command (possibly multiple times) and check if it is started based on filterstr

    Args:
        cmd (str or list of str): Command to be executed.
        filterstr (str): Filter string. will match against against Process.name(), Process.exe() and Process.cmdline()
        n_instances (int, optional): Number of needed instances. Defaults to 1.
        retry (int, optional): Number of retries to execute the command and check. Defaults to 1.
        timout (int, optional): how long the function should wait for process to finish (first or parnet process started with the command)
        delay (int, optional): how long the function should delay the checking process after the process finished or timeout exceeded (in case the first process started another one).

    Raises:
        j.exceptions.Runtime: will be raised if we didn&#39;t reach number of required instances.
    &#34;&#34;&#34;
    for i in range(retry):
        if isinstance(cmd, str):
            args = shlex.split(cmd)
        proc = psutil.Popen(args, close_fds=True, stdout=subprocess.PIPE, stdin=subprocess.PIPE, stderr=subprocess.PIPE)
        try:
            rc = proc.wait(timeout)  # makesure the process is stable
            if rc != 0:  # executing the command succeeded but exited immediately!
                output, error_output = proc.communicate()
                j.logger.error(f&#34;the start command exited with error: {error_output}&#34;)  # the process exited with error
        except psutil.TimeoutExpired:
            pass  # still running
        # wait extra delay to allow any subprocess spawned from the process we just started to finish
        # this may not needed in many cases
        time.sleep(delay)
        # TODO check based on command
        if check_running(filterstr, min=n_instances):
            # found at least {n_instances} instances using the filter string {filterstr}
            return
        else:
            # the required number of instances using the filter string {filterstr} not found yet!
            continue
    j.logger.error(f&#34;could not start the required number of instances ({n_instances}) after {i} attempts.&#34;)
    raise j.exceptions.Runtime(&#34;could not start the required number of instances.&#34;)


def check_stop(cmd, filterstr, retry=1, n_instances=0, timeout=2, delay=0.5):
    &#34;&#34;&#34;Executes a stop command (possibly multiple times) and check if it is already stopped based on filterstr

    Args:
        cmd (str): Command to be executed.
        filterstr (str): Filter string.
        retry (int, optional): Number of retries. Defaults to 1.
        n_inst (int, optional): Number of instances after stop. Defaults to 0.
        timout (int, optional): how long the function should wait for process to finish (first or parnet process started with the command)
        delay (int, optional): how long the function should delay the checking process after the process finished or timeout exceeded (in case the first process started another one).

    Raises:
        j.exceptions.Runtime: if number of instances not matched
    &#34;&#34;&#34;

    for i in range(retry):
        if isinstance(cmd, str):
            args = shlex.split(cmd)
        proc = psutil.Popen(args, close_fds=True, stdout=subprocess.PIPE, stdin=subprocess.PIPE, stderr=subprocess.PIPE)
        try:
            rc = proc.wait(timeout)  # makesure the process is stable
            # print(f&#39;rc: {rc}&#39;)
            if rc != 0:
                # the process exited with error
                output, error_output = proc.communicate()
                j.logger.warnnig(f&#34;the stop command exited with error: {error_output}&#34;)
        except psutil.TimeoutExpired:
            # still running
            pass
        # wait extra delay to allow any subprocess spawned from the process we just started to finish
        # this may not needed in many cases
        time.sleep(delay)
        found = get_pids(filterstr)
        if len(found) == n_instances:
            # the required {n_instances} matching the instances found using the filter string: {filterstr}
            return
        else:
            # the required {n_instances} not matching the instances number found using the filter string: {filterstr} yet
            continue
    # could not match the required number of instances {n_instances} after {i} attempts.
    raise j.exceptions.Runtime(f&#34;could not stop {cmd}, found {len(found)} of instances instead of {n_instances}&#34;)


def get_pids(process_name, match_predicate=None, limit=0, _alt_source=None, include_zombie=False, full_cmd_line=False):
    &#34;&#34;&#34;Return a list of processes ID(s) matching a given process name.

    Function will check string against Process.name(), Process.exe() and Process.cmdline()

    Args:
        process_name (str): The target process name
        match_predicate (callable, optional): Function that does matching between found processes and the targeted process.
            the function should accept two arguments and return a boolean. Defaults to None.
        limit (int, optional): If not equal to 0, function will return as fast as the number of PID(s) found become equal to `limit` value.
        _alt_source(callable or iterable, optional): Can be used to specify an alternative source of the psutil.Process objects to match against.
            ex: get_user_processes func, or get_similar_processes.
            if not specified, psutil.process_iter will be used. Defaults to None.
        include_zombie (bool, optional): Whether to include pid for zombie proccesses or not. Defaults to False.
        full_cmd_line (bool, optional): The pattern is normally only matched against the process name.
            if full_cmd_line is set to True, the full command line is used. Defaults to False.

    Returns:
        list of int: List of the processes IDs.
    &#34;&#34;&#34;
    # default match predicate
    def default_predicate(target, given):
        if isinstance(given, list):
            return target in given
        else:
            return target.strip().lower() == given.lower()

    default_processes_source = psutil.process_iter([&#34;name&#34;, &#34;exe&#34;, &#34;cmdline&#34;])

    match_predicate = match_predicate or default_predicate
    p_source = _alt_source or default_processes_source

    pids = []
    for proc in p_source:
        try:
            if not include_zombie and proc.status() == psutil.STATUS_ZOMBIE:
                # {proc.pid} is a zombie process, ignoring it
                continue

            candidates = [proc.info[&#34;name&#34;]]
            if proc.info[&#34;exe&#34;]:
                candidates.append(os.path.basename(proc.info[&#34;exe&#34;]))
            if proc.info[&#34;cmdline&#34;]:
                if full_cmd_line:
                    candidates.append(proc.info[&#34;cmdline&#34;])
                else:
                    candidates.append(os.path.basename(proc.info[&#34;cmdline&#34;][0]))

            if any([match_predicate(process_name, candidate) for candidate in candidates]):
                pids.append(proc.pid)
                # return early if no need to iterate over all running process
                if limit and len(pids) == limit:
                    return pids
        except psutil.Error:
            pass
    return pids


def get_my_process():
    &#34;&#34;&#34;Get psutil.Process object of the current process.

    Returns:
        psutil.Process: Process object of the current process.
    &#34;&#34;&#34;
    return get_process_object(os.getpid(), die=True)


def get_process_object(pid, die=False):
    &#34;&#34;&#34;Get psutil.Process object of a given process ID (PID).

    Args:
        pid (int): Process ID (PID) to get
        die (bool, optional): Whether to raise an exception if no process with the given PID is found in the
            current process list or not. Defaults to False.

    Raises:
        psutil.NoSuchProcess: If process with the given PID is not found and die set to True.
        psutil.AccessDenied: If permission denied.

    Returns:
        psutil.Process or None: The Process object of the given PID if found, otherwise None, if die set to False.
    &#34;&#34;&#34;
    try:
        return psutil.Process(pid)
    except (psutil.AccessDenied, psutil.NoSuchProcess) as e:
        # when you query processess owned by another user, especially on macOS and Windows you may get AccessDenied exception
        if die:
            raise e
        else:
            return None


def get_user_processes(user):
    &#34;&#34;&#34;Get all process for a specific user.

    Args:
        user (str): The user name to match against.

    Yields:
        psutil.Process: process object for all processes owned by `user`.
    &#34;&#34;&#34;
    try:
        for process in psutil.process_iter([&#34;name&#34;, &#34;exe&#34;, &#34;cmdline&#34;]):
            if process.username() == user:
                yield process
    except (psutil.AccessDenied, psutil.NoSuchProcess):
        pass


def kill_user_processes(user, sig=signal.SIGTERM, timeout=5, sure_kill=False):
    &#34;&#34;&#34;Kill all processes for a specific user.

    Args:
        user (str): The user name to match against.
        sig (signal, optional): See signal module constants. Defaults to signal.SIGTERM.
        timeout (int, optional): How long to wait for a process to terminate (seconds) before raise exception or, if sure_kill=True, send a SIGKILL. Defaults to 5.
        sure_kill (bool, optional): Whether to fallback to SIGKILL if the timeout exceeded for the terminate operation or not. Defaults to False.

    Returns:
        list of psutil.Process): list of process objects that remain alive if any.
    &#34;&#34;&#34;
    failed_processes = []
    for proc in get_user_processes(user):
        try:
            kill(proc, sig=sig, timeout=timeout, sure_kill=sure_kill)
        except (j.exceptions.Runtime, j.exceptions.Permission) as e:
            j.logger.exception(&#34;ignoring an exception that occurred while iterating over user processes&#34;, exception=e)
            failed_processes.append(proc)

    # making sure
    if failed_processes:
        gone, failed_processes = psutil.wait_procs(failed_processes, timeout=0)

    return failed_processes


def get_similar_processes(target_proc=None):
    &#34;&#34;&#34;Gets similar processes to current process, started with same command line and same options.

    Args:
        target_proc (int or psutil.Process, optional): pid, or psutil.Process object.
            if None then pid for current process will be used. Defaults to None.

    Yields:
        psutil.Process: psutil.Process object for all processes similar to a given process.
    &#34;&#34;&#34;
    try:
        if target_proc is None:
            target_proc = get_my_process()
        elif isinstance(target_proc, int):
            target_proc = get_process_object(target_proc, die=True)
        for proc in psutil.process_iter([&#34;name&#34;, &#34;exe&#34;, &#34;cmdline&#34;]):
            if proc.info[&#34;cmdline&#34;] and target_proc.cmdline() and proc.info[&#34;cmdline&#34;] == target_proc.cmdline():
                yield proc
    except (psutil.AccessDenied, psutil.NoSuchProcess):
        pass


def check_running(process_name, min=1):
    &#34;&#34;&#34;Check if there are a specific number of running processes that match the given name.

    Function will check string against Process.name(), Process.exe() and Process.cmdline().

    Args:
        process_name (str): the target process name
        min (int, optional): min number of instances required to be running. Defaults to 1.

    Returns:
        bool: true if process is running, otherwise False
    &#34;&#34;&#34;
    pids = get_pids(process_name, limit=min)
    return len(pids) == min


def check_process_for_pid(pid, process_name):
    &#34;&#34;&#34;Check whether a given pid actually does belong to a given process name.

    Args:
        pid (int): Process ID
        process (str): String to match againset candidate processes name using equality operator

    Returns:
        bool: True if process_name matched process name of the pid, False otherwise.
    &#34;&#34;&#34;
    try:
        proc = psutil.Process(pid)
        return proc.name() == process_name
    except (psutil.AccessDenied, psutil.NoSuchProcess):
        return False


def set_env_var(var_names, var_values):
    &#34;&#34;&#34;Set the value of the environment variables {varnames}. Existing variable are overwritten

    Such changes to the environment affect subprocesses started with os.system(), popen() or fork() and execv()

    Args:
        var_names (list of str): A list of the names of all the environment variables to set
        varvalues (list of str): A list of all values for the environment variables

    Raises:
        j.exceptions.RuntimeError: if error happened during setting the environment variables
    &#34;&#34;&#34;
    # Note:
    # On some platforms, including FreeBSD and Mac OS X, setting environ may cause memory leaks.
    # https://docs.python.org/3/library/os.html?highlight=os%20environ#os.environ
    # Refer to the system documentation for putenv().
    for i in range(len(var_names)):
        os.environ[var_names[i]] = str(var_values[i]).strip()


def get_pid_by_port(port, ipv6=False, udp=False):
    &#34;&#34;&#34;Returns the PID of the process that is listening on the given port

    Args:
        port (int): Port number to lookup for.
        ipv6 (bool, optional): Whether to search the connections that using ipv6 instead of ipv4. Defaults to False.
        udp (bool, optional): Whether to search the connections for UDP port instead of TCP. Defaults to False.

    Returns:
        int or None: PID for the proceses that listen on that port.
    &#34;&#34;&#34;

    process = get_process_by_port(port, ipv6=ipv6, udp=udp)
    if process:
        return process.pid


def kill_process_by_name(process_name, sig=signal.SIGTERM, match_predicate=None, timeout=5, sure_kill=False):
    &#34;&#34;&#34;Kill all processes that match &#39;process_name&#39;.

    Args:
        process_name (str): The target process name.
        sig (signal, optional): See signal module constants. Defaults to signal.SIGKILL
        match_predicate (callable, optional): Function that does matching between\
            found processes and the targeted process, the function should accept\
            two arguments and return a boolean. Defaults to None.
        timeout (int, optional): How long to wait for a process to terminate (seconds) before raise exception\
            or, if sure_kill=True, send a SIGKILL. Defaults to 5.
        sure_kill (bool, optional): Whether to fallback to SIGKILL if the timeout exceeded for the terminate operation or not. Defaults to False.

    Returns:
        list of int: represents the IDs of the processes remaning alive if any.
    &#34;&#34;&#34;
    pids = get_pids(process_name, match_predicate=match_predicate)
    failed_processes = []
    for pid in pids:
        try:
            kill(pid, sig, timeout=timeout, sure_kill=sure_kill)
        except (j.exceptions.Runtime, j.exceptions.Permission):
            failed_processes.append(pid)
    return failed_processes


def kill_all_pids(pids, sig=signal.SIGTERM, timeout=5, sure_kill=False):
    &#34;&#34;&#34;Kill all processes with given pids.

    Args:
        pids (list of int): The target processes IDs.
        sig (signal, optional): See signal module constants. Defaults to signal.SIGKILL.
        timeout (int, optional): How long to wait for a process to terminate (seconds) before raise exception\
            or, if sure_kill=True, send a SIGKILL. Defaults to 5.
        sure_kill (bool, optional): Whether to fallback to SIGKILL if the timeout exceeded for the terminate operation or not. Defaults to False.


    Returns:
        list of int: represents the IDs of the processes remaning alive if any.
    &#34;&#34;&#34;
    failed_processes = []
    for pid in pids:
        try:
            kill(pid, sig, timeout=timeout, sure_kill=sure_kill)
        except (j.exceptions.Runtime, j.exceptions.Permission):
            failed_processes.append(pid)
    return failed_processes


def kill_process_by_port(port, ipv6=False, udp=False, sig=signal.SIGTERM, timeout=5, sure_kill=False):
    &#34;&#34;&#34;Kill process by port.

    Args:
        port (int): The port number.
        ipv6 (bool, optional): Whether to search the connections that using ipv6 instead of ipv4. Defaults to False.
        udp (bool, optional): Whether to search the connections for UDP port instead of TCP. Defaults to False.
        sig (signal, optional): See signal module constants. Defaults to signal.SIGTERM.
        timeout (int, optional): How long to wait for a process to terminate (seconds) before raise exception
            or, if sure_kill=True, send a SIGKILL. Defaults to 5.
        sure_kill (bool, optional): Whether to fallback to SIGKILL if the timeout exceeded for the terminate operation or not. Defaults to False.

    Raises:
        j.exceptions.Runtime: In case killing the process failed.
        j.exceptions.Permission: In case the permission to perform this action is denied.
    &#34;&#34;&#34;
    proc = get_process_by_port(port, ipv6=ipv6, udp=udp)
    kill(proc, sig=sig, timeout=timeout, sure_kill=sure_kill)


def is_port_listening(port, ipv6=False):
    &#34;&#34;&#34;Check if the TCP port is being used by any process

    Args:
        port (int): Port number
        ipv6 (bool, optional): Whether to ipv6 localhost address instead of ipv4 localhost address. Defaults to False.

    Returns:
        bool: True if port is used, False otherwise.
    &#34;&#34;&#34;
    from jumpscale.sals import nettools

    ip6 = &#34;::&#34;
    ip4 = &#34;0.0.0.0&#34;
    return nettools.tcp_connection_test(ip6 if ipv6 else ip4, port, timeout=5)


def get_process_by_port(port, ipv6=False, udp=False):
    &#34;&#34;&#34;Returns the psutil.Process object that is listening on the given port.

    Args:
        port (int): The port for which to find the process.
        ipv6 (bool, optional): Whether to search the connections that using ipv6 instead of ipv4. Defaults to False.
        udp (bool, optional): Whether to search the connections for UDP port instead of TCP. Defaults to False.

    Raises:
        j.exceptions.Runtime: pid is not retrievable.
        j.exceptions.NotFound: if the process is no longer exists.
        j.exceptions.Permission: if the process is not accessible by the user.

    Returns:
        psutil.Process: process object if found, otherwise None
    &#34;&#34;&#34;
    for conn in psutil.net_connections():  # TODO use kind parameter
        try:
            # should we check against ESTABLISHED status?
            # connection.status For UDP and UNIX sockets this is always going to be psutil.CONN_NONE
            if (
                conn.laddr.port == port
                and conn.status in [&#34;LISTEN&#34;, &#34;NONE&#34;, &#34;ESTABLISHED&#34;]
                and (conn.family.name == &#34;AF_INET6&#34;) == ipv6
                and (conn.type.name == &#34;SOCK_DGRAM&#34;) == udp
            ):
                if conn.pid:
                    return psutil.Process(conn.pid)
                else:
                    raise j.exceptions.Runtime(&#34;pid is not retrievable, not root?&#34;)
        except psutil.NoSuchProcess:
            raise j.exceptions.NotFound(&#34;Process is no longer exists&#34;)
        except psutil.AccessDenied:
            raise j.exceptions.Permission(&#34;Permission denied&#34;)


def get_defunct_processes():
    &#34;&#34;&#34;Gets defunct (zombie) processes.

    Returns:
        list of int: List of processes ID(s).
    &#34;&#34;&#34;
    zombie_pids = []
    for proc in psutil.process_iter():
        try:
            if proc.status() == psutil.STATUS_ZOMBIE:
                zombie_pids.append(proc.pid)
        except (psutil.AccessDenied, psutil.NoSuchProcess):
            pass
    return zombie_pids


def get_processes():
    &#34;&#34;&#34;Get an interator for all running processes

    Yields:
        psutil.Process: for all processes running
    &#34;&#34;&#34;
    yield from psutil.process_iter()


def get_processes_info(user=None, sort=&#34;mem&#34;, filterstr=None, limit=25, desc=True):
    &#34;&#34;&#34;Get information for top running processes sorted by memory usage or CPU usage.

    Args:
        user ([type], optional): filter the processes by username. Defaults to None.
        sort (str, optional): sort processes by resource usage, Defaults to &#39;mem&#39;.
            available option:
                &#39;rss&#39; and its alias &#39;mem&#39;: sort by processes which consumed the most memory (Resident Set Size).
                &#39;cpu_times&#39; and its alias &#39;cpu_time&#39;: sort by processes which consumed the most CPU time.
                &#39;cpu_num&#39;: sort by the CPU number this process is currently running on.
                &#39;cpu_percent&#39;: sort by a float representing the process CPU utilization as a percentage which can also\
                    be &gt; 100.0 in case of a process running multiple threads on different CPUs.
                &#39;memory_percent&#39;: sort py the process memory utilization, the process memory to total physical system memory as a percentage
                &#39;create_time&#39;: the process creation time as a floating point number expressed in seconds since the epoch.
                &#39;gids&#39; and its alias &#39;egid&#39;: the effective group id of this process
                &#39;uids&#39; and its alias &#39;euid&#39;: the effective user id of this process
                &#39;pid&#39;: sort by the process PID.
                &#39;ppid&#39;: sort by the process parent PID
                &#39;name&#39;: sort by the processes name
                &#39;username&#39;: sort by the name of the user that owns the process.
                &#39;status&#39;: sort by the current process status, one of the psutil.STATUS_* constants
        filterstr (str, optional): the string to match against process name or command used and filter the results based on.
        limit (int, optional): limit the results to specific number of processes, to disable set it to -1. Defaults to 25.
        desc (bool, optional): whether to sort the data returned in descending order or not. Defaults to True.

    Returns:
        dict: processes info as a dictionary
            available keys [
                    &#34;cpu_num&#34;,
                    &#34;cpu_percent&#34;,
                    &#34;cpu_times&#34;,
                    &#34;create_time&#34;,
                    &#34;gids&#34;,
                    &#34;memory_percent&#34;,
                    &#34;name&#34;,
                    &#34;pid&#34;,
                    &#34;ppid&#34;,
                    &#34;status&#34;,
                    &#34;uids&#34;,
                    &#34;username&#34;,
                    &#34;rss&#34;,
                    &#34;cpu_time&#34;,
                    &#34;ports&#34;
                ]
    &#34;&#34;&#34;

    def _get_sort_key(procObj):
        if sort == &#34;mem&#34;:
            return procObj[&#34;rss&#34;]
        if sort == &#34;cpu_times&#34;:
            return procObj[&#34;cpu_time&#34;]
        elif sort in [&#34;gids&#34;, &#34;egid&#34;]:
            return procObj[&#34;gids&#34;].effective
        elif sort in [&#34;uids&#34;, &#34;euid&#34;]:
            return procObj[&#34;uids&#34;].effective
        else:
            try:
                return procObj[sort]
            except KeyError:
                j.logger.error(f&#34;bad field name for sorting: {sort}&#34;)
                raise j.exceptions.Value(f&#34;bad field name for sorting: {sort}&#34;)

    processes_list = []
    if not filterstr:
        if user:
            p_source = get_user_processes(user=user)
        else:
            p_source = get_processes()
    else:
        # it makes sense that get_pids func should returns list of psutil.Process objects instead of list of pids
        if user:
            p_source = map(get_process_object, get_pids(process_name=filterstr, _alt_source=get_user_processes(user)))
        else:
            p_source = map(get_process_object, get_pids(process_name=filterstr))
    for proc in p_source:
        if proc:  # in case a race condition happened, and get_process_object returned None
            try:
                # Fetch process details as dict
                pinfo = proc.as_dict(
                    attrs=[
                        &#34;cpu_num&#34;,
                        &#34;cpu_percent&#34;,
                        &#34;cpu_times&#34;,
                        &#34;create_time&#34;,
                        &#34;gids&#34;,
                        &#34;memory_percent&#34;,
                        &#34;name&#34;,
                        &#34;pid&#34;,
                        &#34;ppid&#34;,
                        &#34;status&#34;,
                        &#34;uids&#34;,
                        &#34;username&#34;,
                    ]
                )
                pinfo[&#34;rss&#34;] = proc.memory_info().rss / (
                    1024 * 1024
                )  # the non-swapped physical memory a process has used in Mb
                pinfo[&#34;cpu_time&#34;] = sum(pinfo[&#34;cpu_times&#34;][:2])  # cumulative, excluding children and iowait
                pinfo[&#34;ports&#34;] = []
                try:
                    connections = proc.connections()  # need root
                except (psutil.AccessDenied):
                    pass
                else:
                    if connections:
                        for conn in connections:
                            pinfo[&#34;ports&#34;].append({&#34;port&#34;: conn.laddr.port, &#34;status&#34;: conn.status})
                # Append dict to list
                processes_list.append(pinfo)
            except (psutil.NoSuchProcess, psutil.AccessDenied, psutil.ZombieProcess) as e:
                j.logger.exception(
                    &#34;ignoring and logging an exception that occurred while iterating over system processes, not root?&#34;,
                    exception=e,
                )
                pass
    # sort the processes list by sort_key
    sorted_processes = sorted(processes_list, key=_get_sort_key, reverse=desc)[:limit]
    return sorted_processes


def get_ports_mapping(status=psutil.CONN_LISTEN):
    &#34;&#34;&#34;Get a mapping for process to ports with a status filter

    It will skip any process in case of errors (e.g. permission error)

    Example:
        &gt;&gt;&gt; from jumpscale.loader import j
        &gt;&gt;&gt; import psutil
        &gt;&gt;&gt; j.sals.process.get_ports_mapping(psutil.CONN_ESTABLISHED)
        &gt;&gt;&gt; # or
        &gt;&gt;&gt; j.sals.process.get_ports_mapping(&#34;ESTABLISHED&#34;)

    Args:
        status (psutil.CONN_CONSTANT): `psutil` CONN_* constant as a filter. Defaults to psutil.CONN_LISTEN.

    Returns:
        defaultdict: a mapping between process and ports
    &#34;&#34;&#34;
    ports = defaultdict(list)

    for process in get_processes():
        try:
            connections = process.connections()
        except psutil.Error:
            continue

        if connections:
            for conn in connections:
                if conn.status == status:
                    ports[process].append(conn.laddr.port)

    return ports


def get_memory_usage():
    &#34;&#34;&#34;Get memory status

    Returns:
        dict: Memory status info, available keys (&#39;total&#39;, &#39;used&#39;, &#39;percent&#39;)
            &#39;total&#39;: total physical memory in Gb (exclusive swap).
            &#39;used&#39;: memory used in Gb, calculated differently depending on the platform and designed for informational purposes only.
                total - free does not necessarily match used.
            &#39;percent&#39;: the percentage of used memory.
    &#34;&#34;&#34;
    memory_usage = {}
    memory_data = dict(psutil.virtual_memory()._asdict())
    memory_usage[&#34;total&#34;] = math.ceil(
        memory_data.get(&#34;total&#34;) / (1024 * 1024 * 1024)
    )  # total physical memory (exclusive swap).
    memory_usage[&#34;used&#34;] = math.ceil(memory_data.get(&#34;used&#34;) / (1024 * 1024 * 1024))
    memory_usage[&#34;percent&#34;] = memory_data.get(&#34;percent&#34;)
    return memory_usage


def get_environ(pid):
    &#34;&#34;&#34;Gets env vars for a specific process based on pid

    Args:
        pid (int): process pid

    Raises:
        j.exceptions.NotFound: if the process is no longer exists.
        j.exceptions.Permission: if the process is not accessible by the user.

    Returns:
        dict: dict of env variables
    &#34;&#34;&#34;
    try:
        proc = get_process_object(pid, die=True)
        return proc.environ()
    except psutil.NoSuchProcess:
        raise j.exceptions.NotFound(&#34;Process is no longer exists&#34;)
    except psutil.AccessDenied:
        raise j.exceptions.Permission(&#34;Permission denied&#34;)


def kill_proc_tree(
    parent, sig=signal.SIGTERM, include_parent=True, include_grand_children=True, timeout=5, sure_kill=False
):
    &#34;&#34;&#34;Kill a process and its children (including grandchildren) with signal `sig`

    Args:
        proc (int or psutil.Process): Target process ID (PID) or psutil.Process object.
        sig (signal, optional): See signal module constants. Defaults to signal.SIGTERM.
        include_parent (): Whether to kill the process itself. Defaults to True.
        include_grand_children (): whether to kill recursively all grandchildren. Defaults to True.
        timeout (int, optional): How long to wait for a process to terminate (seconds) before raise exception\
            or, if sure_kill=True, send a SIGKILL. Defaults to 5.
        sure_kill (bool, optional): Whether to fallback to SIGKILL if the timeout exceeded for the terminate operation or not. Defaults to False.

    Returns:
        list of psutil.Process: represents the objects of the processes remaning alive if any.

    Raises:
        AssertionError: in case the given `parent` is the current process
    &#34;&#34;&#34;
    if isinstance(parent, int):
        parent = get_process_object(parent)
        if parent is None:
            return  # already dead

    # should be checked on any killing function
    # here we first need to make sure taht `include_parent` is True
    # and/or better check inside the below for loop
    assert parent.pid != os.getpid(), &#34;won&#39;t kill myself&#34;

    processes = parent.children(recursive=include_grand_children)[::-1]
    failed = []
    if include_parent:
        processes.append(parent)

    for p in processes:
        try:
            kill(p, sig=sig, timeout=timeout, sure_kill=sure_kill)
        except (j.exceptions.Runtime, j.exceptions.Permission):
            failed.append(p)

    # making sure
    if failed:
        gone, failed = psutil.wait_procs(failed, timeout=0)
    return failed


def in_docker():
    &#34;&#34;&#34;will check if we are in a docker.

    Returns:
        bool: True if in docker. False otherwise.
    &#34;&#34;&#34;
    rc, out, _ = j.sals.process.execute(&#34;cat /proc/1/cgroup&#34;, die=False, showout=False)
    return rc == 0 and &#34;/docker/&#34; in out


def in_host():
    &#34;&#34;&#34;Will check if we are in a host.

    Returns:
        bool: True if in host. False otherwise.
    &#34;&#34;&#34;
    return not in_docker()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="jumpscale.sals.process.check_process_for_pid"><code class="name flex">
<span>def <span class="ident">check_process_for_pid</span></span>(<span>pid, process_name)</span>
</code></dt>
<dd>
<section class="desc"><p>Check whether a given pid actually does belong to a given process name.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>pid</code></strong> :&ensp;<code>int</code></dt>
<dd>Process ID</dd>
<dt><strong><code>process</code></strong> :&ensp;<code>str</code></dt>
<dd>String to match againset candidate processes name using equality operator</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>bool</code></strong></dt>
<dd>True if process_name matched process name of the pid, False otherwise.</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def check_process_for_pid(pid, process_name):
    &#34;&#34;&#34;Check whether a given pid actually does belong to a given process name.

    Args:
        pid (int): Process ID
        process (str): String to match againset candidate processes name using equality operator

    Returns:
        bool: True if process_name matched process name of the pid, False otherwise.
    &#34;&#34;&#34;
    try:
        proc = psutil.Process(pid)
        return proc.name() == process_name
    except (psutil.AccessDenied, psutil.NoSuchProcess):
        return False</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.process.check_running"><code class="name flex">
<span>def <span class="ident">check_running</span></span>(<span>process_name, min=1)</span>
</code></dt>
<dd>
<section class="desc"><p>Check if there are a specific number of running processes that match the given name.</p>
<p>Function will check string against Process.name(), Process.exe() and Process.cmdline().</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>process_name</code></strong> :&ensp;<code>str</code></dt>
<dd>the target process name</dd>
<dt><strong><code>min</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>min number of instances required to be running. Defaults to 1.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>bool</code></strong></dt>
<dd>true if process is running, otherwise False</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def check_running(process_name, min=1):
    &#34;&#34;&#34;Check if there are a specific number of running processes that match the given name.

    Function will check string against Process.name(), Process.exe() and Process.cmdline().

    Args:
        process_name (str): the target process name
        min (int, optional): min number of instances required to be running. Defaults to 1.

    Returns:
        bool: true if process is running, otherwise False
    &#34;&#34;&#34;
    pids = get_pids(process_name, limit=min)
    return len(pids) == min</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.process.check_start"><code class="name flex">
<span>def <span class="ident">check_start</span></span>(<span>cmd, filterstr, n_instances=1, retry=1, timeout=2, delay=0.5)</span>
</code></dt>
<dd>
<section class="desc"><p>Run command (possibly multiple times) and check if it is started based on filterstr</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>cmd</code></strong> :&ensp;<code>str</code> or <code>list</code> of <code>str</code></dt>
<dd>Command to be executed.</dd>
<dt><strong><code>filterstr</code></strong> :&ensp;<code>str</code></dt>
<dd>Filter string. will match against against Process.name(), Process.exe() and Process.cmdline()</dd>
<dt><strong><code>n_instances</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Number of needed instances. Defaults to 1.</dd>
<dt><strong><code>retry</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Number of retries to execute the command and check. Defaults to 1.</dd>
<dt><strong><code>timout</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>how long the function should wait for process to finish (first or parnet process started with the command)</dd>
<dt><strong><code>delay</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>how long the function should delay the checking process after the process finished or timeout exceeded (in case the first process started another one).</dd>
</dl>
<h2 id="raises">Raises</h2>
<p>j.exceptions.Runtime: will be raised if we didn't reach number of required instances.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def check_start(cmd, filterstr, n_instances=1, retry=1, timeout=2, delay=0.5):
    &#34;&#34;&#34;Run command (possibly multiple times) and check if it is started based on filterstr

    Args:
        cmd (str or list of str): Command to be executed.
        filterstr (str): Filter string. will match against against Process.name(), Process.exe() and Process.cmdline()
        n_instances (int, optional): Number of needed instances. Defaults to 1.
        retry (int, optional): Number of retries to execute the command and check. Defaults to 1.
        timout (int, optional): how long the function should wait for process to finish (first or parnet process started with the command)
        delay (int, optional): how long the function should delay the checking process after the process finished or timeout exceeded (in case the first process started another one).

    Raises:
        j.exceptions.Runtime: will be raised if we didn&#39;t reach number of required instances.
    &#34;&#34;&#34;
    for i in range(retry):
        if isinstance(cmd, str):
            args = shlex.split(cmd)
        proc = psutil.Popen(args, close_fds=True, stdout=subprocess.PIPE, stdin=subprocess.PIPE, stderr=subprocess.PIPE)
        try:
            rc = proc.wait(timeout)  # makesure the process is stable
            if rc != 0:  # executing the command succeeded but exited immediately!
                output, error_output = proc.communicate()
                j.logger.error(f&#34;the start command exited with error: {error_output}&#34;)  # the process exited with error
        except psutil.TimeoutExpired:
            pass  # still running
        # wait extra delay to allow any subprocess spawned from the process we just started to finish
        # this may not needed in many cases
        time.sleep(delay)
        # TODO check based on command
        if check_running(filterstr, min=n_instances):
            # found at least {n_instances} instances using the filter string {filterstr}
            return
        else:
            # the required number of instances using the filter string {filterstr} not found yet!
            continue
    j.logger.error(f&#34;could not start the required number of instances ({n_instances}) after {i} attempts.&#34;)
    raise j.exceptions.Runtime(&#34;could not start the required number of instances.&#34;)</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.process.check_stop"><code class="name flex">
<span>def <span class="ident">check_stop</span></span>(<span>cmd, filterstr, retry=1, n_instances=0, timeout=2, delay=0.5)</span>
</code></dt>
<dd>
<section class="desc"><p>Executes a stop command (possibly multiple times) and check if it is already stopped based on filterstr</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>cmd</code></strong> :&ensp;<code>str</code></dt>
<dd>Command to be executed.</dd>
<dt><strong><code>filterstr</code></strong> :&ensp;<code>str</code></dt>
<dd>Filter string.</dd>
<dt><strong><code>retry</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Number of retries. Defaults to 1.</dd>
<dt><strong><code>n_inst</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Number of instances after stop. Defaults to 0.</dd>
<dt><strong><code>timout</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>how long the function should wait for process to finish (first or parnet process started with the command)</dd>
<dt><strong><code>delay</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>how long the function should delay the checking process after the process finished or timeout exceeded (in case the first process started another one).</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>j.exceptions.Runtime</code>: <code>if</code> <code>number</code> of <code>instances</code> <code>not</code> <code>matched</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def check_stop(cmd, filterstr, retry=1, n_instances=0, timeout=2, delay=0.5):
    &#34;&#34;&#34;Executes a stop command (possibly multiple times) and check if it is already stopped based on filterstr

    Args:
        cmd (str): Command to be executed.
        filterstr (str): Filter string.
        retry (int, optional): Number of retries. Defaults to 1.
        n_inst (int, optional): Number of instances after stop. Defaults to 0.
        timout (int, optional): how long the function should wait for process to finish (first or parnet process started with the command)
        delay (int, optional): how long the function should delay the checking process after the process finished or timeout exceeded (in case the first process started another one).

    Raises:
        j.exceptions.Runtime: if number of instances not matched
    &#34;&#34;&#34;

    for i in range(retry):
        if isinstance(cmd, str):
            args = shlex.split(cmd)
        proc = psutil.Popen(args, close_fds=True, stdout=subprocess.PIPE, stdin=subprocess.PIPE, stderr=subprocess.PIPE)
        try:
            rc = proc.wait(timeout)  # makesure the process is stable
            # print(f&#39;rc: {rc}&#39;)
            if rc != 0:
                # the process exited with error
                output, error_output = proc.communicate()
                j.logger.warnnig(f&#34;the stop command exited with error: {error_output}&#34;)
        except psutil.TimeoutExpired:
            # still running
            pass
        # wait extra delay to allow any subprocess spawned from the process we just started to finish
        # this may not needed in many cases
        time.sleep(delay)
        found = get_pids(filterstr)
        if len(found) == n_instances:
            # the required {n_instances} matching the instances found using the filter string: {filterstr}
            return
        else:
            # the required {n_instances} not matching the instances number found using the filter string: {filterstr} yet
            continue
    # could not match the required number of instances {n_instances} after {i} attempts.
    raise j.exceptions.Runtime(f&#34;could not stop {cmd}, found {len(found)} of instances instead of {n_instances}&#34;)</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.process.execute"><code class="name flex">
<span>def <span class="ident">execute</span></span>(<span>cmd, showout=False, cwd=None, shell=&#39;/bin/bash&#39;, timeout=600, asynchronous=False, env=None, replace_env=False, die=False)</span>
</code></dt>
<dd>
<section class="desc"><p>Execute a command.</p>
<p>Accepts command as a list too, with auto-escaping.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>cmd</code></strong> :&ensp;<code>str</code> or <code>list</code> of <code>str</code></dt>
<dd>Command to be executed, e.g. "ls -la" or ["ls", "-la"]</dd>
<dt><strong><code>showout</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether to show stdout of the command or not. Defaults to False.</dd>
<dt><strong><code>cwd</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Path to <code>cd</code> into before running command. Defaults to None.</dd>
<dt><strong><code>shell</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Specify a working directory for the command. Defaults to "/bin/bash".</dd>
<dt><strong><code>timeout</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Timeout before kill the process. Defaults to 600.</dd>
<dt><strong><code>asynchronous</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether to execute in asynchronous mode or not. Defaults to False.</dd>
<dt><strong><code>env</code></strong> :&ensp;<code>dict</code>, optional</dt>
<dd>Add environment variables here. Defaults to None.</dd>
<dt><strong><code>replace_env</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether to replace the entire environment with env. Defaults to False.</dd>
<dt><strong><code>die</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether to raise exception if command failed or not. Defaults to False.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>tuple</code></strong></dt>
<dd>tuple[return_code: int, stdout: str, stderr: str]</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def execute(
    cmd,
    showout=False,
    cwd=None,
    shell=&#34;/bin/bash&#34;,
    timeout=600,
    asynchronous=False,
    env=None,
    replace_env=False,
    die=False,
):
    &#34;&#34;&#34;Execute a command.

    Accepts command as a list too, with auto-escaping.

    Args:
        cmd (str or list of str): Command to be executed, e.g. &#34;ls -la&#34; or [&#34;ls&#34;, &#34;-la&#34;]
        showout (bool, optional): Whether to show stdout of the command or not. Defaults to False.
        cwd (str, optional): Path to `cd` into before running command. Defaults to None.
        shell (str, optional): Specify a working directory for the command. Defaults to &#34;/bin/bash&#34;.
        timeout (int, optional): Timeout before kill the process. Defaults to 600.
        asynchronous (bool, optional): Whether to execute in asynchronous mode or not. Defaults to False.
        env (dict, optional): Add environment variables here. Defaults to None.
        replace_env (bool, optional): Whether to replace the entire environment with env. Defaults to False.
        die (bool, optional): Whether to raise exception if command failed or not. Defaults to False.

    Returns:
        tuple: tuple[return_code: int, stdout: str, stderr: str]
    &#34;&#34;&#34;
    return j.core.executors.run_local(
        cmd=cmd,
        hide=not showout,
        cwd=cwd,
        shell=shell,
        timeout=timeout,
        asynchronous=asynchronous,
        env=env or {},
        replace_env=replace_env,
        warn=not die,
    )</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.process.get_defunct_processes"><code class="name flex">
<span>def <span class="ident">get_defunct_processes</span></span>(<span>)</span>
</code></dt>
<dd>
<section class="desc"><p>Gets defunct (zombie) processes.</p>
<h2 id="returns">Returns</h2>
<p>list of int: List of processes ID(s).</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def get_defunct_processes():
    &#34;&#34;&#34;Gets defunct (zombie) processes.

    Returns:
        list of int: List of processes ID(s).
    &#34;&#34;&#34;
    zombie_pids = []
    for proc in psutil.process_iter():
        try:
            if proc.status() == psutil.STATUS_ZOMBIE:
                zombie_pids.append(proc.pid)
        except (psutil.AccessDenied, psutil.NoSuchProcess):
            pass
    return zombie_pids</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.process.get_environ"><code class="name flex">
<span>def <span class="ident">get_environ</span></span>(<span>pid)</span>
</code></dt>
<dd>
<section class="desc"><p>Gets env vars for a specific process based on pid</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>pid</code></strong> :&ensp;<code>int</code></dt>
<dd>process pid</dd>
</dl>
<h2 id="raises">Raises</h2>
<p>j.exceptions.NotFound: if the process is no longer exists.
j.exceptions.Permission: if the process is not accessible by the user.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>dict</code></strong></dt>
<dd>dict of env variables</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def get_environ(pid):
    &#34;&#34;&#34;Gets env vars for a specific process based on pid

    Args:
        pid (int): process pid

    Raises:
        j.exceptions.NotFound: if the process is no longer exists.
        j.exceptions.Permission: if the process is not accessible by the user.

    Returns:
        dict: dict of env variables
    &#34;&#34;&#34;
    try:
        proc = get_process_object(pid, die=True)
        return proc.environ()
    except psutil.NoSuchProcess:
        raise j.exceptions.NotFound(&#34;Process is no longer exists&#34;)
    except psutil.AccessDenied:
        raise j.exceptions.Permission(&#34;Permission denied&#34;)</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.process.get_filtered_pids"><code class="name flex">
<span>def <span class="ident">get_filtered_pids</span></span>(<span>filterstr, excludes=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Get pids filtered by filterstr and excludes, matching against the full command line used to start the process.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>filterstr</code></strong> :&ensp;<code>str</code></dt>
<dd>the String to filter based on.</dd>
<dt><strong><code>excludes</code></strong> :&ensp;<code>list</code>[<code>str</code>]</dt>
<dd>exclude list. Defaults to None.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list</code> of <code>int</code>: <code>List</code> of <code>the</code> <code>processes</code> <code>IDs</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def get_filtered_pids(filterstr, excludes=None):
    &#34;&#34;&#34;Get pids filtered by filterstr and excludes, matching against the full command line used to start the process.

    Args:
        filterstr (str): the String to filter based on.
        excludes (list[str]): exclude list. Defaults to None.

    Returns:
        list of int: List of the processes IDs
    &#34;&#34;&#34;
    pids = []
    for proc in psutil.process_iter([&#34;name&#34;, &#34;cmdline&#34;]):
        cmd_line = &#34; &#34;.join(proc.info[&#34;cmdline&#34;])
        if proc.info[&#34;cmdline&#34;] and filterstr in cmd_line:
            # found filter string: {filterstr} in command line: {cmd_line}
            if excludes:
                for exclude in excludes:
                    if exclude in cmd_line:
                        # we excluded this because it contain exclude string
                        break
                else:  # intended `for/else` meaning for loop finished normally with no break
                    pids.append(proc.pid)  # may yield proc instead
                continue
            else:
                pids.append(proc.pid)  # may yield proc instead
    # if pids is empty root could be needed
    return pids</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.process.get_memory_usage"><code class="name flex">
<span>def <span class="ident">get_memory_usage</span></span>(<span>)</span>
</code></dt>
<dd>
<section class="desc"><p>Get memory status</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>dict</code></strong></dt>
<dd>Memory status info, available keys ('total', 'used', 'percent')
'total': total physical memory in Gb (exclusive swap).
'used': memory used in Gb, calculated differently depending on the platform and designed for informational purposes only.
total - free does not necessarily match used.
'percent': the percentage of used memory.</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def get_memory_usage():
    &#34;&#34;&#34;Get memory status

    Returns:
        dict: Memory status info, available keys (&#39;total&#39;, &#39;used&#39;, &#39;percent&#39;)
            &#39;total&#39;: total physical memory in Gb (exclusive swap).
            &#39;used&#39;: memory used in Gb, calculated differently depending on the platform and designed for informational purposes only.
                total - free does not necessarily match used.
            &#39;percent&#39;: the percentage of used memory.
    &#34;&#34;&#34;
    memory_usage = {}
    memory_data = dict(psutil.virtual_memory()._asdict())
    memory_usage[&#34;total&#34;] = math.ceil(
        memory_data.get(&#34;total&#34;) / (1024 * 1024 * 1024)
    )  # total physical memory (exclusive swap).
    memory_usage[&#34;used&#34;] = math.ceil(memory_data.get(&#34;used&#34;) / (1024 * 1024 * 1024))
    memory_usage[&#34;percent&#34;] = memory_data.get(&#34;percent&#34;)
    return memory_usage</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.process.get_my_process"><code class="name flex">
<span>def <span class="ident">get_my_process</span></span>(<span>)</span>
</code></dt>
<dd>
<section class="desc"><p>Get psutil.Process object of the current process.</p>
<h2 id="returns">Returns</h2>
<p>psutil.Process: Process object of the current process.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def get_my_process():
    &#34;&#34;&#34;Get psutil.Process object of the current process.

    Returns:
        psutil.Process: Process object of the current process.
    &#34;&#34;&#34;
    return get_process_object(os.getpid(), die=True)</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.process.get_pid_by_port"><code class="name flex">
<span>def <span class="ident">get_pid_by_port</span></span>(<span>port, ipv6=False, udp=False)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns the PID of the process that is listening on the given port</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>port</code></strong> :&ensp;<code>int</code></dt>
<dd>Port number to lookup for.</dd>
<dt><strong><code>ipv6</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether to search the connections that using ipv6 instead of ipv4. Defaults to False.</dd>
<dt><strong><code>udp</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether to search the connections for UDP port instead of TCP. Defaults to False.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>int or None: PID for the proceses that listen on that port.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def get_pid_by_port(port, ipv6=False, udp=False):
    &#34;&#34;&#34;Returns the PID of the process that is listening on the given port

    Args:
        port (int): Port number to lookup for.
        ipv6 (bool, optional): Whether to search the connections that using ipv6 instead of ipv4. Defaults to False.
        udp (bool, optional): Whether to search the connections for UDP port instead of TCP. Defaults to False.

    Returns:
        int or None: PID for the proceses that listen on that port.
    &#34;&#34;&#34;

    process = get_process_by_port(port, ipv6=ipv6, udp=udp)
    if process:
        return process.pid</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.process.get_pids"><code class="name flex">
<span>def <span class="ident">get_pids</span></span>(<span>process_name, match_predicate=None, limit=0, include_zombie=False, full_cmd_line=False)</span>
</code></dt>
<dd>
<section class="desc"><p>Return a list of processes ID(s) matching a given process name.</p>
<p>Function will check string against Process.name(), Process.exe() and Process.cmdline()</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>process_name</code></strong> :&ensp;<code>str</code></dt>
<dd>The target process name</dd>
<dt><strong><code>match_predicate</code></strong> :&ensp;<code>callable</code>, optional</dt>
<dd>Function that does matching between found processes and the targeted process.
the function should accept two arguments and return a boolean. Defaults to None.</dd>
<dt><strong><code>limit</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>If not equal to 0, function will return as fast as the number of PID(s) found become equal to <code>limit</code> value.</dd>
<dt>_alt_source(callable or iterable, optional): Can be used to specify an alternative source of the psutil.Process objects to match against.</dt>
<dt>ex: get_user_processes func, or get_similar_processes.</dt>
<dt>if not specified, psutil.process_iter will be used. Defaults to None.</dt>
<dt><strong><code>include_zombie</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether to include pid for zombie proccesses or not. Defaults to False.</dd>
<dt><strong><code>full_cmd_line</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>The pattern is normally only matched against the process name.
if full_cmd_line is set to True, the full command line is used. Defaults to False.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>list of int: List of the processes IDs.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def get_pids(process_name, match_predicate=None, limit=0, _alt_source=None, include_zombie=False, full_cmd_line=False):
    &#34;&#34;&#34;Return a list of processes ID(s) matching a given process name.

    Function will check string against Process.name(), Process.exe() and Process.cmdline()

    Args:
        process_name (str): The target process name
        match_predicate (callable, optional): Function that does matching between found processes and the targeted process.
            the function should accept two arguments and return a boolean. Defaults to None.
        limit (int, optional): If not equal to 0, function will return as fast as the number of PID(s) found become equal to `limit` value.
        _alt_source(callable or iterable, optional): Can be used to specify an alternative source of the psutil.Process objects to match against.
            ex: get_user_processes func, or get_similar_processes.
            if not specified, psutil.process_iter will be used. Defaults to None.
        include_zombie (bool, optional): Whether to include pid for zombie proccesses or not. Defaults to False.
        full_cmd_line (bool, optional): The pattern is normally only matched against the process name.
            if full_cmd_line is set to True, the full command line is used. Defaults to False.

    Returns:
        list of int: List of the processes IDs.
    &#34;&#34;&#34;
    # default match predicate
    def default_predicate(target, given):
        if isinstance(given, list):
            return target in given
        else:
            return target.strip().lower() == given.lower()

    default_processes_source = psutil.process_iter([&#34;name&#34;, &#34;exe&#34;, &#34;cmdline&#34;])

    match_predicate = match_predicate or default_predicate
    p_source = _alt_source or default_processes_source

    pids = []
    for proc in p_source:
        try:
            if not include_zombie and proc.status() == psutil.STATUS_ZOMBIE:
                # {proc.pid} is a zombie process, ignoring it
                continue

            candidates = [proc.info[&#34;name&#34;]]
            if proc.info[&#34;exe&#34;]:
                candidates.append(os.path.basename(proc.info[&#34;exe&#34;]))
            if proc.info[&#34;cmdline&#34;]:
                if full_cmd_line:
                    candidates.append(proc.info[&#34;cmdline&#34;])
                else:
                    candidates.append(os.path.basename(proc.info[&#34;cmdline&#34;][0]))

            if any([match_predicate(process_name, candidate) for candidate in candidates]):
                pids.append(proc.pid)
                # return early if no need to iterate over all running process
                if limit and len(pids) == limit:
                    return pids
        except psutil.Error:
            pass
    return pids</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.process.get_pids_filtered_by_regex"><code class="name flex">
<span>def <span class="ident">get_pids_filtered_by_regex</span></span>(<span>regex_list)</span>
</code></dt>
<dd>
<section class="desc"><p>Get pids of a process filtered by Regex list, matching against the full command line used to start the process.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>regex_list</code></strong> :&ensp;<code>list</code>[<code>str</code>]</dt>
<dd>List of regex expressions.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>list of int: List of the processes IDs.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def get_pids_filtered_by_regex(regex_list):
    &#34;&#34;&#34;Get pids of a process filtered by Regex list, matching against the full command line used to start the process.

    Args:
        regex_list (list[str]): List of regex expressions.

    Returns:
        list of int: List of the processes IDs.
    &#34;&#34;&#34;
    res = []
    for process in psutil.process_iter(attrs=[&#34;cmdline&#34;]):
        if process.info[&#34;cmdline&#34;]:
            cmdline = &#34; &#34;.join(process.info[&#34;cmdline&#34;])
            for r in regex_list:
                if re.match(r, cmdline):
                    res.append(process.pid)
    return res</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.process.get_pids_filtered_sorted"><code class="name flex">
<span>def <span class="ident">get_pids_filtered_sorted</span></span>(<span>filterstr, sortkey=None, desc=False)</span>
</code></dt>
<dd>
<section class="desc"><p>Get pids of process by a filter string and optionally sort by sortkey</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>filterstr</code></strong> :&ensp;<code>str</code></dt>
<dd>filter string.</dd>
<dt><strong><code>sortkey</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Defaults to None. (if no sortkey used it will sort by pid(s) in ascending order).
sortkey can be one of the following:
%cpu
cpu utilization of the process in
%mem
ratio of the process's resident set size
to the physical memory on the machine, expressed as a percentage.
cputime
cumulative CPU time, "[DD-]hh:mm:ss" format.
(alias time).
egid
effective group ID number of the process as a decimal integer.
(alias gid).
egroup
effective group ID of the process. This will be the textual group ID, if it can be obtained and the field width permits, or a decimal representation otherwise.
(alias group).
euid
effective user ID (alias uid).
euser
effective user name.
gid
see egid. (alias egid).
pid
a number representing the process ID (alias tgid).
ppid
parent process ID.
psr
processor that process is currently assigned to.
start_time
starting time or date of the process.</dd>
<dt><strong><code>desc</code></strong></dt>
<dd>(bool, optional): Whether to sort the processes in descending order or not(asc). Defaults to False (asc).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list</code> of <code>int</code>: <code>list</code> of <code>the</code> <code>processes</code> <code>IDs</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def get_pids_filtered_sorted(filterstr, sortkey=None, desc=False):
    &#34;&#34;&#34;Get pids of process by a filter string and optionally sort by sortkey

    Args:
        filterstr (str): filter string.
        sortkey (str, optional): Defaults to None. (if no sortkey used it will sort by pid(s) in ascending order).
            sortkey can be one of the following:
            %cpu           cpu utilization of the process in
            %mem           ratio of the process&#39;s resident set size  to the physical memory on the machine, expressed as a percentage.
            cputime        cumulative CPU time, &#34;[DD-]hh:mm:ss&#34; format.  (alias time).
            egid           effective group ID number of the process as a decimal integer.  (alias gid).
            egroup         effective group ID of the process. This will be the textual group ID, if it can be obtained and the field width permits, or a decimal representation otherwise.  (alias group).
            euid           effective user ID (alias uid).
            euser          effective user name.
            gid            see egid. (alias egid).
            pid            a number representing the process ID (alias tgid).
            ppid           parent process ID.
            psr            processor that process is currently assigned to.
            start_time     starting time or date of the process.
        desc: (bool, optional): Whether to sort the processes in descending order or not(asc). Defaults to False (asc).

    Returns:
        list of int: list of the processes IDs
    &#34;&#34;&#34;
    ps_to_psutil_map = {
        &#34;%cpu&#34;: &#34;cpu_percent&#34;,
        &#34;%mem&#34;: &#34;memory_percent&#34;,
        &#34;cputime&#34;: &#34;cpu_time&#34;,
        &#34;psr&#34;: &#34;cpu_num&#34;,
        &#34;start_time&#34;: &#34;create_time&#34;,
        &#34;egid&#34;: &#34;egid&#34;,
        &#34;gid&#34;: &#34;egid&#34;,
        &#34;euid&#34;: &#34;euid&#34;,
        &#34;uid&#34;: &#34;euid&#34;,
        &#34;euser&#34;: &#34;username&#34;,
        &#34;pid&#34;: &#34;pid&#34;,
        &#34;ppid&#34;: &#34;ppid&#34;,
    }
    if sortkey is None:  # mimic default ps commnad sorting behavior
        sortkey = &#34;pid&#34;
    # return pids from process objects
    return [p[&#34;pid&#34;] for p in get_processes_info(sort=ps_to_psutil_map[sortkey], filterstr=filterstr, desc=desc)]</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.process.get_ports_mapping"><code class="name flex">
<span>def <span class="ident">get_ports_mapping</span></span>(<span>status=&#39;LISTEN&#39;)</span>
</code></dt>
<dd>
<section class="desc"><p>Get a mapping for process to ports with a status filter</p>
<p>It will skip any process in case of errors (e.g. permission error)</p>
<h2 id="example">Example</h2>
<pre><code>&gt;&gt;&gt; from jumpscale.loader import j
&gt;&gt;&gt; import psutil
&gt;&gt;&gt; j.sals.process.get_ports_mapping(psutil.CONN_ESTABLISHED)
&gt;&gt;&gt; # or
&gt;&gt;&gt; j.sals.process.get_ports_mapping("ESTABLISHED")
</code></pre>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>status</code></strong> :&ensp;<code>psutil.CONN_CONSTANT</code></dt>
<dd><code>psutil</code> CONN_* constant as a filter. Defaults to psutil.CONN_LISTEN.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>defaultdict</code></strong></dt>
<dd>a mapping between process and ports</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def get_ports_mapping(status=psutil.CONN_LISTEN):
    &#34;&#34;&#34;Get a mapping for process to ports with a status filter

    It will skip any process in case of errors (e.g. permission error)

    Example:
        &gt;&gt;&gt; from jumpscale.loader import j
        &gt;&gt;&gt; import psutil
        &gt;&gt;&gt; j.sals.process.get_ports_mapping(psutil.CONN_ESTABLISHED)
        &gt;&gt;&gt; # or
        &gt;&gt;&gt; j.sals.process.get_ports_mapping(&#34;ESTABLISHED&#34;)

    Args:
        status (psutil.CONN_CONSTANT): `psutil` CONN_* constant as a filter. Defaults to psutil.CONN_LISTEN.

    Returns:
        defaultdict: a mapping between process and ports
    &#34;&#34;&#34;
    ports = defaultdict(list)

    for process in get_processes():
        try:
            connections = process.connections()
        except psutil.Error:
            continue

        if connections:
            for conn in connections:
                if conn.status == status:
                    ports[process].append(conn.laddr.port)

    return ports</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.process.get_process_by_port"><code class="name flex">
<span>def <span class="ident">get_process_by_port</span></span>(<span>port, ipv6=False, udp=False)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns the psutil.Process object that is listening on the given port.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>port</code></strong> :&ensp;<code>int</code></dt>
<dd>The port for which to find the process.</dd>
<dt><strong><code>ipv6</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether to search the connections that using ipv6 instead of ipv4. Defaults to False.</dd>
<dt><strong><code>udp</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether to search the connections for UDP port instead of TCP. Defaults to False.</dd>
</dl>
<h2 id="raises">Raises</h2>
<p>j.exceptions.Runtime: pid is not retrievable.
j.exceptions.NotFound: if the process is no longer exists.
j.exceptions.Permission: if the process is not accessible by the user.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>psutil.Process</code>: <code>process</code> <code>object</code> <code>if</code> <code>found</code>, <code>otherwise</code> <code>None</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def get_process_by_port(port, ipv6=False, udp=False):
    &#34;&#34;&#34;Returns the psutil.Process object that is listening on the given port.

    Args:
        port (int): The port for which to find the process.
        ipv6 (bool, optional): Whether to search the connections that using ipv6 instead of ipv4. Defaults to False.
        udp (bool, optional): Whether to search the connections for UDP port instead of TCP. Defaults to False.

    Raises:
        j.exceptions.Runtime: pid is not retrievable.
        j.exceptions.NotFound: if the process is no longer exists.
        j.exceptions.Permission: if the process is not accessible by the user.

    Returns:
        psutil.Process: process object if found, otherwise None
    &#34;&#34;&#34;
    for conn in psutil.net_connections():  # TODO use kind parameter
        try:
            # should we check against ESTABLISHED status?
            # connection.status For UDP and UNIX sockets this is always going to be psutil.CONN_NONE
            if (
                conn.laddr.port == port
                and conn.status in [&#34;LISTEN&#34;, &#34;NONE&#34;, &#34;ESTABLISHED&#34;]
                and (conn.family.name == &#34;AF_INET6&#34;) == ipv6
                and (conn.type.name == &#34;SOCK_DGRAM&#34;) == udp
            ):
                if conn.pid:
                    return psutil.Process(conn.pid)
                else:
                    raise j.exceptions.Runtime(&#34;pid is not retrievable, not root?&#34;)
        except psutil.NoSuchProcess:
            raise j.exceptions.NotFound(&#34;Process is no longer exists&#34;)
        except psutil.AccessDenied:
            raise j.exceptions.Permission(&#34;Permission denied&#34;)</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.process.get_process_object"><code class="name flex">
<span>def <span class="ident">get_process_object</span></span>(<span>pid, die=False)</span>
</code></dt>
<dd>
<section class="desc"><p>Get psutil.Process object of a given process ID (PID).</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>pid</code></strong> :&ensp;<code>int</code></dt>
<dd>Process ID (PID) to get</dd>
<dt><strong><code>die</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether to raise an exception if no process with the given PID is found in the
current process list or not. Defaults to False.</dd>
</dl>
<h2 id="raises">Raises</h2>
<p>psutil.NoSuchProcess: If process with the given PID is not found and die set to True.
psutil.AccessDenied: If permission denied.</p>
<h2 id="returns">Returns</h2>
<p>psutil.Process or None: The Process object of the given PID if found, otherwise None, if die set to False.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def get_process_object(pid, die=False):
    &#34;&#34;&#34;Get psutil.Process object of a given process ID (PID).

    Args:
        pid (int): Process ID (PID) to get
        die (bool, optional): Whether to raise an exception if no process with the given PID is found in the
            current process list or not. Defaults to False.

    Raises:
        psutil.NoSuchProcess: If process with the given PID is not found and die set to True.
        psutil.AccessDenied: If permission denied.

    Returns:
        psutil.Process or None: The Process object of the given PID if found, otherwise None, if die set to False.
    &#34;&#34;&#34;
    try:
        return psutil.Process(pid)
    except (psutil.AccessDenied, psutil.NoSuchProcess) as e:
        # when you query processess owned by another user, especially on macOS and Windows you may get AccessDenied exception
        if die:
            raise e
        else:
            return None</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.process.get_processes"><code class="name flex">
<span>def <span class="ident">get_processes</span></span>(<span>)</span>
</code></dt>
<dd>
<section class="desc"><p>Get an interator for all running processes</p>
<h2 id="yields">Yields</h2>
<dl>
<dt><code>psutil.Process</code>: <code>for</code> <code>all</code> <code>processes</code> <code>running</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def get_processes():
    &#34;&#34;&#34;Get an interator for all running processes

    Yields:
        psutil.Process: for all processes running
    &#34;&#34;&#34;
    yield from psutil.process_iter()</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.process.get_processes_info"><code class="name flex">
<span>def <span class="ident">get_processes_info</span></span>(<span>user=None, sort=&#39;mem&#39;, filterstr=None, limit=25, desc=True)</span>
</code></dt>
<dd>
<section class="desc"><p>Get information for top running processes sorted by memory usage or CPU usage.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>user</code></strong> :&ensp;[<code>type</code>], optional</dt>
<dd>filter the processes by username. Defaults to None.</dd>
<dt><strong><code>sort</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>sort processes by resource usage, Defaults to 'mem'.
available option:
'rss' and its alias 'mem': sort by processes which consumed the most memory (Resident Set Size).
'cpu_times' and its alias 'cpu_time': sort by processes which consumed the most CPU time.
'cpu_num': sort by the CPU number this process is currently running on.
'cpu_percent': sort by a float representing the process CPU utilization as a percentage which can also
be &gt; 100.0 in case of a process running multiple threads on different CPUs.
'memory_percent': sort py the process memory utilization, the process memory to total physical system memory as a percentage
'create_time': the process creation time as a floating point number expressed in seconds since the epoch.
'gids' and its alias 'egid': the effective group id of this process
'uids' and its alias 'euid': the effective user id of this process
'pid': sort by the process PID.
'ppid': sort by the process parent PID
'name': sort by the processes name
'username': sort by the name of the user that owns the process.
'status': sort by the current process status, one of the psutil.STATUS_* constants</dd>
<dt><strong><code>filterstr</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>the string to match against process name or command used and filter the results based on.</dd>
<dt><strong><code>limit</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>limit the results to specific number of processes, to disable set it to -1. Defaults to 25.</dd>
<dt><strong><code>desc</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>whether to sort the data returned in descending order or not. Defaults to True.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>dict</code></strong></dt>
<dd>processes info as a dictionary
available keys [
"cpu_num",
"cpu_percent",
"cpu_times",
"create_time",
"gids",
"memory_percent",
"name",
"pid",
"ppid",
"status",
"uids",
"username",
"rss",
"cpu_time",
"ports"
]</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def get_processes_info(user=None, sort=&#34;mem&#34;, filterstr=None, limit=25, desc=True):
    &#34;&#34;&#34;Get information for top running processes sorted by memory usage or CPU usage.

    Args:
        user ([type], optional): filter the processes by username. Defaults to None.
        sort (str, optional): sort processes by resource usage, Defaults to &#39;mem&#39;.
            available option:
                &#39;rss&#39; and its alias &#39;mem&#39;: sort by processes which consumed the most memory (Resident Set Size).
                &#39;cpu_times&#39; and its alias &#39;cpu_time&#39;: sort by processes which consumed the most CPU time.
                &#39;cpu_num&#39;: sort by the CPU number this process is currently running on.
                &#39;cpu_percent&#39;: sort by a float representing the process CPU utilization as a percentage which can also\
                    be &gt; 100.0 in case of a process running multiple threads on different CPUs.
                &#39;memory_percent&#39;: sort py the process memory utilization, the process memory to total physical system memory as a percentage
                &#39;create_time&#39;: the process creation time as a floating point number expressed in seconds since the epoch.
                &#39;gids&#39; and its alias &#39;egid&#39;: the effective group id of this process
                &#39;uids&#39; and its alias &#39;euid&#39;: the effective user id of this process
                &#39;pid&#39;: sort by the process PID.
                &#39;ppid&#39;: sort by the process parent PID
                &#39;name&#39;: sort by the processes name
                &#39;username&#39;: sort by the name of the user that owns the process.
                &#39;status&#39;: sort by the current process status, one of the psutil.STATUS_* constants
        filterstr (str, optional): the string to match against process name or command used and filter the results based on.
        limit (int, optional): limit the results to specific number of processes, to disable set it to -1. Defaults to 25.
        desc (bool, optional): whether to sort the data returned in descending order or not. Defaults to True.

    Returns:
        dict: processes info as a dictionary
            available keys [
                    &#34;cpu_num&#34;,
                    &#34;cpu_percent&#34;,
                    &#34;cpu_times&#34;,
                    &#34;create_time&#34;,
                    &#34;gids&#34;,
                    &#34;memory_percent&#34;,
                    &#34;name&#34;,
                    &#34;pid&#34;,
                    &#34;ppid&#34;,
                    &#34;status&#34;,
                    &#34;uids&#34;,
                    &#34;username&#34;,
                    &#34;rss&#34;,
                    &#34;cpu_time&#34;,
                    &#34;ports&#34;
                ]
    &#34;&#34;&#34;

    def _get_sort_key(procObj):
        if sort == &#34;mem&#34;:
            return procObj[&#34;rss&#34;]
        if sort == &#34;cpu_times&#34;:
            return procObj[&#34;cpu_time&#34;]
        elif sort in [&#34;gids&#34;, &#34;egid&#34;]:
            return procObj[&#34;gids&#34;].effective
        elif sort in [&#34;uids&#34;, &#34;euid&#34;]:
            return procObj[&#34;uids&#34;].effective
        else:
            try:
                return procObj[sort]
            except KeyError:
                j.logger.error(f&#34;bad field name for sorting: {sort}&#34;)
                raise j.exceptions.Value(f&#34;bad field name for sorting: {sort}&#34;)

    processes_list = []
    if not filterstr:
        if user:
            p_source = get_user_processes(user=user)
        else:
            p_source = get_processes()
    else:
        # it makes sense that get_pids func should returns list of psutil.Process objects instead of list of pids
        if user:
            p_source = map(get_process_object, get_pids(process_name=filterstr, _alt_source=get_user_processes(user)))
        else:
            p_source = map(get_process_object, get_pids(process_name=filterstr))
    for proc in p_source:
        if proc:  # in case a race condition happened, and get_process_object returned None
            try:
                # Fetch process details as dict
                pinfo = proc.as_dict(
                    attrs=[
                        &#34;cpu_num&#34;,
                        &#34;cpu_percent&#34;,
                        &#34;cpu_times&#34;,
                        &#34;create_time&#34;,
                        &#34;gids&#34;,
                        &#34;memory_percent&#34;,
                        &#34;name&#34;,
                        &#34;pid&#34;,
                        &#34;ppid&#34;,
                        &#34;status&#34;,
                        &#34;uids&#34;,
                        &#34;username&#34;,
                    ]
                )
                pinfo[&#34;rss&#34;] = proc.memory_info().rss / (
                    1024 * 1024
                )  # the non-swapped physical memory a process has used in Mb
                pinfo[&#34;cpu_time&#34;] = sum(pinfo[&#34;cpu_times&#34;][:2])  # cumulative, excluding children and iowait
                pinfo[&#34;ports&#34;] = []
                try:
                    connections = proc.connections()  # need root
                except (psutil.AccessDenied):
                    pass
                else:
                    if connections:
                        for conn in connections:
                            pinfo[&#34;ports&#34;].append({&#34;port&#34;: conn.laddr.port, &#34;status&#34;: conn.status})
                # Append dict to list
                processes_list.append(pinfo)
            except (psutil.NoSuchProcess, psutil.AccessDenied, psutil.ZombieProcess) as e:
                j.logger.exception(
                    &#34;ignoring and logging an exception that occurred while iterating over system processes, not root?&#34;,
                    exception=e,
                )
                pass
    # sort the processes list by sort_key
    sorted_processes = sorted(processes_list, key=_get_sort_key, reverse=desc)[:limit]
    return sorted_processes</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.process.get_similar_processes"><code class="name flex">
<span>def <span class="ident">get_similar_processes</span></span>(<span>target_proc=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Gets similar processes to current process, started with same command line and same options.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>target_proc</code></strong> :&ensp;<code>int</code> or <code>psutil.Process</code>, optional</dt>
<dd>pid, or psutil.Process object.
if None then pid for current process will be used. Defaults to None.</dd>
</dl>
<h2 id="yields">Yields</h2>
<p>psutil.Process: psutil.Process object for all processes similar to a given process.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def get_similar_processes(target_proc=None):
    &#34;&#34;&#34;Gets similar processes to current process, started with same command line and same options.

    Args:
        target_proc (int or psutil.Process, optional): pid, or psutil.Process object.
            if None then pid for current process will be used. Defaults to None.

    Yields:
        psutil.Process: psutil.Process object for all processes similar to a given process.
    &#34;&#34;&#34;
    try:
        if target_proc is None:
            target_proc = get_my_process()
        elif isinstance(target_proc, int):
            target_proc = get_process_object(target_proc, die=True)
        for proc in psutil.process_iter([&#34;name&#34;, &#34;exe&#34;, &#34;cmdline&#34;]):
            if proc.info[&#34;cmdline&#34;] and target_proc.cmdline() and proc.info[&#34;cmdline&#34;] == target_proc.cmdline():
                yield proc
    except (psutil.AccessDenied, psutil.NoSuchProcess):
        pass</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.process.get_user_processes"><code class="name flex">
<span>def <span class="ident">get_user_processes</span></span>(<span>user)</span>
</code></dt>
<dd>
<section class="desc"><p>Get all process for a specific user.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>user</code></strong> :&ensp;<code>str</code></dt>
<dd>The user name to match against.</dd>
</dl>
<h2 id="yields">Yields</h2>
<p>psutil.Process: process object for all processes owned by <code>user</code>.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def get_user_processes(user):
    &#34;&#34;&#34;Get all process for a specific user.

    Args:
        user (str): The user name to match against.

    Yields:
        psutil.Process: process object for all processes owned by `user`.
    &#34;&#34;&#34;
    try:
        for process in psutil.process_iter([&#34;name&#34;, &#34;exe&#34;, &#34;cmdline&#34;]):
            if process.username() == user:
                yield process
    except (psutil.AccessDenied, psutil.NoSuchProcess):
        pass</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.process.in_docker"><code class="name flex">
<span>def <span class="ident">in_docker</span></span>(<span>)</span>
</code></dt>
<dd>
<section class="desc"><p>will check if we are in a docker.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>bool</code></strong></dt>
<dd>True if in docker. False otherwise.</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def in_docker():
    &#34;&#34;&#34;will check if we are in a docker.

    Returns:
        bool: True if in docker. False otherwise.
    &#34;&#34;&#34;
    rc, out, _ = j.sals.process.execute(&#34;cat /proc/1/cgroup&#34;, die=False, showout=False)
    return rc == 0 and &#34;/docker/&#34; in out</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.process.in_host"><code class="name flex">
<span>def <span class="ident">in_host</span></span>(<span>)</span>
</code></dt>
<dd>
<section class="desc"><p>Will check if we are in a host.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>bool</code></strong></dt>
<dd>True if in host. False otherwise.</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def in_host():
    &#34;&#34;&#34;Will check if we are in a host.

    Returns:
        bool: True if in host. False otherwise.
    &#34;&#34;&#34;
    return not in_docker()</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.process.is_alive"><code class="name flex">
<span>def <span class="ident">is_alive</span></span>(<span>pid)</span>
</code></dt>
<dd>
<section class="desc"><p>Check whether the given PID exists in the current process list.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>pid</code></strong> :&ensp;<code>int</code></dt>
<dd>Process ID (PID) to be checked.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>bool</code></strong></dt>
<dd>True if the given PID exists in the current process list, False otherwise.</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def is_alive(pid):
    &#34;&#34;&#34;Check whether the given PID exists in the current process list.

    Args:
        pid (int): Process ID (PID) to be checked.

    Returns:
        bool: True if the given PID exists in the current process list, False otherwise.
    &#34;&#34;&#34;
    return psutil.pid_exists(pid)</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.process.is_installed"><code class="name flex">
<span>def <span class="ident">is_installed</span></span>(<span>cmd)</span>
</code></dt>
<dd>
<section class="desc"><p>Checks if a specific command is available on system e.g. curl.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>cmd</code></strong> :&ensp;<code>str</code></dt>
<dd>Command to be checked.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>bool</code></strong></dt>
<dd>True if command is available, False otherwise.</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def is_installed(cmd):
    &#34;&#34;&#34;Checks if a specific command is available on system e.g. curl.

    Args:
        cmd (str): Command to be checked.

    Returns:
        bool: True if command is available, False otherwise.
    &#34;&#34;&#34;
    rc, _, _ = execute(f&#34;which {cmd}&#34;, die=False)
    return rc == 0</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.process.is_port_listening"><code class="name flex">
<span>def <span class="ident">is_port_listening</span></span>(<span>port, ipv6=False)</span>
</code></dt>
<dd>
<section class="desc"><p>Check if the TCP port is being used by any process</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>port</code></strong> :&ensp;<code>int</code></dt>
<dd>Port number</dd>
<dt><strong><code>ipv6</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether to ipv6 localhost address instead of ipv4 localhost address. Defaults to False.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>bool</code></strong></dt>
<dd>True if port is used, False otherwise.</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def is_port_listening(port, ipv6=False):
    &#34;&#34;&#34;Check if the TCP port is being used by any process

    Args:
        port (int): Port number
        ipv6 (bool, optional): Whether to ipv6 localhost address instead of ipv4 localhost address. Defaults to False.

    Returns:
        bool: True if port is used, False otherwise.
    &#34;&#34;&#34;
    from jumpscale.sals import nettools

    ip6 = &#34;::&#34;
    ip4 = &#34;0.0.0.0&#34;
    return nettools.tcp_connection_test(ip6 if ipv6 else ip4, port, timeout=5)</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.process.kill"><code class="name flex">
<span>def <span class="ident">kill</span></span>(<span>proc, sig=&lt;Signals.SIGTERM: 15&gt;, timeout=5, sure_kill=False)</span>
</code></dt>
<dd>
<section class="desc"><p>Kill a process with a specified signal.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>proc</code></strong> :&ensp;<code>int</code> or <code>psutil.Process</code></dt>
<dd>Target process ID (PID) or psutil.Process object.</dd>
<dt><strong><code>sig</code></strong> :&ensp;<code>signal</code>, optional</dt>
<dd>See signal module constants. Defaults to signal.SIGTERM.</dd>
<dt><strong><code>timeout</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>How long to wait for a process to terminate (seconds) before raise exception
or, if sure_kill=True, send a SIGKILL. Defaults to 5.</dd>
<dt><strong><code>sure_kill</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether to fallback to SIGKILL if the timeout exceeded for the terminate operation or not. Defaults to False.</dd>
</dl>
<h2 id="raises">Raises</h2>
<p>j.exceptions.Runtime: In case killing the process failed.
j.exceptions.Permission: In case the permission to perform this action is denied.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def kill(proc, sig=signal.SIGTERM, timeout=5, sure_kill=False):
    &#34;&#34;&#34;Kill a process with a specified signal.

    Args:
        proc (int or psutil.Process): Target process ID (PID) or psutil.Process object.
        sig (signal, optional): See signal module constants. Defaults to signal.SIGTERM.
        timeout (int, optional): How long to wait for a process to terminate (seconds) before raise exception
            or, if sure_kill=True, send a SIGKILL. Defaults to 5.
        sure_kill (bool, optional): Whether to fallback to SIGKILL if the timeout exceeded for the terminate operation or not. Defaults to False.

    Raises:
        j.exceptions.Runtime: In case killing the process failed.
        j.exceptions.Permission: In case the permission to perform this action is denied.
    &#34;&#34;&#34;
    try:
        if isinstance(proc, int):
            proc = get_process_object(proc, die=True)
        if proc.status() == psutil.STATUS_ZOMBIE:
            return
        proc.send_signal(sig)
        # Wait for a process to terminate
        # If PID no longer exists return None immediately
        # If timeout exceeded and the process is still alive raise TimeoutExpired exception
        proc.wait(timeout=timeout)
        # the process with PID {proc.pid} was terminated with sig {sig}
    except psutil.TimeoutExpired as e:
        # timeout expires and process is still alive.
        if sure_kill and sig != signal.SIGKILL and os.name != &#34;nt&#34;:
            # SIGKILL not supported in windows
            # If a process gets this signal it must quit immediately and will not perform any clean-up operations
            proc.kill()
            # SIGKILL signal sent
            try:
                proc.wait(1)
                # the process with PID {proc.pid} was terminated with sig {signal.SIGKILL}
            except psutil.TimeoutExpired as e:
                if proc.status() == psutil.STATUS_ZOMBIE:
                    # the process with PID: {proc.pid} becomes a zombie and should be considered a dead.
                    return
                # the process may be in an uninterruptible sleep
                j.logger.warning(f&#34;Could not kill the process with pid: {proc.pid} with {sig}. Timeout: {timeout}&#34;)
                raise j.exceptions.Runtime(f&#34;Could not kill process with pid {proc.pid}, {proc.status()}&#34;) from e
        else:
            raise j.exceptions.Runtime(f&#34;Could not kill process with pid {proc.pid}&#34;) from e
    except psutil.AccessDenied as e:
        # permission to perform an action is denied
        raise j.exceptions.Permission(&#34;Permission to perform this action is denied!&#34;) from e
    except psutil.NoSuchProcess:
        # Process no longer exists or Zombie (already dead)
        pass</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.process.kill_all_pids"><code class="name flex">
<span>def <span class="ident">kill_all_pids</span></span>(<span>pids, sig=&lt;Signals.SIGTERM: 15&gt;, timeout=5, sure_kill=False)</span>
</code></dt>
<dd>
<section class="desc"><p>Kill all processes with given pids.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>pids</code></strong> :&ensp;<code>list</code> of <code>int</code></dt>
<dd>The target processes IDs.</dd>
<dt><strong><code>sig</code></strong> :&ensp;<code>signal</code>, optional</dt>
<dd>See signal module constants. Defaults to signal.SIGKILL.</dd>
<dt><strong><code>timeout</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>How long to wait for a process to terminate (seconds) before raise exception
or, if sure_kill=True, send a SIGKILL. Defaults to 5.</dd>
<dt><strong><code>sure_kill</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether to fallback to SIGKILL if the timeout exceeded for the terminate operation or not. Defaults to False.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>list of int: represents the IDs of the processes remaning alive if any.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def kill_all_pids(pids, sig=signal.SIGTERM, timeout=5, sure_kill=False):
    &#34;&#34;&#34;Kill all processes with given pids.

    Args:
        pids (list of int): The target processes IDs.
        sig (signal, optional): See signal module constants. Defaults to signal.SIGKILL.
        timeout (int, optional): How long to wait for a process to terminate (seconds) before raise exception\
            or, if sure_kill=True, send a SIGKILL. Defaults to 5.
        sure_kill (bool, optional): Whether to fallback to SIGKILL if the timeout exceeded for the terminate operation or not. Defaults to False.


    Returns:
        list of int: represents the IDs of the processes remaning alive if any.
    &#34;&#34;&#34;
    failed_processes = []
    for pid in pids:
        try:
            kill(pid, sig, timeout=timeout, sure_kill=sure_kill)
        except (j.exceptions.Runtime, j.exceptions.Permission):
            failed_processes.append(pid)
    return failed_processes</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.process.kill_proc_tree"><code class="name flex">
<span>def <span class="ident">kill_proc_tree</span></span>(<span>parent, sig=&lt;Signals.SIGTERM: 15&gt;, include_parent=True, include_grand_children=True, timeout=5, sure_kill=False)</span>
</code></dt>
<dd>
<section class="desc"><p>Kill a process and its children (including grandchildren) with signal <code>sig</code></p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>proc</code></strong> :&ensp;<code>int</code> or <code>psutil.Process</code></dt>
<dd>Target process ID (PID) or psutil.Process object.</dd>
<dt><strong><code>sig</code></strong> :&ensp;<code>signal</code>, optional</dt>
<dd>See signal module constants. Defaults to signal.SIGTERM.</dd>
<dt>include_parent (): Whether to kill the process itself. Defaults to True.</dt>
<dt>include_grand_children (): whether to kill recursively all grandchildren. Defaults to True.</dt>
<dt><strong><code>timeout</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>How long to wait for a process to terminate (seconds) before raise exception
or, if sure_kill=True, send a SIGKILL. Defaults to 5.</dd>
<dt><strong><code>sure_kill</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether to fallback to SIGKILL if the timeout exceeded for the terminate operation or not. Defaults to False.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>list of psutil.Process: represents the objects of the processes remaning alive if any.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><strong><code>AssertionError</code></strong></dt>
<dd>in case the given <code>parent</code> is the current process</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def kill_proc_tree(
    parent, sig=signal.SIGTERM, include_parent=True, include_grand_children=True, timeout=5, sure_kill=False
):
    &#34;&#34;&#34;Kill a process and its children (including grandchildren) with signal `sig`

    Args:
        proc (int or psutil.Process): Target process ID (PID) or psutil.Process object.
        sig (signal, optional): See signal module constants. Defaults to signal.SIGTERM.
        include_parent (): Whether to kill the process itself. Defaults to True.
        include_grand_children (): whether to kill recursively all grandchildren. Defaults to True.
        timeout (int, optional): How long to wait for a process to terminate (seconds) before raise exception\
            or, if sure_kill=True, send a SIGKILL. Defaults to 5.
        sure_kill (bool, optional): Whether to fallback to SIGKILL if the timeout exceeded for the terminate operation or not. Defaults to False.

    Returns:
        list of psutil.Process: represents the objects of the processes remaning alive if any.

    Raises:
        AssertionError: in case the given `parent` is the current process
    &#34;&#34;&#34;
    if isinstance(parent, int):
        parent = get_process_object(parent)
        if parent is None:
            return  # already dead

    # should be checked on any killing function
    # here we first need to make sure taht `include_parent` is True
    # and/or better check inside the below for loop
    assert parent.pid != os.getpid(), &#34;won&#39;t kill myself&#34;

    processes = parent.children(recursive=include_grand_children)[::-1]
    failed = []
    if include_parent:
        processes.append(parent)

    for p in processes:
        try:
            kill(p, sig=sig, timeout=timeout, sure_kill=sure_kill)
        except (j.exceptions.Runtime, j.exceptions.Permission):
            failed.append(p)

    # making sure
    if failed:
        gone, failed = psutil.wait_procs(failed, timeout=0)
    return failed</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.process.kill_process_by_name"><code class="name flex">
<span>def <span class="ident">kill_process_by_name</span></span>(<span>process_name, sig=&lt;Signals.SIGTERM: 15&gt;, match_predicate=None, timeout=5, sure_kill=False)</span>
</code></dt>
<dd>
<section class="desc"><p>Kill all processes that match 'process_name'.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>process_name</code></strong> :&ensp;<code>str</code></dt>
<dd>The target process name.</dd>
<dt><strong><code>sig</code></strong> :&ensp;<code>signal</code>, optional</dt>
<dd>See signal module constants. Defaults to signal.SIGKILL</dd>
<dt><strong><code>match_predicate</code></strong> :&ensp;<code>callable</code>, optional</dt>
<dd>Function that does matching between
found processes and the targeted process, the function should accept
two arguments and return a boolean. Defaults to None.</dd>
<dt><strong><code>timeout</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>How long to wait for a process to terminate (seconds) before raise exception
or, if sure_kill=True, send a SIGKILL. Defaults to 5.</dd>
<dt><strong><code>sure_kill</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether to fallback to SIGKILL if the timeout exceeded for the terminate operation or not. Defaults to False.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>list of int: represents the IDs of the processes remaning alive if any.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def kill_process_by_name(process_name, sig=signal.SIGTERM, match_predicate=None, timeout=5, sure_kill=False):
    &#34;&#34;&#34;Kill all processes that match &#39;process_name&#39;.

    Args:
        process_name (str): The target process name.
        sig (signal, optional): See signal module constants. Defaults to signal.SIGKILL
        match_predicate (callable, optional): Function that does matching between\
            found processes and the targeted process, the function should accept\
            two arguments and return a boolean. Defaults to None.
        timeout (int, optional): How long to wait for a process to terminate (seconds) before raise exception\
            or, if sure_kill=True, send a SIGKILL. Defaults to 5.
        sure_kill (bool, optional): Whether to fallback to SIGKILL if the timeout exceeded for the terminate operation or not. Defaults to False.

    Returns:
        list of int: represents the IDs of the processes remaning alive if any.
    &#34;&#34;&#34;
    pids = get_pids(process_name, match_predicate=match_predicate)
    failed_processes = []
    for pid in pids:
        try:
            kill(pid, sig, timeout=timeout, sure_kill=sure_kill)
        except (j.exceptions.Runtime, j.exceptions.Permission):
            failed_processes.append(pid)
    return failed_processes</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.process.kill_process_by_port"><code class="name flex">
<span>def <span class="ident">kill_process_by_port</span></span>(<span>port, ipv6=False, udp=False, sig=&lt;Signals.SIGTERM: 15&gt;, timeout=5, sure_kill=False)</span>
</code></dt>
<dd>
<section class="desc"><p>Kill process by port.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>port</code></strong> :&ensp;<code>int</code></dt>
<dd>The port number.</dd>
<dt><strong><code>ipv6</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether to search the connections that using ipv6 instead of ipv4. Defaults to False.</dd>
<dt><strong><code>udp</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether to search the connections for UDP port instead of TCP. Defaults to False.</dd>
<dt><strong><code>sig</code></strong> :&ensp;<code>signal</code>, optional</dt>
<dd>See signal module constants. Defaults to signal.SIGTERM.</dd>
<dt><strong><code>timeout</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>How long to wait for a process to terminate (seconds) before raise exception
or, if sure_kill=True, send a SIGKILL. Defaults to 5.</dd>
<dt><strong><code>sure_kill</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether to fallback to SIGKILL if the timeout exceeded for the terminate operation or not. Defaults to False.</dd>
</dl>
<h2 id="raises">Raises</h2>
<p>j.exceptions.Runtime: In case killing the process failed.
j.exceptions.Permission: In case the permission to perform this action is denied.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def kill_process_by_port(port, ipv6=False, udp=False, sig=signal.SIGTERM, timeout=5, sure_kill=False):
    &#34;&#34;&#34;Kill process by port.

    Args:
        port (int): The port number.
        ipv6 (bool, optional): Whether to search the connections that using ipv6 instead of ipv4. Defaults to False.
        udp (bool, optional): Whether to search the connections for UDP port instead of TCP. Defaults to False.
        sig (signal, optional): See signal module constants. Defaults to signal.SIGTERM.
        timeout (int, optional): How long to wait for a process to terminate (seconds) before raise exception
            or, if sure_kill=True, send a SIGKILL. Defaults to 5.
        sure_kill (bool, optional): Whether to fallback to SIGKILL if the timeout exceeded for the terminate operation or not. Defaults to False.

    Raises:
        j.exceptions.Runtime: In case killing the process failed.
        j.exceptions.Permission: In case the permission to perform this action is denied.
    &#34;&#34;&#34;
    proc = get_process_by_port(port, ipv6=ipv6, udp=udp)
    kill(proc, sig=sig, timeout=timeout, sure_kill=sure_kill)</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.process.kill_user_processes"><code class="name flex">
<span>def <span class="ident">kill_user_processes</span></span>(<span>user, sig=&lt;Signals.SIGTERM: 15&gt;, timeout=5, sure_kill=False)</span>
</code></dt>
<dd>
<section class="desc"><p>Kill all processes for a specific user.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>user</code></strong> :&ensp;<code>str</code></dt>
<dd>The user name to match against.</dd>
<dt><strong><code>sig</code></strong> :&ensp;<code>signal</code>, optional</dt>
<dd>See signal module constants. Defaults to signal.SIGTERM.</dd>
<dt><strong><code>timeout</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>How long to wait for a process to terminate (seconds) before raise exception or, if sure_kill=True, send a SIGKILL. Defaults to 5.</dd>
<dt><strong><code>sure_kill</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether to fallback to SIGKILL if the timeout exceeded for the terminate operation or not. Defaults to False.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>list of psutil.Process): list of process objects that remain alive if any.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def kill_user_processes(user, sig=signal.SIGTERM, timeout=5, sure_kill=False):
    &#34;&#34;&#34;Kill all processes for a specific user.

    Args:
        user (str): The user name to match against.
        sig (signal, optional): See signal module constants. Defaults to signal.SIGTERM.
        timeout (int, optional): How long to wait for a process to terminate (seconds) before raise exception or, if sure_kill=True, send a SIGKILL. Defaults to 5.
        sure_kill (bool, optional): Whether to fallback to SIGKILL if the timeout exceeded for the terminate operation or not. Defaults to False.

    Returns:
        list of psutil.Process): list of process objects that remain alive if any.
    &#34;&#34;&#34;
    failed_processes = []
    for proc in get_user_processes(user):
        try:
            kill(proc, sig=sig, timeout=timeout, sure_kill=sure_kill)
        except (j.exceptions.Runtime, j.exceptions.Permission) as e:
            j.logger.exception(&#34;ignoring an exception that occurred while iterating over user processes&#34;, exception=e)
            failed_processes.append(proc)

    # making sure
    if failed_processes:
        gone, failed_processes = psutil.wait_procs(failed_processes, timeout=0)

    return failed_processes</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.process.ps_find"><code class="name flex">
<span>def <span class="ident">ps_find</span></span>(<span>process_name)</span>
</code></dt>
<dd>
<section class="desc"><p>Check if there is any running process that match the given name.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>process_name</code></strong> :&ensp;<code>str</code></dt>
<dd>The target process name. will match against against Process.name(), Process.exe() and Process.cmdline()</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>bool</code></strong></dt>
<dd>True if process is found, False otherwise.</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def ps_find(process_name):
    &#34;&#34;&#34;Check if there is any running process that match the given name.

    Args:
        process_name (str): The target process name. will match against against Process.name(), Process.exe() and Process.cmdline()

    Returns:
        bool: True if process is found, False otherwise.
    &#34;&#34;&#34;
    return len(get_pids(process_name, limit=1)) == 1</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.process.set_env_var"><code class="name flex">
<span>def <span class="ident">set_env_var</span></span>(<span>var_names, var_values)</span>
</code></dt>
<dd>
<section class="desc"><p>Set the value of the environment variables {varnames}. Existing variable are overwritten</p>
<p>Such changes to the environment affect subprocesses started with os.system(), popen() or fork() and execv()</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>var_names</code></strong> :&ensp;<code>list</code> of <code>str</code></dt>
<dd>A list of the names of all the environment variables to set</dd>
<dt><strong><code>varvalues</code></strong> :&ensp;<code>list</code> of <code>str</code></dt>
<dd>A list of all values for the environment variables</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>j.exceptions.RuntimeError</code>: <code>if</code> <code>error</code> <code>happened</code> <code>during</code> <code>setting</code> <code>the</code> <code>environment</code> <code>variables</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def set_env_var(var_names, var_values):
    &#34;&#34;&#34;Set the value of the environment variables {varnames}. Existing variable are overwritten

    Such changes to the environment affect subprocesses started with os.system(), popen() or fork() and execv()

    Args:
        var_names (list of str): A list of the names of all the environment variables to set
        varvalues (list of str): A list of all values for the environment variables

    Raises:
        j.exceptions.RuntimeError: if error happened during setting the environment variables
    &#34;&#34;&#34;
    # Note:
    # On some platforms, including FreeBSD and Mac OS X, setting environ may cause memory leaks.
    # https://docs.python.org/3/library/os.html?highlight=os%20environ#os.environ
    # Refer to the system documentation for putenv().
    for i in range(len(var_names)):
        os.environ[var_names[i]] = str(var_values[i]).strip()</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="jumpscale.sals" href="../index.html">jumpscale.sals</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="jumpscale.sals.process.check_process_for_pid" href="#jumpscale.sals.process.check_process_for_pid">check_process_for_pid</a></code></li>
<li><code><a title="jumpscale.sals.process.check_running" href="#jumpscale.sals.process.check_running">check_running</a></code></li>
<li><code><a title="jumpscale.sals.process.check_start" href="#jumpscale.sals.process.check_start">check_start</a></code></li>
<li><code><a title="jumpscale.sals.process.check_stop" href="#jumpscale.sals.process.check_stop">check_stop</a></code></li>
<li><code><a title="jumpscale.sals.process.execute" href="#jumpscale.sals.process.execute">execute</a></code></li>
<li><code><a title="jumpscale.sals.process.get_defunct_processes" href="#jumpscale.sals.process.get_defunct_processes">get_defunct_processes</a></code></li>
<li><code><a title="jumpscale.sals.process.get_environ" href="#jumpscale.sals.process.get_environ">get_environ</a></code></li>
<li><code><a title="jumpscale.sals.process.get_filtered_pids" href="#jumpscale.sals.process.get_filtered_pids">get_filtered_pids</a></code></li>
<li><code><a title="jumpscale.sals.process.get_memory_usage" href="#jumpscale.sals.process.get_memory_usage">get_memory_usage</a></code></li>
<li><code><a title="jumpscale.sals.process.get_my_process" href="#jumpscale.sals.process.get_my_process">get_my_process</a></code></li>
<li><code><a title="jumpscale.sals.process.get_pid_by_port" href="#jumpscale.sals.process.get_pid_by_port">get_pid_by_port</a></code></li>
<li><code><a title="jumpscale.sals.process.get_pids" href="#jumpscale.sals.process.get_pids">get_pids</a></code></li>
<li><code><a title="jumpscale.sals.process.get_pids_filtered_by_regex" href="#jumpscale.sals.process.get_pids_filtered_by_regex">get_pids_filtered_by_regex</a></code></li>
<li><code><a title="jumpscale.sals.process.get_pids_filtered_sorted" href="#jumpscale.sals.process.get_pids_filtered_sorted">get_pids_filtered_sorted</a></code></li>
<li><code><a title="jumpscale.sals.process.get_ports_mapping" href="#jumpscale.sals.process.get_ports_mapping">get_ports_mapping</a></code></li>
<li><code><a title="jumpscale.sals.process.get_process_by_port" href="#jumpscale.sals.process.get_process_by_port">get_process_by_port</a></code></li>
<li><code><a title="jumpscale.sals.process.get_process_object" href="#jumpscale.sals.process.get_process_object">get_process_object</a></code></li>
<li><code><a title="jumpscale.sals.process.get_processes" href="#jumpscale.sals.process.get_processes">get_processes</a></code></li>
<li><code><a title="jumpscale.sals.process.get_processes_info" href="#jumpscale.sals.process.get_processes_info">get_processes_info</a></code></li>
<li><code><a title="jumpscale.sals.process.get_similar_processes" href="#jumpscale.sals.process.get_similar_processes">get_similar_processes</a></code></li>
<li><code><a title="jumpscale.sals.process.get_user_processes" href="#jumpscale.sals.process.get_user_processes">get_user_processes</a></code></li>
<li><code><a title="jumpscale.sals.process.in_docker" href="#jumpscale.sals.process.in_docker">in_docker</a></code></li>
<li><code><a title="jumpscale.sals.process.in_host" href="#jumpscale.sals.process.in_host">in_host</a></code></li>
<li><code><a title="jumpscale.sals.process.is_alive" href="#jumpscale.sals.process.is_alive">is_alive</a></code></li>
<li><code><a title="jumpscale.sals.process.is_installed" href="#jumpscale.sals.process.is_installed">is_installed</a></code></li>
<li><code><a title="jumpscale.sals.process.is_port_listening" href="#jumpscale.sals.process.is_port_listening">is_port_listening</a></code></li>
<li><code><a title="jumpscale.sals.process.kill" href="#jumpscale.sals.process.kill">kill</a></code></li>
<li><code><a title="jumpscale.sals.process.kill_all_pids" href="#jumpscale.sals.process.kill_all_pids">kill_all_pids</a></code></li>
<li><code><a title="jumpscale.sals.process.kill_proc_tree" href="#jumpscale.sals.process.kill_proc_tree">kill_proc_tree</a></code></li>
<li><code><a title="jumpscale.sals.process.kill_process_by_name" href="#jumpscale.sals.process.kill_process_by_name">kill_process_by_name</a></code></li>
<li><code><a title="jumpscale.sals.process.kill_process_by_port" href="#jumpscale.sals.process.kill_process_by_port">kill_process_by_port</a></code></li>
<li><code><a title="jumpscale.sals.process.kill_user_processes" href="#jumpscale.sals.process.kill_user_processes">kill_user_processes</a></code></li>
<li><code><a title="jumpscale.sals.process.ps_find" href="#jumpscale.sals.process.ps_find">ps_find</a></code></li>
<li><code><a title="jumpscale.sals.process.set_env_var" href="#jumpscale.sals.process.set_env_var">set_env_var</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.6.4</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>