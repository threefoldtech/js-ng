<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.6.4" />
<title>jumpscale.sals.reservation_chatflow.deployer API documentation</title>
<meta name="description" content="" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase;cursor:pointer}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>jumpscale.sals.reservation_chatflow.deployer</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>Source code</summary>
<pre><code class="python">import base64
import re
import uuid
from collections import defaultdict
from decimal import Decimal
from textwrap import dedent
import requests

import gevent
import netaddr
from nacl.public import Box
from contextlib import ContextDecorator
from jumpscale.clients.explorer.models import DiskType, NextAction, WorkloadType, ZDBMode
from jumpscale.core.base import StoredFactory
from jumpscale.loader import j
from jumpscale.packages.tfgrid_solutions.models import PoolConfig
from jumpscale.sals.chatflows.chatflows import StopChatFlow
from jumpscale.sals.zos.zos import Zosv2


GATEWAY_WORKLOAD_TYPES = [
    WorkloadType.Domain_delegate,
    WorkloadType.Gateway4to6,
    WorkloadType.Subdomain,
    WorkloadType.Reverse_proxy,
    WorkloadType.Proxy,
]

pool_factory = StoredFactory(PoolConfig)
pool_factory.always_reload = True

NODE_BLOCKING_WORKLOAD_TYPES = [
    WorkloadType.Container,
    WorkloadType.Network_resource,
    WorkloadType.Volume,
    WorkloadType.Zdb,
]


DOMAINS_DISALLOW_PREFIX = &#34;TFGATEWAY:DOMAINS:DISALLOWED&#34;
DOMAINS_DISALLOW_EXPIRATION = 60 * 60 * 4  # 4 hours
DOMAINS_COUNT_KEY = &#34;TFGATEWAY:DOMAINS:FAILURE_COUNT&#34;


class DeploymentFailed(StopChatFlow):
    def __init__(self, msg=None, solution_uuid=None, wid=None, identity_name=None, **kwargs):
        super().__init__(msg, **kwargs)
        self.solution_uuid = solution_uuid
        self.wid = wid
        self.identity_name = identity_name


class deployment_context(ContextDecorator):
    def __enter__(self):
        return self

    def __exit__(self, exc_type, exc, exc_tb):
        if exc_type != DeploymentFailed:
            return
        if exc.solution_uuid:
            # cancel related workloads
            j.logger.info(f&#34;canceling workload ids of solution_uuid: {exc.solution_uuid}&#34;)
            j.sals.reservation_chatflow.solutions.cancel_solution_by_uuid(exc.solution_uuid)
        if exc.wid:
            # block the failed node if the workload is network or container
            zos = j.sals.zos.get(exc.identity_name)
            workload = zos.workloads.get(exc.wid)
            if workload.info.workload_type in NODE_BLOCKING_WORKLOAD_TYPES:
                j.logger.info(f&#34;blocking node {workload.info.node_id} for failed workload {workload.id}&#34;)
                j.sals.reservation_chatflow.reservation_chatflow.block_node(workload.info.node_id)


class NetworkView:
    class dry_run_context(ContextDecorator):
        def __init__(self, test_network_name, *args, **kwargs):
            super().__init__(*args, **kwargs)
            self.test_network_name = test_network_name

        def __enter__(self):
            return self

        def __exit__(self, *exc):
            network_view = NetworkView(self.test_network_name)
            for workload in network_view.network_workloads:
                j.sals.zos.get().workloads.decomission(workload.id)

    def __init__(self, name, workloads=None, nodes=None):
        self.name = name
        if not workloads:
            workloads = j.sals.zos.get().workloads.list(j.core.identity.me.tid, NextAction.DEPLOY)
        self.workloads = workloads
        self.used_ips = []
        self.network_workloads = []
        nodes = nodes or {node.node_id for node in j.sals.zos.get()._explorer.nodes.list()}
        self._fill_used_ips(self.workloads, nodes)
        self._init_network_workloads(self.workloads, nodes)
        if self.network_workloads:
            self.iprange = self.network_workloads[0].network_iprange
        else:
            self.iprange = &#34;can&#39;t be retrieved&#34;

    def _init_network_workloads(self, workloads, nodes=None):
        nodes = nodes or {node.node_id for node in j.sals.zos.get()._explorer.nodes.list()}
        for workload in workloads:
            if workload.info.node_id not in nodes:
                continue
            if workload.info.next_action != NextAction.DEPLOY:
                continue
            if workload.info.workload_type == WorkloadType.Network_resource and workload.name == self.name:
                self.network_workloads.append(workload)

    def _fill_used_ips(self, workloads, nodes=None):
        nodes = nodes or {node.node_id for node in j.sals.zos.get()._explorer.nodes.list()}
        for workload in workloads:
            if workload.info.node_id not in nodes:
                continue
            if workload.info.next_action != NextAction.DEPLOY:
                continue
            if workload.info.workload_type == WorkloadType.Kubernetes:
                self.used_ips.append(workload.ipaddress)
            elif workload.info.workload_type == WorkloadType.Container:
                for conn in workload.network_connection:
                    if conn.network_id == self.name:
                        self.used_ips.append(conn.ipaddress)

    def add_node(self, node, pool_id):
        used_ip_ranges = set()
        for workload in self.network_workloads:
            if workload.info.node_id == node.node_id:
                return
            used_ip_ranges.add(workload.iprange)
            for peer in workload.peers:
                used_ip_ranges.add(peer.iprange)
        else:
            network_range = netaddr.IPNetwork(self.iprange)
            for idx, subnet in enumerate(network_range.subnet(24)):
                if str(subnet) not in used_ip_ranges:
                    break
            else:
                raise StopChatFlow(&#34;Failed to find free network&#34;)
            network = j.sals.zos.get().network.create(self.iprange, self.name)
            node_workloads = {}
            for net_workload in self.network_workloads:
                node_workloads[net_workload.info.node_id] = net_workload
            network.network_resources = list(node_workloads.values())  # add only latest network resource for each node
            j.sals.zos.get().network.add_node(network, node.node_id, str(subnet), pool_id)
            return network

    def add_access(self, node_id=None, use_ipv4=True, pool_id=None):
        if node_id and not pool_id:
            raise StopChatFlow(&#34;You must specify the pool id if you specify the node id&#34;)
        node_id = node_id or self.network_workloads[0].info.node_id
        pool_id = pool_id or self.network_workloads[0].info.pool_id
        used_ip_ranges = set()
        for workload in self.network_workloads:
            used_ip_ranges.add(workload.iprange)
            for peer in workload.peers:
                used_ip_ranges.add(peer.iprange)
        else:
            network_range = netaddr.IPNetwork(self.iprange)
            for idx, subnet in enumerate(network_range.subnet(24)):
                if str(subnet) not in used_ip_ranges:
                    break
            else:
                raise StopChatFlow(&#34;Failed to find free network&#34;)
        network = j.sals.zos.get().network.create(self.iprange, self.name)
        node_workloads = {}
        for net_workload in self.network_workloads:
            node_workloads[net_workload.info.node_id] = net_workload
        network.network_resources = list(node_workloads.values())  # add only latest network resource for each node
        if node_id not in node_workloads:
            j.sals.zos.get().network.add_node(network, node_id, str(subnet), pool_id=pool_id)
        wg_quick = j.sals.zos.get().network.add_access(network, node_id, str(subnet), ipv4=use_ipv4)
        return network, wg_quick

    def delete_access(self, ip_range, node_id=None):
        node_id = node_id or self.network_workloads[0].info.node_id
        node_workloads = {}
        for net_workload in self.network_workloads:
            node_workloads[net_workload.info.node_id] = net_workload
        network = j.sals.zos.get().network.create(self.iprange, self.name)
        network.network_resources = list(node_workloads.values())
        network = j.sals.zos.get().network.delete_access(network, node_id, ip_range)
        return network

    def get_node_range(self, node):
        for workload in self.network_workloads:
            if workload.info.next_action != NextAction.DEPLOY:
                continue
            if workload.info.node_id == node.node_id:
                return workload.iprange
        raise StopChatFlow(f&#34;Node {node.node_id} is not part of network&#34;)

    def copy(self):
        return NetworkView(self.name)

    def get_node_free_ips(self, node):
        ip_range = self.get_node_range(node)
        freeips = []
        hosts = netaddr.IPNetwork(ip_range).iter_hosts()
        next(hosts)  # skip ip used by node
        for host in hosts:
            ip = str(host)
            if ip not in self.used_ips:
                freeips.append(ip)
        return freeips

    def get_free_ip(self, node):
        ip_range = self.get_node_range(node)
        hosts = netaddr.IPNetwork(ip_range).iter_hosts()
        next(hosts)  # skip ip used by node
        for host in hosts:
            ip = str(host)
            if ip not in self.used_ips:
                self.used_ips.append(ip)
                return ip
        return None

    def dry_run(self, test_network_name=None, node_ids=None, pool_ids=None, bot=None, breaking_node_ids=None):
        name = test_network_name or uuid.uuid4().hex
        breaking_node_ids = breaking_node_ids or node_ids
        if bot:
            bot.md_show_update(&#34;Starting dry run to check nodes status&#34;)
        ip_range = netaddr.IPNetwork(&#34;10.10.0.0/16&#34;)

        if any([node_ids, pool_ids]) and not all([node_ids, pool_ids]):
            raise StopChatFlow(&#34;you must specify both pool ids and node ids together&#34;)
        node_pool_dict = {}
        if node_ids:
            for idx, node_id in enumerate(node_ids):
                node_pool_dict[node_id] = pool_ids[idx]
        else:
            for workload in self.network_workloads:
                node_pool_dict[workload.info.node_id] = workload.info.pool_id
            node_ids = list(node_pool_dict.keys())
            pool_ids = list(node_pool_dict.values())

        node_ids = list(set(node_ids))
        network = j.sals.zos.get().network.create(str(ip_range), name)
        for idx, subnet in enumerate(ip_range.subnet(24)):
            if idx == len(node_ids):
                break
            j.sals.zos.get().network.add_node(network, node_ids[idx], str(subnet), node_pool_dict[node_ids[idx]])
        result = []
        for resource in network.network_resources:
            if bot:
                bot.md_show_update(f&#34;testing deployment on node {resource.info.node_id}&#34;)
            try:
                result.append(j.sals.zos.get().workloads.deploy(resource))
            except Exception as e:
                raise StopChatFlow(
                    f&#34;failed to deploy workload on node {resource.info.node_id} due to&#34; f&#34; error {str(e)}&#34;
                )
        for idx, wid in enumerate(result):
            try:
                deployer.wait_workload(wid, bot, 2)
            except StopChatFlow:
                workload = j.sals.zos.get().workloads.get(wid)
                # if not a breaking nodes (old node not used for deployment) we can overlook it
                if workload.info.node_id not in breaking_node_ids:
                    continue
                j.sals.reservation_chatflow.reservation_chatflow.block_node(network.network_resources[idx].info.node_id)
                raise StopChatFlow(
                    &#34;Network nodes dry run failed on node&#34; f&#34; {network.network_resources[idx].info.node_id}&#34;
                )


class ChatflowDeployer:
    def __init__(self):
        self.workloads = defaultdict(
            lambda: defaultdict(lambda: defaultdict(list))
        )  # Next Action: workload_type: pool_id: [workloads]

    @property
    def _explorer(self):
        return j.core.identity.me.explorer

    def load_user_workloads(self, next_action=NextAction.DEPLOY):
        all_workloads = j.sals.zos.get().workloads.list(j.core.identity.me.tid, next_action)
        self.workloads.pop(next_action, None)
        for workload in all_workloads:
            if workload.info.metadata:
                workload.info.metadata = self.decrypt_metadata(workload.info.metadata)
                try:
                    j.data.serializers.json.loads(workload.info.metadata)
                except:
                    workload.info.metadata = &#34;{}&#34;
            else:
                workload.info.metadata = &#34;{}&#34;
            self.workloads[workload.info.next_action][workload.info.workload_type][workload.info.pool_id].append(
                workload
            )

    def decrypt_metadata(self, encrypted_metadata):
        try:
            pk = j.core.identity.me.nacl.signing_key.verify_key.to_curve25519_public_key()
            sk = j.core.identity.me.nacl.signing_key.to_curve25519_private_key()
            box = Box(sk, pk)
            return box.decrypt(base64.b85decode(encrypted_metadata.encode())).decode()
        except:
            return &#34;{}&#34;

    def list_networks(self, next_action=NextAction.DEPLOY, sync=True):
        if sync:
            self.load_user_workloads(next_action=next_action)
        networks = {}  # name: last child network resource
        for pool_id in self.workloads[next_action][WorkloadType.Network_resource]:
            for workload in self.workloads[next_action][WorkloadType.Network_resource][pool_id]:
                networks[workload.name] = workload
        all_workloads = []
        for pools_workloads in self.workloads[next_action].values():
            for pool_id, workload_list in pools_workloads.items():
                all_workloads += workload_list
        network_views = {}
        nodes = {node.node_id for node in j.sals.zos.get()._explorer.nodes.list()}
        for network_name in networks:
            network_views[network_name] = NetworkView(network_name, all_workloads, nodes)
        return network_views

    def _pool_form(self, bot):
        form = bot.new_form()
        cu = form.int_ask(&#34;Required Amount of Compute Unit (CU)&#34;, required=True, min=0, default=0)
        su = form.int_ask(&#34;Required Amount of Storage Unit (SU)&#34;, required=True, min=0, default=0)
        time_unit = form.drop_down_choice(
            &#34;Please choose the duration unit&#34;, [&#34;Day&#34;, &#34;Month&#34;, &#34;Year&#34;], required=True, default=&#34;Month&#34;
        )
        ttl = form.int_ask(&#34;Please specify the pools time-to-live&#34;, required=True, min=1, default=0)
        form.ask(
            &#34;&#34;&#34;- Compute Unit (CU) is the amount of data processing power specified as the number of virtual CPU cores (logical CPUs) and RAM (Random Access Memory).
- Storage Unit (SU) is the size of data storage capacity.

You can get more detail information about clout units on the wiki: &lt;a href=&#34;https://wiki.threefold.io/#/grid_concepts?id=cloud-units-v4&#34; target=&#34;_blank&#34;&gt;Cloud units details&lt;/a&gt;.


The way this form works is you define how much cloud units you want to reserve and define for how long you would like the selected amount of cloud units.
As an example, if you want to be able to run some workloads that consumes `5CU` and `10SU` worth of capacity for `2 month`, you would specify:

- CU: 5
- SU: 10
- Duration unit: Month
- Duration: 2
&#34;&#34;&#34;,
            md=True,
        )
        ttl = ttl.value
        time_unit = time_unit.value
        if time_unit == &#34;Day&#34;:
            days = 1
        elif time_unit == &#34;Month&#34;:
            days = 30
        elif time_unit == &#34;Year&#34;:
            days = 365
        else:
            raise j.exceptions.Input(&#34;Invalid duration unit&#34;)

        cu = cu.value * 60 * 60 * 24 * days * ttl
        su = su.value * 60 * 60 * 24 * days * ttl
        return (cu, su, [&#34;TFT&#34;])

    def create_pool(self, bot):
        cu, su, currencies = self._pool_form(bot)
        all_farms = self._explorer.farms.list()
        available_farms = {}
        farms_by_name = {}
        for farm in all_farms:
            farm_assets = [w.asset for w in farm.wallet_addresses]
            if currencies[0] not in farm_assets:
                continue
            res = self.check_farm_capacity(farm.name, currencies)
            available = res[0]
            resources = res[1:]
            if available:
                available_farms[farm.name] = resources
                farms_by_name[farm.name] = farm
        farm_messages = {}
        for farm in available_farms:
            farm_assets = [w.asset for w in farms_by_name[farm].wallet_addresses]
            if currencies[0] not in farm_assets:
                continue
            resources = available_farms[farm]
            farm_obj = farms_by_name[farm]
            location_list = [farm_obj.location.continent, farm_obj.location.country, farm_obj.location.city]
            location = &#34;-&#34;.join([info for info in location_list if info])
            if location:
                location = f&#34; location: {location}&#34;
            farm_messages[
                f&#34;{farm.capitalize()}{location}: CRU: {resources[0]} SRU: {resources[1]} HRU: {resources[2]} MRU {resources[3]}&#34;
            ] = farm
        if not farm_messages:
            raise StopChatFlow(f&#34;There are no farms available that the support {currencies[0]} currency&#34;)
        selected_farm = bot.drop_down_choice(
            &#34;Please choose a farm to reserve capacity from. By reserving IT Capacity, you are purchasing the capacity from one of the farms. The available Resource Units (RU): CRU, MRU, HRU, SRU, NRU are displayed for you to make a more-informed decision on farm selection. &#34;,
            list(farm_messages.keys()),
            required=True,
        )
        farm = farm_messages[selected_farm]
        try:
            pool_info = j.sals.zos.get().pools.create(cu, su, farm, currencies)
        except Exception as e:
            raise StopChatFlow(f&#34;failed to reserve pool.\n{str(e)}&#34;)
        qr_code = self.show_payment(pool_info, bot)
        self.wait_pool_payment(bot, pool_info.reservation_id, 10, qr_code, trigger_cus=cu, trigger_sus=su)
        return pool_info

    def extend_pool(self, bot, pool_id):
        cu, su, currencies = self._pool_form(bot)
        currencies = [&#34;TFT&#34;]
        try:
            pool_info = j.sals.zos.get().pools.extend(pool_id, cu, su, currencies=currencies)
        except Exception as e:
            raise StopChatFlow(f&#34;failed to extend pool.\n{str(e)}&#34;)
        qr_code = self.show_payment(pool_info, bot)
        pool = j.sals.zos.get().pools.get(pool_id)
        trigger_cus = pool.cus + (cu * 0.75) if cu else 0
        trigger_sus = pool.sus + (su * 0.75) if su else 0
        self.wait_pool_payment(bot, pool_id, 10, qr_code, trigger_cus=trigger_cus, trigger_sus=trigger_sus)
        return pool_info

    def check_farm_capacity(self, farm_name, currencies=None, sru=None, cru=None, mru=None, hru=None, ip_version=None):
        node_filter = None
        if ip_version and ip_version not in [&#34;IPv4&#34;, &#34;IPv6&#34;]:
            raise j.exceptions.Runtime(f&#34;{ip_version} is not a valid IP Version&#34;)
        else:
            if ip_version == &#34;IPv4&#34;:
                node_filter = j.sals.zos.get().nodes_finder.filter_public_ip4
            elif ip_version == &#34;IPv6&#34;:
                node_filter = j.sals.zos.get().nodes_finder.filter_public_ip6
        currencies = currencies or []
        farm_nodes = j.sals.zos.get().nodes_finder.nodes_search(farm_name=farm_name)
        available_cru = 0
        available_sru = 0
        available_mru = 0
        available_hru = 0
        running_nodes = 0
        blocked_nodes = j.sals.reservation_chatflow.reservation_chatflow.list_blocked_nodes()
        access_node = None
        for node in farm_nodes:
            if &#34;FreeTFT&#34; in currencies and not node.free_to_use:
                continue
            if not j.sals.zos.get().nodes_finder.filter_is_up(node):
                continue
            if node.node_id in blocked_nodes:
                continue
            if not access_node and ip_version and node_filter(node):
                access_node = node
            running_nodes += 1
            available_cru += node.total_resources.cru - node.used_resources.cru
            available_sru += node.total_resources.sru - node.used_resources.sru
            available_mru += node.total_resources.mru - node.used_resources.mru
            available_hru += node.total_resources.hru - node.used_resources.hru

        if not running_nodes:
            return False, available_cru, available_sru, available_mru, available_hru
        if sru and available_sru &lt; sru:
            return False, available_cru, available_sru, available_mru, available_hru
        if cru and available_cru &lt; cru:
            return False, available_cru, available_sru, available_mru, available_hru
        if mru and available_mru &lt; mru:
            return False, available_cru, available_sru, available_mru, available_hru
        if hru and available_hru &lt; hru:
            return False, available_cru, available_sru, available_mru, available_hru
        if ip_version and not access_node:
            return False, available_cru, available_sru, available_mru, available_hru
        return True, available_cru, available_sru, available_mru, available_hru

    def show_payment(self, pool, bot):
        escrow_info = pool.escrow_information
        resv_id = pool.reservation_id
        escrow_address = escrow_info.address
        escrow_asset = escrow_info.asset
        total_amount = escrow_info.amount
        if not total_amount:
            return
        total_amount_dec = Decimal(total_amount) / Decimal(1e7)
        total_amount = &#34;{0:f}&#34;.format(total_amount_dec)

        wallets = j.sals.reservation_chatflow.reservation_chatflow.list_wallets()
        wallet_names = []
        for w in wallets.keys():
            wallet = j.clients.stellar.get(w)
            try:
                balances = wallet.get_balance().balances
            except:
                continue
            for balance in balances:
                if balance.asset_code in escrow_asset:
                    if float(balance.balance) &gt; float(total_amount):
                        wallet_names.append(w)
                    else:
                        break
        wallet_names.append(&#34;External Wallet (QR Code)&#34;)
        self.msg_payment_info, qr_code = self.get_qr_code_payment_info(pool)
        message = f&#34;&#34;&#34;
        &lt;h3&gt;Billing details:&lt;/h3&gt;&lt;br&gt;
        {self.msg_payment_info}
        &lt;br&gt;&lt;hr&gt;&lt;br&gt;
        &lt;h3&gt; Choose a wallet name to use for payment or proceed with payment through External wallet (QR Code) &lt;/h3&gt;
        &#34;&#34;&#34;
        result = bot.single_choice(message, wallet_names, html=True, required=True)
        if result == &#34;External Wallet (QR Code)&#34;:
            msg_text = f&#34;&#34;&#34;
            &lt;h3&gt;Make a Payment&lt;/h3&gt;
            Scan the QR code with your wallet (do not change the message) or enter the information below manually and proceed with the payment. Make sure to put p-{resv_id} as memo_text value.

            {self.msg_payment_info}

            &#34;&#34;&#34;
            bot.qrcode_show(data=qr_code, msg=msg_text, scale=4, update=True, html=True)
        else:
            wallet = wallets[result]
            wallet.transfer(
                destination_address=escrow_address, amount=total_amount, asset=escrow_asset, memo_text=f&#34;p-{resv_id}&#34;
            )
            return None
        return qr_code

    def list_pools(self, cu=None, su=None):
        all_pools = [p for p in j.sals.zos.get().pools.list() if p.node_ids]

        available_pools = {}
        for pool in all_pools:
            hidden = False
            name = &#34;&#34;
            if f&#34;pool_{pool.pool_id}&#34; in pool_factory.list_all():
                local_config = pool_factory.get(f&#34;pool_{pool.pool_id}&#34;)
                hidden = local_config.hidden
                name = local_config.name
            if hidden:
                continue
            res = self.check_pool_capacity(pool, cu, su)
            available = res[0]
            if available:
                resources = res[1:]
                if name:
                    resources += (name,)
                available_pools[pool.pool_id] = resources
        return available_pools

    def check_pool_capacity(self, pool, cu=None, su=None):
        available_su = pool.sus
        available_cu = pool.cus
        if pool.empty_at &lt; 0:
            return False, 0, 0
        if cu and available_cu &lt; cu:
            return False, available_cu, available_su
        if su and available_su &lt; su:
            return False, available_cu, available_su
        if (cu or su) and pool.empty_at &lt; j.data.time.now().timestamp:
            return False, 0, 0
        return True, available_cu, available_su

    def select_pool(
        self, bot, cu=None, su=None, sru=None, mru=None, hru=None, cru=None, available_pools=None, workload_name=None
    ):
        if j.config.get(&#34;OVER_PROVISIONING&#34;):
            cru = 0
            mru = 0
        available_pools = available_pools or self.list_pools(cu, su)
        if not available_pools:
            raise StopChatFlow(&#34;no available pools with enough capacity for your workload&#34;)
        pool_messages = {}
        for pool in available_pools:
            nodes = j.sals.zos.get().nodes_finder.nodes_by_capacity(pool_id=pool, sru=sru, mru=mru, hru=hru, cru=cru)
            if not nodes:
                continue

            pool_msg = f&#34;Pool: {pool} cu: {available_pools[pool][0]} su:&#34; f&#34; {available_pools[pool][1]}&#34;
            if len(available_pools[pool]) &gt; 2:
                pool_msg += f&#34; Name: {available_pools[pool][2]}&#34;
            pool_messages[pool_msg] = pool
        if not pool_messages:
            raise StopChatFlow(&#34;no available resources in the farms bound to your pools&#34;)
        msg = &#34;Please select a pool&#34;
        if workload_name:
            msg += f&#34; for {workload_name}&#34;
        pool = bot.drop_down_choice(msg, list(pool_messages.keys()), required=True)
        return pool_messages[pool]

    def get_pool_farm_id(self, pool_id=None, pool=None):
        pool = pool or j.sals.zos.get().pools.get(pool_id)
        pool_id = pool.pool_id
        if not pool.node_ids:
            raise StopChatFlow(f&#34;Pool {pool_id} doesn&#39;t contain any nodes&#34;)
        farm_id = None
        while not farm_id:
            for node_id in pool.node_ids:
                try:
                    node = self._explorer.nodes.get(node_id)
                    farm_id = node.farm_id
                    break
                except requests.exceptions.HTTPError:
                    continue
            return farm_id or -1

    def ask_name(self, bot, msg=None):
        msg = (
            msg
            or &#34;Please enter a name for your workload (Can be used to prepare domain for you and needed to track your solution on the grid)&#34;
        )
        name = bot.string_ask(msg, required=True, field=&#34;name&#34;, is_identifier=True)

        return name

    def ask_email(self, bot):
        valid = False
        email = None
        regex = r&#34;^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$&#34;
        while not valid:
            email = bot.string_ask(&#34;Please enter your email address&#34;, required=True, field=&#34;email&#34;)
            valid = re.search(regex, email) is not None
            if not valid:
                bot.md_show(&#34;Please enter a valid email address&#34;)
        return email

    def ask_ipv6(self, bot, workload_name=None):
        workload_name = workload_name or &#34;your workload&#34;
        ipv6 = bot.single_choice(
            f&#34;Do you want to assign a global IPv6 address to {workload_name}?&#34;,
            options=[&#34;YES&#34;, &#34;NO&#34;],
            default=&#34;NO&#34;,
            required=True,
        )
        return ipv6 == &#34;YES&#34;

    def encrypt_metadata(self, metadata):
        if isinstance(metadata, dict):
            metadata = j.data.serializers.json.dumps(metadata)
        pk = j.core.identity.me.nacl.signing_key.verify_key.to_curve25519_public_key()
        sk = j.core.identity.me.nacl.signing_key.to_curve25519_private_key()
        box = Box(sk, pk)
        encrypted_metadata = base64.b85encode(box.encrypt(metadata.encode())).decode()
        return encrypted_metadata

    def deploy_network(self, name, access_node, ip_range, ip_version, pool_id, **metadata):
        network = j.sals.zos.get().network.create(ip_range, name)
        node_subnets = netaddr.IPNetwork(ip_range).subnet(24)
        network_config = dict()
        use_ipv4 = ip_version == &#34;IPv4&#34;

        j.sals.zos.get().network.add_node(network, access_node.node_id, str(next(node_subnets)), pool_id)
        wg_quick = j.sals.zos.get().network.add_access(
            network, access_node.node_id, str(next(node_subnets)), ipv4=use_ipv4
        )

        network_config[&#34;wg&#34;] = wg_quick
        j.sals.fs.mkdir(f&#34;{j.core.dirs.CFGDIR}/wireguard/&#34;)
        j.sals.fs.write_file(f&#34;{j.core.dirs.CFGDIR}/{name}.conf&#34;, f&#34;{wg_quick}&#34;)

        ids = []
        parent_id = None
        for workload in network.network_resources:
            workload.info.description = j.data.serializers.json.dumps({&#34;parent_id&#34;: parent_id})
            metadata[&#34;parent_network&#34;] = parent_id
            workload.info.metadata = self.encrypt_metadata(metadata)
            ids.append(j.sals.zos.get().workloads.deploy(workload))
            parent_id = ids[-1]
        network_config[&#34;ids&#34;] = ids
        network_config[&#34;rid&#34;] = ids[0]
        return network_config

    def add_access(
        self, network_name, network_view=None, node_id=None, pool_id=None, use_ipv4=True, bot=None, **metadata
    ):
        network_view = network_view or NetworkView(network_name)
        network, wg = network_view.add_access(node_id, use_ipv4, pool_id)
        result = {&#34;ids&#34;: [], &#34;wg&#34;: wg}
        node_workloads = {}
        # deploy only latest resource generated by zos sal for each node
        for workload in network.network_resources:
            node_workloads[workload.info.node_id] = workload

        dry_run_name = uuid.uuid4().hex
        with NetworkView.dry_run_context(dry_run_name):
            network_view.dry_run(
                dry_run_name,
                list(node_workloads.keys()),
                [w.info.pool_id for w in node_workloads.values()],
                bot,
                breaking_node_ids=[node_id],
            )

        parent_id = network_view.network_workloads[-1].id
        for resource in node_workloads.values():
            resource.info.reference = &#34;&#34;
            resource.info.description = j.data.serializers.json.dumps({&#34;parent_id&#34;: parent_id})
            metadata[&#34;parent_network&#34;] = parent_id
            resource.info.metadata = self.encrypt_metadata(metadata)
            result[&#34;ids&#34;].append(j.sals.zos.get().workloads.deploy(resource))
            parent_id = result[&#34;ids&#34;][-1]
        result[&#34;rid&#34;] = result[&#34;ids&#34;][0]
        return result

    def delete_access(self, network_name, iprange, network_view=None, node_id=None, bot=None, **metadata):
        network_view = network_view or NetworkView(network_name)
        network = network_view.delete_access(iprange, node_id)

        node_workloads = {}
        # deploy only latest resource generated by zos sal for each node
        for workload in network.network_resources:
            node_workloads[workload.info.node_id] = workload
        dry_run_name = uuid.uuid4().hex
        with NetworkView.dry_run_context(dry_run_name):
            network_view.dry_run(
                dry_run_name,
                list(node_workloads.keys()),
                [w.info.pool_id for w in node_workloads.values()],
                bot,
                breaking_node_ids=[node_id],
            )
        parent_id = network_view.network_workloads[-1].id
        result = []
        for resource in node_workloads.values():
            resource.info.reference = &#34;&#34;
            resource.info.description = j.data.serializers.json.dumps({&#34;parent_id&#34;: parent_id})
            metadata[&#34;parent_network&#34;] = parent_id
            resource.info.metadata = self.encrypt_metadata(metadata)
            result.append(j.sals.zos.get().workloads.deploy(resource))
            parent_id = result[-1]
        return result

    def wait_workload(self, workload_id, bot=None, expiry=10, breaking_node_id=None):
        expiry = expiry or 10
        expiration_provisioning = j.data.time.now().timestamp + expiry * 60

        workload = j.sals.zos.get().workloads.get(workload_id)
        if workload.info.workload_type in GATEWAY_WORKLOAD_TYPES:
            node = self._explorer.gateway.get(workload.info.node_id)
        else:
            node = self._explorer.nodes.get(workload.info.node_id)
        # check if the node is up
        if not j.sals.zos.get().nodes_finder.filter_is_up(node):
            cancel = True
            if breaking_node_id and breaking_node_id == node.node_id:
                # if the node is down and it is the same as breaking_node_id
                if workload.info.workload_type == WorkloadType.Network_resource:
                    # if the workload is a newtork we don&#39;t cancel it
                    cancel = False
            # the node is down but it is not a breaking node_id
            elif workload.info.workload_type == WorkloadType.Network_resource:
                # if the workload is network we can overlook it
                return True
            if cancel:
                j.sals.reservation_chatflow.solutions.cancel_solution([workload_id])
            raise StopChatFlow(f&#34;Workload {workload_id} failed to deploy because the node is down {node.node_id}&#34;)

        # wait for workload
        while True:
            workload = j.sals.zos.get().workloads.get(workload_id)
            remaning_time = j.data.time.get(expiration_provisioning).humanize(granularity=[&#34;minute&#34;, &#34;second&#34;])
            if bot:
                deploying_message = f&#34;&#34;&#34;\
                # Deploying...

                &lt;br /&gt;Workload ID: {workload_id}


                Deployment should take around 2 to 3 minutes, but might take longer and will be cancelled if it is not successful in 10 mins
                &#34;&#34;&#34;
                bot.md_show_update(dedent(deploying_message), md=True)
            if workload.info.result.workload_id:
                success = workload.info.result.state.value == 1
                if not success:
                    error_message = workload.info.result.message
                    msg = f&#34;Workload {workload.id} failed to deploy due to error {error_message}. For more details: {j.core.identity.me.explorer_url}/reservations/workloads/{workload.id}&#34;
                    j.logger.error(msg)
                    j.tools.alerthandler.alert_raise(
                        appname=&#34;chatflows&#34;, category=&#34;internal_errors&#34;, message=msg, alert_type=&#34;exception&#34;
                    )
                elif workload.info.workload_type != WorkloadType.Network_resource:
                    j.sals.reservation_chatflow.reservation_chatflow.unblock_node(workload.info.node_id)
                return success
            if expiration_provisioning &lt; j.data.time.get().timestamp:
                j.sals.reservation_chatflow.reservation_chatflow.block_node(workload.info.node_id)
                if workload.info.workload_type != WorkloadType.Network_resource:
                    j.sals.reservation_chatflow.solutions.cancel_solution([workload_id])
                elif breaking_node_id and workload.info.node_id != breaking_node_id:
                    return True
                raise StopChatFlow(f&#34;Workload {workload_id} failed to deploy in time&#34;)
            gevent.sleep(1)

    def add_network_node(self, name, node, pool_id, network_view=None, bot=None, **metadata):
        if not network_view:
            network_view = NetworkView(name)
        network = network_view.add_node(node, pool_id)
        if not network:
            return
        parent_id = network_view.network_workloads[-1].id
        ids = []
        node_workloads = {}
        # deploy only latest resource generated by zos sal for each node
        for workload in network.network_resources:
            node_workloads[workload.info.node_id] = workload
        dry_run_name = uuid.uuid4().hex
        with NetworkView.dry_run_context(dry_run_name):
            network_view.dry_run(
                dry_run_name,
                list(node_workloads.keys()),
                [w.info.pool_id for w in node_workloads.values()],
                bot,
                breaking_node_ids=[node.node_id],
            )
        for workload in node_workloads.values():
            workload.info.reference = &#34;&#34;
            workload.info.description = j.data.serializers.json.dumps({&#34;parent_id&#34;: parent_id})
            metadata[&#34;parent_network&#34;] = parent_id
            workload.info.metadata = self.encrypt_metadata(metadata)
            ids.append(j.sals.zos.get().workloads.deploy(workload))
            parent_id = ids[-1]
        return {&#34;ids&#34;: ids, &#34;rid&#34;: ids[0]}

    def select_network(self, bot, network_views=None):
        network_views = network_views or self.list_networks()
        if not network_views:
            raise StopChatFlow(f&#34;You don&#39;t have any deployed network.&#34;)
        network_name = bot.single_choice(&#34;Please select a network&#34;, list(network_views.keys()), required=True)
        return network_views[network_name]

    def deploy_volume(self, pool_id, node_id, size, volume_type=DiskType.SSD, **metadata):
        volume = j.sals.zos.get().volume.create(node_id, pool_id, size, volume_type)
        if metadata:
            volume.info.metadata = self.encrypt_metadata(metadata)
        return j.sals.zos.get().workloads.deploy(volume)

    def deploy_container(
        self,
        pool_id,
        node_id,
        network_name,
        ip_address,
        flist,
        env=None,
        cpu=1,
        memory=1024,
        disk_size=256,
        disk_type=DiskType.SSD,
        entrypoint=&#34;&#34;,
        interactive=False,
        secret_env=None,
        volumes=None,
        log_config=None,
        public_ipv6=False,
        **metadata,
    ):
        &#34;&#34;&#34;
        volumes: dict {&#34;mountpoint (/)&#34;: volume_id}
        log_Config: dict. keys (&#34;channel_type&#34;, &#34;channel_host&#34;, &#34;channel_port&#34;, &#34;channel_name&#34;)
        &#34;&#34;&#34;
        env = env or {}
        encrypted_secret_env = {}
        if secret_env:
            for key, val in secret_env.items():
                encrypted_secret_env[key] = j.sals.zos.get().container.encrypt_secret(node_id, val)
        container = j.sals.zos.get().container.create(
            node_id,
            network_name,
            ip_address,
            flist,
            pool_id,
            env,
            cpu,
            memory,
            disk_size,
            entrypoint,
            interactive,
            encrypted_secret_env,
            public_ipv6=public_ipv6,
        )
        if volumes:
            for mount_point, vol_id in volumes.items():
                j.sals.zos.get().volume.attach_existing(container, f&#34;{vol_id}-1&#34;, mount_point)
        if metadata:
            container.info.metadata = self.encrypt_metadata(metadata)
        if log_config:
            j.sals.zos.get().container.add_logs(container, **log_config)
        return j.sals.zos.get().workloads.deploy(container)

    def ask_container_resources(
        self,
        bot,
        cpu=True,
        memory=True,
        disk_size=True,
        disk_type=False,
        default_cpu=1,
        default_memory=1024,
        default_disk_size=256,
        default_disk_type=&#34;SSD&#34;,
    ):
        form = bot.new_form()
        if cpu:
            cpu_answer = form.int_ask(&#34;Please specify how many CPUs&#34;, default=default_cpu, required=True, min=1)
        if memory:
            memory_answer = form.int_ask(
                &#34;Please specify how much memory (in MB)&#34;, default=default_memory, required=True, min=1024
            )
        if disk_size:
            disk_size_answer = form.int_ask(
                &#34;Please specify the size of root filesystem (in MB)&#34;, default=default_disk_size, required=True
            )
        if disk_type:
            disk_type_answer = form.single_choice(
                &#34;Please choose the root filesystem disktype&#34;, [&#34;SSD&#34;, &#34;HDD&#34;], default=default_disk_type, required=True
            )
        form.ask()
        resources = {}
        if cpu:
            resources[&#34;cpu&#34;] = cpu_answer.value
        if memory:
            resources[&#34;memory&#34;] = memory_answer.value
        if disk_size:
            resources[&#34;disk_size&#34;] = disk_size_answer.value
        if disk_type:
            resources[&#34;disk_type&#34;] = DiskType[disk_type_answer.value]
        return resources

    def ask_container_logs(self, bot, solution_name=None):
        logs_config = {}
        form = bot.new_form()
        channel_type = form.string_ask(&#34;Please add the channel type&#34;, default=&#34;redis&#34;, required=True)
        channel_host = form.string_ask(&#34;Please add the IP address where the logs will be output to&#34;, required=True)
        channel_port = form.int_ask(&#34;Please add the port available where the logs will be output to&#34;, required=True)
        channel_name = form.string_ask(
            &#34;Please add the channel name to be used. The channels will be in the form&#34; &#34; NAME-stdout and NAME-stderr&#34;,
            default=solution_name,
            required=True,
        )
        form.ask()
        logs_config[&#34;channel_type&#34;] = channel_type.value
        logs_config[&#34;channel_host&#34;] = channel_host.value
        logs_config[&#34;channel_port&#34;] = channel_port.value
        logs_config[&#34;channel_name&#34;] = channel_name.value
        return logs_config

    def schedule_container(self, pool_id, cru=None, sru=None, mru=None, hru=None, ip_version=None):
        query = {&#34;cru&#34;: cru, &#34;sru&#34;: sru, &#34;mru&#34;: mru, &#34;hru&#34;: hru, &#34;ip_version&#34;: ip_version}
        return j.sals.reservation_chatflow.reservation_chatflow.get_nodes(1, pool_ids=[pool_id], **query)[0]

    def ask_container_placement(
        self,
        bot,
        pool_id,
        cru=None,
        sru=None,
        mru=None,
        hru=None,
        ip_version=None,
        free_to_use=False,
        workload_name=None,
    ):
        if not workload_name:
            workload_name = &#34;your workload&#34;
        automatic_choice = bot.single_choice(
            &#34;Do you want to automatically select a node for deployment for&#34; f&#34; {workload_name}?&#34;,
            [&#34;YES&#34;, &#34;NO&#34;],
            default=&#34;YES&#34;,
            required=True,
        )
        if automatic_choice == &#34;YES&#34;:
            return None
        if j.config.get(&#34;OVER_PROVISIONING&#34;):
            cru = 0
            mru = 0
        nodes = j.sals.zos.get().nodes_finder.nodes_by_capacity(pool_id=pool_id, cru=cru, sru=sru, mru=mru, hru=hru)
        nodes = list(nodes)
        nodes = j.sals.reservation_chatflow.reservation_chatflow.filter_nodes(nodes, free_to_use, ip_version)
        blocked_nodes = j.sals.reservation_chatflow.reservation_chatflow.list_blocked_nodes()
        node_messages = {node.node_id: node for node in nodes if node.node_id not in blocked_nodes}
        if not node_messages:
            raise StopChatFlow(&#34;Failed to find resources for this reservation&#34;)
        node_id = bot.drop_down_choice(
            f&#34;Please choose the node you want to deploy {workload_name} on&#34;, list(node_messages.keys()), required=True
        )
        return node_messages[node_id]

    def calculate_capacity_units(self, cru=0, mru=0, sru=0, hru=0):
        &#34;&#34;&#34;
        return cu, su
        &#34;&#34;&#34;
        cu = min((mru - 1) / 4, cru * 4 / 2)
        su = (hru / 1000 + sru / 100 / 2) / 1.2
        if cu &lt; 0:
            cu = 0
        if su &lt; 0:
            su = 0
        return cu, su

    def get_network_view(self, network_name, workloads=None):
        return NetworkView(network_name, workloads)

    def delegate_domain(self, pool_id, gateway_id, domain_name, **metadata):
        domain_delegate = j.sals.zos.get().gateway.delegate_domain(gateway_id, domain_name, pool_id)
        if metadata:
            domain_delegate.info.metadata = self.encrypt_metadata(metadata)
        return j.sals.zos.get().workloads.deploy(domain_delegate)

    def deploy_kubernetes_master(
        self, pool_id, node_id, network_name, cluster_secret, ssh_keys, ip_address, size=1, **metadata
    ):
        master = j.sals.zos.get().kubernetes.add_master(
            node_id, network_name, cluster_secret, ip_address, size, ssh_keys, pool_id
        )
        master.info.description = j.data.serializers.json.dumps({&#34;role&#34;: &#34;master&#34;})
        if metadata:
            master.info.metadata = self.encrypt_metadata(metadata)
        return j.sals.zos.get().workloads.deploy(master)

    def deploy_kubernetes_worker(
        self, pool_id, node_id, network_name, cluster_secret, ssh_keys, ip_address, master_ip, size=1, **metadata
    ):
        worker = j.sals.zos.get().kubernetes.add_worker(
            node_id, network_name, cluster_secret, ip_address, size, master_ip, ssh_keys, pool_id
        )
        worker.info.description = j.data.serializers.json.dumps({&#34;role&#34;: &#34;worker&#34;})
        if metadata:
            worker.info.metadata = self.encrypt_metadata(metadata)
        return j.sals.zos.get().workloads.deploy(worker)

    def deploy_kubernetes_cluster(
        self,
        pool_id,
        node_ids,
        network_name,
        cluster_secret,
        ssh_keys,
        size=1,
        ip_addresses=None,
        slave_pool_ids=None,
        **metadata,
    ):
        &#34;&#34;&#34;
        deplou k8s cluster with the same number of nodes as specifed in node_ids

        Args:
            pool_id: this one is always used for master.
            node_ids: list() of node ids to deploy on. first node_id is used for master reservation
            ip_addresses: if specified it will be mapped 1-1 with node_ids for workloads. if not specified it will choose any free_ip from the node
            slave_pool_ids: if specified, k8s workers will deployed on each of these pools respectively. if empty it will use the master pool_id

        Return:
            list: [{&#34;node_id&#34;: &#34;ip_address&#34;}, ...] first dict is master&#39;s result
        &#34;&#34;&#34;
        slave_pool_ids = slave_pool_ids or ([pool_id] * (len(node_ids) - 1))
        pool_ids = [pool_id] + slave_pool_ids
        result = []  # [{&#34;node_id&#34;: id,  &#34;ip_address&#34;: ip, &#34;reservation_id&#34;: 16}] first dict is master&#39;s result
        if ip_addresses and len(ip_addresses) != len(node_ids):
            raise StopChatFlow(&#34;length of ips != node_ids&#34;)

        if not ip_addresses:
            # get free_ips for the nodes
            ip_addresses = []
            for i in range(len(node_ids)):
                node_id = node_ids[i]
                pool_id = pool_ids[i]
                node = self._explorer.nodes.get(node_id)
                res = self.add_network_node(network_name, node, pool_id)
                if res:
                    for wid in res[&#34;ids&#34;]:
                        success = self.wait_workload(wid, breaking_node_id=node.node_id)
                        if not success:
                            raise StopChatFlow(f&#34;Failed to add node {node.node_id} to network {wid}&#34;)
                network_view = NetworkView(network_name)
                address = network_view.get_free_ip(node)
                if not address:
                    raise StopChatFlow(f&#34;No free IPs for network {network_name} on the specifed node&#34; f&#34; {node_id}&#34;)
                ip_addresses.append(address)

        # deploy_master
        master_ip = ip_addresses[0]
        master_resv_id = self.deploy_kubernetes_master(
            pool_ids[0], node_ids[0], network_name, cluster_secret, ssh_keys, master_ip, size, **metadata
        )
        result.append({&#34;node_id&#34;: node_ids[0], &#34;ip_address&#34;: master_ip, &#34;reservation_id&#34;: master_resv_id})
        for i in range(1, len(node_ids)):
            node_id = node_ids[i]
            pool_id = pool_ids[i]
            ip_address = ip_addresses[i]
            resv_id = self.deploy_kubernetes_worker(
                pool_id, node_id, network_name, cluster_secret, ssh_keys, ip_address, master_ip, size, **metadata
            )
            result.append({&#34;node_id&#34;: node_id, &#34;ip_address&#34;: ip_address, &#34;reservation_id&#34;: resv_id})
        return result

    def ask_multi_pool_placement(
        self, bot, number_of_nodes, resource_query_list=None, pool_ids=None, workload_names=None, ip_version=None
    ):
        &#34;&#34;&#34;
        Ask and schedule workloads accross multiple pools

        Args:
            bot: chatflow object
            number_of_nodes: number of required nodes for deployment
            resource_query_list: list of query dicts {&#34;cru&#34;: 1, &#34;sru&#34;: 2, &#34;mru&#34;: 1, &#34;hru&#34;: 1}. if specified it must be same length as number_of_nodes
            pool_ids: if specfied it will limit the pools shown in the chatflow to only these pools
            workload_names: if specified they will shown when asking the user for node selection for each workload. if specified it must be same length as number_of_nodes

        Returns:
            ([], []): first list contains the selected node objects. second list contains selected pool ids
        &#34;&#34;&#34;
        resource_query_list = resource_query_list or [dict()] * number_of_nodes
        workload_names = workload_names or [None] * number_of_nodes
        if len(resource_query_list) != number_of_nodes:
            raise StopChatFlow(&#34;resource query_list must be same length as number of nodes&#34;)
        if len(workload_names) != number_of_nodes:
            raise StopChatFlow(&#34;workload_names must be same length as number of nodes&#34;)

        pools = self.list_pools()
        if pool_ids:
            filtered_pools = {}
            for pool_id in pools:
                if pool_id in pool_ids:
                    filtered_pools[pool_id] = pools[pool_id]
            pools = filtered_pools
        selected_nodes = []
        selected_pool_ids = []
        for i in range(number_of_nodes):
            cu, su = self.calculate_capacity_units(**resource_query_list[i])
            pool_choices = {}
            for p in pools:
                if pools[p][0] &lt; cu or pools[p][1] &lt; su:
                    continue
                nodes = j.sals.zos.get().nodes_finder.nodes_by_capacity(pool_id=p, **resource_query_list[i])
                if not nodes:
                    continue
                pool_choices[p] = pools[p]
            pool_id = self.select_pool(bot, available_pools=pool_choices, workload_name=workload_names[i], cu=cu, su=su)
            node = self.ask_container_placement(
                bot, pool_id, workload_name=workload_names[i], ip_version=ip_version, **resource_query_list[i]
            )
            if not node:
                node = self.schedule_container(pool_id, ip_version=ip_version, **resource_query_list[i])
            selected_nodes.append(node)
            selected_pool_ids.append(pool_id)
        return selected_nodes, selected_pool_ids

    def list_pool_gateways(self, pool_id):
        &#34;&#34;&#34;
        return dict of gateways where keys are descriptive string of each gateway
        &#34;&#34;&#34;
        pool = j.sals.zos.get().pools.get(pool_id)
        farm_id = self.get_pool_farm_id(pool_id)
        if farm_id &lt; 0:
            raise StopChatFlow(f&#34;no available gateways in pool {pool_id} farm: {farm_id}&#34;)
        gateways = self._explorer.gateway.list(farm_id=farm_id)
        if not gateways:
            raise StopChatFlow(f&#34;no available gateways in pool {pool_id} farm: {farm_id}&#34;)
        result = {}
        for g in gateways:
            if not g.dns_nameserver:
                continue
            if g.node_id not in pool.node_ids:
                continue
            result[f&#34;{g.dns_nameserver[0]} {g.location.continent} {g.location.country}&#34; f&#34; {g.node_id}&#34;] = g
        return result

    def list_all_gateways(self, pool_ids=None):
        &#34;&#34;&#34;
        Args:
            pool_ids: if specified it will only list gateways inside these pools

        Returns:
            dict: {&#34;gateway_message&#34;: {&#34;gateway&#34;: g, &#34;pool&#34;: pool},}
        &#34;&#34;&#34;
        all_gateways = filter(j.sals.zos.get().nodes_finder.filter_is_up, self._explorer.gateway.list())
        if not all_gateways:
            raise StopChatFlow(f&#34;no available gateways&#34;)
        all_pools = [p for p in j.sals.zos.get().pools.list() if p.node_ids]
        available_node_ids = {}  # node_id: pool
        if pool_ids is not None:
            for pool in all_pools:
                if pool.pool_id in pool_ids:
                    available_node_ids.update({node_id: pool for node_id in pool.node_ids})
        else:
            for pool in all_pools:
                available_node_ids.update({node_id: pool for node_id in pool.node_ids})
        result = {}
        for gateway in all_gateways:
            if gateway.node_id in available_node_ids:
                if not gateway.dns_nameserver:
                    continue
                pool = available_node_ids[gateway.node_id]
                hidden = False
                name = &#34;&#34;
                if f&#34;pool_{pool.pool_id}&#34; in pool_factory.list_all():
                    local_config = pool_factory.get(f&#34;pool_{pool.pool_id}&#34;)
                    hidden = local_config.hidden
                    name = local_config.name
                if hidden:
                    continue
                if name:
                    message = (
                        f&#34;Pool: {pool.pool_id} Name: {name} {gateway.dns_nameserver[0]}&#34;
                        f&#34; {gateway.location.continent} {gateway.location.country}&#34;
                        f&#34; {gateway.node_id}&#34;
                    )
                else:
                    message = (
                        f&#34;Pool: {pool.pool_id} {gateway.dns_nameserver[0]}&#34;
                        f&#34; {gateway.location.continent} {gateway.location.country}&#34;
                        f&#34; {gateway.node_id}&#34;
                    )
                result[message] = {&#34;gateway&#34;: gateway, &#34;pool&#34;: pool}
        if not result:
            raise StopChatFlow(f&#34;no gateways available in your pools&#34;)
        return result

    def select_gateway(self, bot, pool_ids=None):
        &#34;&#34;&#34;
        Args:
            pool_ids: if specified it will only list gateways inside these pools

        Returns:
            gateway, pool_objects
        &#34;&#34;&#34;
        gateways = self.list_all_gateways(pool_ids)

        selected = bot.single_choice(&#34;Please select a gateway&#34;, list(gateways.keys()), required=True)
        return gateways[selected][&#34;gateway&#34;], gateways[selected][&#34;pool&#34;]

    def create_ipv6_gateway(self, gateway_id, pool_id, public_key, **metadata):
        if isinstance(public_key, bytes):
            public_key = public_key.decode()
        workload = j.sals.zos.get().gateway.gateway_4to6(gateway_id, public_key, pool_id)
        if metadata:
            workload.info.metadata = self.encrypt_metadata(metadata)
        return j.sals.zos.get().workloads.deploy(workload)

    def deploy_zdb(self, pool_id, node_id, size, mode, password, disk_type=&#34;SSD&#34;, public=False, **metadata):
        workload = j.sals.zos.get().zdb.create(node_id, size, mode, password, pool_id, disk_type, public)
        if metadata:
            workload.info.metadata = self.encrypt_metadata(metadata)
        return j.sals.zos.get().workloads.deploy(workload)

    def create_subdomain(self, pool_id, gateway_id, subdomain, addresses=None, **metadata):
        &#34;&#34;&#34;
        creates an A record pointing to the specified addresses
        if no addresses are specified, the record will point the gateway IP address (used for exposing solutions)
        &#34;&#34;&#34;
        if not addresses:
            gateway = self._explorer.gateway.get(gateway_id)
            addresses = [j.sals.nettools.get_host_by_name(ns) for ns in gateway.dns_nameserver]
        workload = j.sals.zos.get().gateway.sub_domain(gateway_id, subdomain, addresses, pool_id)
        if metadata:
            workload.info.metadata = self.encrypt_metadata(metadata)
        return j.sals.zos.get().workloads.deploy(workload)

    def create_proxy(self, pool_id, gateway_id, domain_name, trc_secret, **metadata):
        &#34;&#34;&#34;
        creates a reverse tunnel on the gateway node
        &#34;&#34;&#34;
        workload = j.sals.zos.get().gateway.tcp_proxy_reverse(gateway_id, domain_name, trc_secret, pool_id)
        if metadata:
            workload.info.metadata = self.encrypt_metadata(metadata)
        return j.sals.zos.get().workloads.deploy(workload)

    def expose_and_create_certificate(
        self,
        pool_id,
        gateway_id,
        network_name,
        trc_secret,
        domain,
        email,
        solution_ip,
        solution_port,
        enforce_https=False,
        node_id=None,
        proxy_pool_id=None,
        log_config=None,
        bot=None,
        public_key=&#34;&#34;,
        **metadata,
    ):
        &#34;&#34;&#34;
        exposes the solution and enable ssl for it&#39;s domain
        Args:
            pool_id: the pool used to create your solution
            gateway_id: Gateway id
            network_name: Name of the network selected while creating the solution
            trc_secret: Secret for tcp router
            domain: the domain we will issue certificate for
            email: used to issue certificate
            solution_ip: where your server is hosted (the actual server)
            solution_port: the port your application is listening on
            enforce_https: whether you want to only use https or not
            node_id: your node id
            solution_uuid: solution id
            public_key: your public key in case you want to have ssh access on the nginx container

        &#34;&#34;&#34;
        test_cert = j.config.get(&#34;TEST_CERT&#34;)
        proxy_pool_id = proxy_pool_id or pool_id
        gateway = self._explorer.gateway.get(gateway_id)

        proxy_id = self.create_proxy(
            pool_id=proxy_pool_id, gateway_id=gateway_id, domain_name=domain, trc_secret=trc_secret, **metadata
        )
        success = self.wait_workload(proxy_id)
        if not success:
            raise DeploymentFailed(
                f&#34;failed to create reverse proxy on gateway {gateway_id} workload {proxy_id}&#34;,
                wid=proxy_id,
                solution_uuid=metadata.get(&#34;solution_uuid&#34;),
            )

        tf_gateway = f&#34;{gateway.dns_nameserver[0]}:{gateway.tcp_router_port}&#34;
        secret_env = {
            &#34;TRC_SECRET&#34;: trc_secret,
            &#34;TFGATEWAY&#34;: tf_gateway,
            &#34;EMAIL&#34;: email,
            &#34;SOLUTION_IP&#34;: solution_ip,
            &#34;SOLUTION_PORT&#34;: str(solution_port),
            &#34;DOMAIN&#34;: domain,
            &#34;ENFORCE_HTTPS&#34;: &#34;true&#34; if enforce_https else &#34;false&#34;,
            &#34;PUBKEY&#34;: public_key,
            &#34;TEST_CERT&#34;: &#34;true&#34; if test_cert else &#34;false&#34;,
        }
        if not node_id:
            node = self.schedule_container(pool_id=pool_id, cru=1, mru=1, hru=1)
            node_id = node.node_id
        else:
            node = self._explorer.nodes.get(node_id)

        res = self.add_network_node(network_name, node, pool_id, bot=bot)
        if res:
            for wid in res[&#34;ids&#34;]:
                success = self.wait_workload(wid, bot, breaking_node_id=node.node_id)
                if not success:
                    raise DeploymentFailed(
                        f&#34;failed to add node {node.node_id} to network workload {wid}&#34;,
                        wid=wid,
                        solution_uuid=metadata.get(&#34;solution_uuid&#34;),
                    )
        network_view = NetworkView(network_name)
        network_view = network_view.copy()
        ip_address = network_view.get_free_ip(node)
        resv_id = self.deploy_container(
            pool_id=pool_id,
            node_id=node_id,
            network_name=network_name,
            ip_address=ip_address,
            flist=&#34;https://hub.grid.tf/omar0.3bot/omarelawady-nginx-certbot-zinit.flist&#34;,
            disk_type=DiskType.HDD,
            disk_size=512,
            secret_env=secret_env,
            public_ipv6=False,
            log_config=log_config,
            **metadata,
        )
        return resv_id

    def expose_address(
        self,
        pool_id,
        gateway_id,
        network_name,
        local_ip,
        port,
        tls_port,
        trc_secret,
        node_id=None,
        reserve_proxy=False,
        proxy_pool_id=None,
        domain_name=None,
        bot=None,
        log_config=None,
        **metadata,
    ):
        proxy_pool_id = proxy_pool_id or pool_id
        gateway = self._explorer.gateway.get(gateway_id)

        if reserve_proxy:
            if not domain_name:
                raise StopChatFlow(&#34;you must pass domain_name when you ise reserv_proxy&#34;)
            resv_id = self.create_proxy(
                pool_id=proxy_pool_id, gateway_id=gateway_id, domain_name=domain_name, trc_secret=trc_secret, **metadata
            )
            success = self.wait_workload(resv_id)
            if not success:
                raise DeploymentFailed(
                    f&#34;failed to create reverse proxy on gateway {gateway_id} to network workload {resv_id}&#34;,
                    wid=resv_id,
                    solution_uuid=metadata.get(&#34;solution_uuid&#34;),
                )

        remote = f&#34;{gateway.dns_nameserver[0]}:{gateway.tcp_router_port}&#34;
        secret_env = {&#34;TRC_SECRET&#34;: trc_secret}
        if not node_id:
            node = self.schedule_container(pool_id=pool_id, cru=1, mru=1, hru=1)
            node_id = node.node_id
        else:
            node = self._explorer.nodes.get(node_id)

        res = self.add_network_node(network_name, node, pool_id, bot=bot)
        if res:
            for wid in res[&#34;ids&#34;]:
                success = self.wait_workload(wid, bot, breaking_node_id=node.node_id)
                if not success:
                    if reserve_proxy:
                        j.sals.reservation_chatflow.solutions.cancel([resv_id])
                    raise DeploymentFailed(
                        f&#34;Failed to add node {node.node_id} to network {wid}&#34;,
                        wid=wid,
                        solution_uuid=metadata.get(&#34;solution_uuid&#34;),
                    )
        network_view = NetworkView(network_name)
        network_view = network_view.copy()
        network_view.used_ips.append(local_ip)
        ip_address = network_view.get_free_ip(node)
        env = {
            &#34;SOLUTION_IP&#34;: local_ip,
            &#34;HTTP_PORT&#34;: str(port),
            &#34;HTTPS_PORT&#34;: str(tls_port),
            &#34;REMOTE_IP&#34;: gateway.dns_nameserver[0],
            &#34;REMOTE_PORT&#34;: str(gateway.tcp_router_port),
        }
        print(log_config)
        resv_id = self.deploy_container(
            pool_id=pool_id,
            node_id=node_id,
            network_name=network_name,
            ip_address=ip_address,
            flist=&#34;https://hub.grid.tf/omar0.3bot/omarelawady-trc-zinit.flist&#34;,
            disk_type=DiskType.HDD,
            secret_env=secret_env,
            env=env,
            public_ipv6=False,
            log_config=log_config,
            **metadata,
        )
        return resv_id

    def deploy_minio_zdb(
        self,
        pool_id,
        password,
        node_ids=None,
        zdb_no=None,
        disk_type=DiskType.HDD,
        disk_size=10,
        pool_ids=None,
        **metadata,
    ):
        &#34;&#34;&#34;
        deploy zdb workloads on the specified node_ids if specified or deploy workloads as specifdied by the zdb_no
        Args:
            pool_id: used to deploy all workloads in this pool (overriden when pool_ids is specified)
            node_ids: if specified, it will be used for deployment of workloads.
            pool_ids: if specified, zdb workloads will be
            zdb_no: if specified and no node_ids, it will automatically schedule zdb workloads matching pool config

        Returns:
            []: list of workload ids deployed
        &#34;&#34;&#34;
        node_ids = node_ids or []
        if not (zdb_no or node_ids):
            raise StopChatFlow(&#34;you must pass at least one of zdb_no or node_ids&#34;)

        if node_ids:
            pool_ids = pool_ids or [pool_id] * len(node_ids)
        else:
            pool_ids = pool_ids or [pool_id] * zdb_no

        if len(pool_ids) != len(node_ids):
            raise StopChatFlow(&#34;pool_ids must be same length as node_ids&#34;)

        if not node_ids and zdb_no:
            query = {}
            if disk_type == DiskType.SSD:
                query[&#34;sru&#34;] = disk_size
            else:
                query[&#34;hru&#34;] = disk_size
            for pool_id in pool_ids:
                node = j.sals.reservation_chatflow.reservation_chatflow.nodes_get(
                    pool_ids=[pool_id], number_of_nodes=1, **query
                )[0]
                node_ids.append(node.node_id)

        result = []
        for i in range(len(node_ids)):
            node_id = node_ids[i]
            pool_id = pool_ids[i]
            resv_id = self.deploy_zdb(
                pool_id=pool_id,
                node_id=node_id,
                size=disk_size,
                mode=ZDBMode.Seq,
                password=password,
                disk_type=disk_type,
                **metadata,
            )
            result.append(resv_id)
        return result

    def deploy_minio_containers(
        self,
        pool_id,
        network_name,
        minio_nodes,
        minio_ip_addresses,
        zdb_configs,
        ak,
        sk,
        ssh_key,
        cpu,
        memory,
        data,
        parity,
        disk_type=DiskType.SSD,
        disk_size=10,
        log_config=None,
        mode=&#34;Single&#34;,
        bot=None,
        public_ipv6=False,
        secondary_pool_id=None,
        **metadata,
    ):
        secondary_pool_id = secondary_pool_id or pool_id
        secret_env = {}
        if mode == &#34;Master/Slave&#34;:
            secret_env[&#34;TLOG&#34;] = zdb_configs.pop(-1)
        shards = &#34;,&#34;.join(zdb_configs)
        secret_env[&#34;SHARDS&#34;] = shards
        secret_env[&#34;SECRET_KEY&#34;] = sk
        env = {
            &#34;DATA&#34;: str(data),
            &#34;PARITY&#34;: str(parity),
            &#34;ACCESS_KEY&#34;: ak,
            &#34;SSH_KEY&#34;: ssh_key,
            &#34;MINIO_PROMETHEUS_AUTH_TYPE&#34;: &#34;public&#34;,
        }
        result = []
        master_volume_id = self.deploy_volume(pool_id, minio_nodes[0], disk_size, disk_type, **metadata)
        success = self.wait_workload(master_volume_id, bot)
        if not success:
            raise DeploymentFailed(
                f&#34;Failed to create volume {master_volume_id} for minio container on&#34; f&#34; node {minio_nodes[0]}&#34;,
                wid=master_volume_id,
                solution_uuid=metadata.get(&#34;solution_uuid&#34;),
            )
        master_cont_id = self.deploy_container(
            pool_id=pool_id,
            node_id=minio_nodes[0],
            network_name=network_name,
            ip_address=minio_ip_addresses[0],
            env=env,
            cpu=cpu,
            memory=memory,
            secret_env=secret_env,
            log_config=log_config,
            volumes={&#34;/data&#34;: master_volume_id},
            public_ipv6=public_ipv6,
            flist=&#34;https://hub.grid.tf/tf-official-apps/minio:latest.flist&#34;,
            **metadata,
        )
        result.append(master_cont_id)
        if mode == &#34;Master/Slave&#34;:
            secret_env[&#34;MASTER&#34;] = secret_env.pop(&#34;TLOG&#34;)
            slave_volume_id = self.deploy_volume(pool_id, minio_nodes[1], disk_size, disk_type, **metadata)
            success = self.wait_workload(slave_volume_id, bot)
            if not success:
                raise DeploymentFailed(
                    f&#34;Failed to create volume {slave_volume_id} for minio container on&#34; f&#34; node {minio_nodes[1]}&#34;,
                    solution_uuid=metadata.get(&#34;solution_uuid&#34;),
                    wid=slave_volume_id,
                )
            slave_cont_id = self.deploy_container(
                pool_id=secondary_pool_id,
                node_id=minio_nodes[1],
                network_name=network_name,
                ip_address=minio_ip_addresses[1],
                env=env,
                cpu=cpu,
                memory=memory,
                secret_env=secret_env,
                log_config=log_config,
                volumes={&#34;/data&#34;: slave_volume_id},
                public_ipv6=public_ipv6,
                flist=&#34;https://hub.grid.tf/tf-official-apps/minio:latest.flist&#34;,
                **metadata,
            )
            result.append(slave_cont_id)
        return result

    def get_zdb_url(self, zdb_id, password):
        workload = j.sals.zos.get().workloads.get(zdb_id)
        result_json = j.data.serializers.json.loads(workload.info.result.data_json)
        if &#34;IPs&#34; in result_json:
            ip = result_json[&#34;IPs&#34;][0]
        else:
            ip = result_json[&#34;IP&#34;]
        namespace = result_json[&#34;Namespace&#34;]
        port = result_json[&#34;Port&#34;]
        url = f&#34;{namespace}:{password}@[{ip}]:{port}&#34;
        return url

    def ask_multi_pool_distribution(
        self, bot, number_of_nodes, resource_query=None, pool_ids=None, workload_name=None, ip_version=None
    ):
        &#34;&#34;&#34;
        Choose multiple pools to distribute workload automatically

        Args:
            bot: chatflow object
            resource_query: query dict {&#34;cru&#34;: 1, &#34;sru&#34;: 2, &#34;mru&#34;: 1, &#34;hru&#34;: 1}.
            pool_ids: if specfied it will limit the pools shown in the chatflow to only these pools
            workload_name: name shown in the message
        Returns:
            ([], []): first list contains the selected node objects. second list contains selected pool ids
        &#34;&#34;&#34;
        resource_query = resource_query or {}
        cu, su = self.calculate_capacity_units(**resource_query)
        pools = self.list_pools(cu, su)
        if pool_ids:
            filtered_pools = {}
            for pool_id in pools:
                if pool_id in pool_ids:
                    filtered_pools[pool_id] = pools[pool_id]
            pools = filtered_pools

        workload_name = workload_name or &#34;workloads&#34;
        messages = {}
        pool_factory = StoredFactory(PoolConfig)
        for p in pools:
            hidden = False
            name = &#34;&#34;
            if f&#34;pool_{p}&#34; in pool_factory.list_all():
                pool_config = pool_factory.get(f&#34;pool_{p}&#34;)
                hidden = pool_config.hidden
                name = pool_config.name
            if hidden:
                continue
            if name:
                messages[f&#34;Name: {name} Pool: {p} CU: {pools[p][0]} SU: {pools[p][1]}&#34;] = p
            else:
                messages[f&#34;Pool: {p} CU: {pools[p][0]} SU: {pools[p][1]}&#34;] = p

        while True:
            pool_choices = bot.multi_list_choice(
                &#34;Please select the pools you wish to distribute you&#34; f&#34; {workload_name} on&#34;,
                options=list(messages.keys()),
                required=True,
            )
            if not pool_choices:
                bot.md_show(&#34;You must select at least one pool. please click next to try again.&#34;)
            else:
                break

        pool_ids = {}
        node_to_pool = {}
        for p in pool_choices:
            pool = pool_ids.get(messages[p], j.sals.zos.get().pools.get(messages[p]))
            pool_ids[messages[p]] = pool.pool_id
            for node_id in pool.node_ids:
                node_to_pool[node_id] = pool

        nodes = j.sals.reservation_chatflow.reservation_chatflow.get_nodes(
            number_of_nodes, pool_ids=list(pool_ids.values()), ip_version=ip_version, **resource_query
        )
        selected_nodes = []
        selected_pool_ids = []
        for node in nodes:
            selected_nodes.append(node)
            pool = node_to_pool[node.node_id]
            selected_pool_ids.append(pool.pool_id)
        return selected_nodes, selected_pool_ids

    def chatflow_pools_check(self):
        if not self.list_pools():
            raise StopChatFlow(&#34;You don&#39;t have any capacity pools. Please create one first.&#34;)

    def chatflow_network_check(self, bot):
        networks = self.list_networks()
        if not networks:
            raise StopChatFlow(&#34;You don&#39;t have any deployed networks. Please create one first.&#34;)
        bot.all_network_viewes = networks

    def wait_demo_payment(self, bot, pool_id, exp=5, trigger_cus=0, trigger_sus=1):
        expiration = j.data.time.now().timestamp + exp * 60
        msg = &#34;&lt;h2&gt; Waiting for resources provisioning...&lt;/h2&gt;&#34;
        while j.data.time.get().timestamp &lt; expiration:
            bot.md_show_update(msg, html=True)
            pool = j.sals.zos.get().pools.get(pool_id)
            if pool.cus &gt;= trigger_cus and pool.sus &gt;= trigger_sus:
                bot.md_show_update(&#34;Preparing app resources&#34;)
                return True
            gevent.sleep(2)

        return False

    def wait_pool_payment(self, bot, pool_id, exp=5, qr_code=None, trigger_cus=0, trigger_sus=1):
        expiration = j.data.time.now().timestamp + exp * 60
        msg = &#34;&lt;h2&gt; Waiting for payment...&lt;/h2&gt;&#34;
        if qr_code:
            qr_encoded = j.tools.qrcode.base64_get(qr_code, scale=2)
            msg += f&#34;Please scan the QR Code below for the payment details if you missed it from the previous screen&#34;
            qr_code_msg = f&#34;&#34;&#34;
            &lt;div class=&#34;text-center&#34;&gt;
                &lt;img style=&#34;border:1px dashed #85929E&#34; src=&#34;data:image/png;base64,{qr_encoded}&#34;/&gt;
            &lt;/div&gt;
            &#34;&#34;&#34;
            pool = j.sals.zos.get().pools.get(pool_id)
            msg = msg + self.msg_payment_info + qr_code_msg
        while j.data.time.get().timestamp &lt; expiration:
            bot.md_show_update(msg, html=True)
            pool = j.sals.zos.get().pools.get(pool_id)
            if pool.cus &gt;= trigger_cus and pool.sus &gt;= trigger_sus:
                bot.md_show_update(&#34;Preparing app resources&#34;)
                return True
            gevent.sleep(2)

        return False

    def get_payment_info(self, pool):
        escrow_info = pool.escrow_information
        resv_id = pool.reservation_id
        escrow_address = escrow_info.address
        escrow_asset = escrow_info.asset
        total_amount = escrow_info.amount
        total_amount_dec = Decimal(total_amount) / Decimal(1e7)
        thecurrency = escrow_asset.split(&#34;:&#34;)[0]
        return {
            &#34;escrow_info&#34;: escrow_info,
            &#34;resv_id&#34;: resv_id,
            &#34;escrow_address&#34;: escrow_address,
            &#34;escrow_asset&#34;: escrow_asset,
            &#34;total_amount_dec&#34;: total_amount_dec,
            &#34;thecurrency&#34;: thecurrency,
            &#34;total_amount&#34;: total_amount,
        }

    def get_qr_code_payment_info(self, pool):
        info = self.get_payment_info(pool)
        total_amount = &#34;{0:f}&#34;.format(info[&#34;total_amount_dec&#34;])
        qr_code = f&#34;{info[&#39;thecurrency&#39;]}:{info[&#39;escrow_address&#39;]}?amount={total_amount}&amp;message=p-{info[&#39;resv_id&#39;]}&amp;sender=me&#34;
        msg_text = f&#34;&#34;&#34;

        &lt;h4&gt; Destination Wallet Address: &lt;/h4&gt;  {info[&#39;escrow_address&#39;]} \n
        &lt;h4&gt; Currency: &lt;/h4&gt;  {info[&#39;thecurrency&#39;]} \n
        &lt;h4&gt; Memo Text (Reservation ID): &lt;/h4&gt;  p-{info[&#39;resv_id&#39;]} \n
        &lt;h4&gt; Total Amount: &lt;/h4&gt; {total_amount} {info[&#39;thecurrency&#39;]} \n

        &lt;h5&gt;Inserting the memo-text is an important way to identify a transaction recipient beyond a wallet address. Failure to do so will result in a failed payment. Please also keep in mind that an additional Transaction fee of 0.1 {info[&#39;thecurrency&#39;]} will automatically occurs per transaction.&lt;/h5&gt;
        &#34;&#34;&#34;

        return msg_text, qr_code

    def test_managed_domain(self, gateway_id, managed_domain, pool_id, gateway=None):
        gateway = gateway or self._explorer.gateway.get(gateway_id)
        subdomain = f&#34;{uuid.uuid4().hex}.{managed_domain}&#34;
        addresses = [j.sals.nettools.get_host_by_name(gateway.dns_nameserver[0])]
        subdomain_id = self.create_subdomain(pool_id, gateway_id, subdomain, addresses)
        success = self.wait_workload(subdomain_id)
        if not success:
            return False
        try:
            j.sals.nettools.get_host_by_name(subdomain)
        except Exception as e:
            j.logger.error(f&#34;managed domain test failed for {managed_domain} due to error {str(e)}&#34;)
            j.sals.zos.get().workloads.decomission(subdomain_id)
            return False
        j.sals.zos.get().workloads.decomission(subdomain_id)
        return True

    def block_managed_domain(self, managed_domain):
        count = j.core.db.hincrby(DOMAINS_COUNT_KEY, managed_domain)
        expiration = count * DOMAINS_DISALLOW_EXPIRATION
        domain_key = f&#34;{DOMAINS_DISALLOW_PREFIX}:{managed_domain}&#34;
        j.core.db.set(domain_key, expiration, ex=expiration)

    def unblock_managed_domain(self, managed_domain, reset=True):
        domain_key = f&#34;{DOMAINS_DISALLOW_PREFIX}:{managed_domain}&#34;
        j.core.db.delete(domain_key)
        if reset:
            j.core.db.hdel(DOMAINS_COUNT_KEY, managed_domain)

    def list_blocked_managed_domains(self):
        blocked_domains_keys = j.core.db.keys(f&#34;{DOMAINS_DISALLOW_PREFIX}:*&#34;)
        failure_count_dict = j.core.db.hgetall(DOMAINS_COUNT_KEY)
        blocked_domains_values = j.core.db.mget(blocked_domains_keys)
        result = {}
        for idx, key in enumerate(blocked_domains_keys):
            key = key[len(DOMAINS_DISALLOW_PREFIX) + 1 :]
            node_id = key.decode()
            expiration = int(blocked_domains_values[idx])
            failure_count = int(failure_count_dict[key])
            result[node_id] = {&#34;expiration&#34;: expiration, &#34;failure_count&#34;: failure_count}
        return result


deployer = ChatflowDeployer()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="jumpscale.sals.reservation_chatflow.deployer.ChatflowDeployer"><code class="flex name class">
<span>class <span class="ident">ChatflowDeployer</span></span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">class ChatflowDeployer:
    def __init__(self):
        self.workloads = defaultdict(
            lambda: defaultdict(lambda: defaultdict(list))
        )  # Next Action: workload_type: pool_id: [workloads]

    @property
    def _explorer(self):
        return j.core.identity.me.explorer

    def load_user_workloads(self, next_action=NextAction.DEPLOY):
        all_workloads = j.sals.zos.get().workloads.list(j.core.identity.me.tid, next_action)
        self.workloads.pop(next_action, None)
        for workload in all_workloads:
            if workload.info.metadata:
                workload.info.metadata = self.decrypt_metadata(workload.info.metadata)
                try:
                    j.data.serializers.json.loads(workload.info.metadata)
                except:
                    workload.info.metadata = &#34;{}&#34;
            else:
                workload.info.metadata = &#34;{}&#34;
            self.workloads[workload.info.next_action][workload.info.workload_type][workload.info.pool_id].append(
                workload
            )

    def decrypt_metadata(self, encrypted_metadata):
        try:
            pk = j.core.identity.me.nacl.signing_key.verify_key.to_curve25519_public_key()
            sk = j.core.identity.me.nacl.signing_key.to_curve25519_private_key()
            box = Box(sk, pk)
            return box.decrypt(base64.b85decode(encrypted_metadata.encode())).decode()
        except:
            return &#34;{}&#34;

    def list_networks(self, next_action=NextAction.DEPLOY, sync=True):
        if sync:
            self.load_user_workloads(next_action=next_action)
        networks = {}  # name: last child network resource
        for pool_id in self.workloads[next_action][WorkloadType.Network_resource]:
            for workload in self.workloads[next_action][WorkloadType.Network_resource][pool_id]:
                networks[workload.name] = workload
        all_workloads = []
        for pools_workloads in self.workloads[next_action].values():
            for pool_id, workload_list in pools_workloads.items():
                all_workloads += workload_list
        network_views = {}
        nodes = {node.node_id for node in j.sals.zos.get()._explorer.nodes.list()}
        for network_name in networks:
            network_views[network_name] = NetworkView(network_name, all_workloads, nodes)
        return network_views

    def _pool_form(self, bot):
        form = bot.new_form()
        cu = form.int_ask(&#34;Required Amount of Compute Unit (CU)&#34;, required=True, min=0, default=0)
        su = form.int_ask(&#34;Required Amount of Storage Unit (SU)&#34;, required=True, min=0, default=0)
        time_unit = form.drop_down_choice(
            &#34;Please choose the duration unit&#34;, [&#34;Day&#34;, &#34;Month&#34;, &#34;Year&#34;], required=True, default=&#34;Month&#34;
        )
        ttl = form.int_ask(&#34;Please specify the pools time-to-live&#34;, required=True, min=1, default=0)
        form.ask(
            &#34;&#34;&#34;- Compute Unit (CU) is the amount of data processing power specified as the number of virtual CPU cores (logical CPUs) and RAM (Random Access Memory).
- Storage Unit (SU) is the size of data storage capacity.

You can get more detail information about clout units on the wiki: &lt;a href=&#34;https://wiki.threefold.io/#/grid_concepts?id=cloud-units-v4&#34; target=&#34;_blank&#34;&gt;Cloud units details&lt;/a&gt;.


The way this form works is you define how much cloud units you want to reserve and define for how long you would like the selected amount of cloud units.
As an example, if you want to be able to run some workloads that consumes `5CU` and `10SU` worth of capacity for `2 month`, you would specify:

- CU: 5
- SU: 10
- Duration unit: Month
- Duration: 2
&#34;&#34;&#34;,
            md=True,
        )
        ttl = ttl.value
        time_unit = time_unit.value
        if time_unit == &#34;Day&#34;:
            days = 1
        elif time_unit == &#34;Month&#34;:
            days = 30
        elif time_unit == &#34;Year&#34;:
            days = 365
        else:
            raise j.exceptions.Input(&#34;Invalid duration unit&#34;)

        cu = cu.value * 60 * 60 * 24 * days * ttl
        su = su.value * 60 * 60 * 24 * days * ttl
        return (cu, su, [&#34;TFT&#34;])

    def create_pool(self, bot):
        cu, su, currencies = self._pool_form(bot)
        all_farms = self._explorer.farms.list()
        available_farms = {}
        farms_by_name = {}
        for farm in all_farms:
            farm_assets = [w.asset for w in farm.wallet_addresses]
            if currencies[0] not in farm_assets:
                continue
            res = self.check_farm_capacity(farm.name, currencies)
            available = res[0]
            resources = res[1:]
            if available:
                available_farms[farm.name] = resources
                farms_by_name[farm.name] = farm
        farm_messages = {}
        for farm in available_farms:
            farm_assets = [w.asset for w in farms_by_name[farm].wallet_addresses]
            if currencies[0] not in farm_assets:
                continue
            resources = available_farms[farm]
            farm_obj = farms_by_name[farm]
            location_list = [farm_obj.location.continent, farm_obj.location.country, farm_obj.location.city]
            location = &#34;-&#34;.join([info for info in location_list if info])
            if location:
                location = f&#34; location: {location}&#34;
            farm_messages[
                f&#34;{farm.capitalize()}{location}: CRU: {resources[0]} SRU: {resources[1]} HRU: {resources[2]} MRU {resources[3]}&#34;
            ] = farm
        if not farm_messages:
            raise StopChatFlow(f&#34;There are no farms available that the support {currencies[0]} currency&#34;)
        selected_farm = bot.drop_down_choice(
            &#34;Please choose a farm to reserve capacity from. By reserving IT Capacity, you are purchasing the capacity from one of the farms. The available Resource Units (RU): CRU, MRU, HRU, SRU, NRU are displayed for you to make a more-informed decision on farm selection. &#34;,
            list(farm_messages.keys()),
            required=True,
        )
        farm = farm_messages[selected_farm]
        try:
            pool_info = j.sals.zos.get().pools.create(cu, su, farm, currencies)
        except Exception as e:
            raise StopChatFlow(f&#34;failed to reserve pool.\n{str(e)}&#34;)
        qr_code = self.show_payment(pool_info, bot)
        self.wait_pool_payment(bot, pool_info.reservation_id, 10, qr_code, trigger_cus=cu, trigger_sus=su)
        return pool_info

    def extend_pool(self, bot, pool_id):
        cu, su, currencies = self._pool_form(bot)
        currencies = [&#34;TFT&#34;]
        try:
            pool_info = j.sals.zos.get().pools.extend(pool_id, cu, su, currencies=currencies)
        except Exception as e:
            raise StopChatFlow(f&#34;failed to extend pool.\n{str(e)}&#34;)
        qr_code = self.show_payment(pool_info, bot)
        pool = j.sals.zos.get().pools.get(pool_id)
        trigger_cus = pool.cus + (cu * 0.75) if cu else 0
        trigger_sus = pool.sus + (su * 0.75) if su else 0
        self.wait_pool_payment(bot, pool_id, 10, qr_code, trigger_cus=trigger_cus, trigger_sus=trigger_sus)
        return pool_info

    def check_farm_capacity(self, farm_name, currencies=None, sru=None, cru=None, mru=None, hru=None, ip_version=None):
        node_filter = None
        if ip_version and ip_version not in [&#34;IPv4&#34;, &#34;IPv6&#34;]:
            raise j.exceptions.Runtime(f&#34;{ip_version} is not a valid IP Version&#34;)
        else:
            if ip_version == &#34;IPv4&#34;:
                node_filter = j.sals.zos.get().nodes_finder.filter_public_ip4
            elif ip_version == &#34;IPv6&#34;:
                node_filter = j.sals.zos.get().nodes_finder.filter_public_ip6
        currencies = currencies or []
        farm_nodes = j.sals.zos.get().nodes_finder.nodes_search(farm_name=farm_name)
        available_cru = 0
        available_sru = 0
        available_mru = 0
        available_hru = 0
        running_nodes = 0
        blocked_nodes = j.sals.reservation_chatflow.reservation_chatflow.list_blocked_nodes()
        access_node = None
        for node in farm_nodes:
            if &#34;FreeTFT&#34; in currencies and not node.free_to_use:
                continue
            if not j.sals.zos.get().nodes_finder.filter_is_up(node):
                continue
            if node.node_id in blocked_nodes:
                continue
            if not access_node and ip_version and node_filter(node):
                access_node = node
            running_nodes += 1
            available_cru += node.total_resources.cru - node.used_resources.cru
            available_sru += node.total_resources.sru - node.used_resources.sru
            available_mru += node.total_resources.mru - node.used_resources.mru
            available_hru += node.total_resources.hru - node.used_resources.hru

        if not running_nodes:
            return False, available_cru, available_sru, available_mru, available_hru
        if sru and available_sru &lt; sru:
            return False, available_cru, available_sru, available_mru, available_hru
        if cru and available_cru &lt; cru:
            return False, available_cru, available_sru, available_mru, available_hru
        if mru and available_mru &lt; mru:
            return False, available_cru, available_sru, available_mru, available_hru
        if hru and available_hru &lt; hru:
            return False, available_cru, available_sru, available_mru, available_hru
        if ip_version and not access_node:
            return False, available_cru, available_sru, available_mru, available_hru
        return True, available_cru, available_sru, available_mru, available_hru

    def show_payment(self, pool, bot):
        escrow_info = pool.escrow_information
        resv_id = pool.reservation_id
        escrow_address = escrow_info.address
        escrow_asset = escrow_info.asset
        total_amount = escrow_info.amount
        if not total_amount:
            return
        total_amount_dec = Decimal(total_amount) / Decimal(1e7)
        total_amount = &#34;{0:f}&#34;.format(total_amount_dec)

        wallets = j.sals.reservation_chatflow.reservation_chatflow.list_wallets()
        wallet_names = []
        for w in wallets.keys():
            wallet = j.clients.stellar.get(w)
            try:
                balances = wallet.get_balance().balances
            except:
                continue
            for balance in balances:
                if balance.asset_code in escrow_asset:
                    if float(balance.balance) &gt; float(total_amount):
                        wallet_names.append(w)
                    else:
                        break
        wallet_names.append(&#34;External Wallet (QR Code)&#34;)
        self.msg_payment_info, qr_code = self.get_qr_code_payment_info(pool)
        message = f&#34;&#34;&#34;
        &lt;h3&gt;Billing details:&lt;/h3&gt;&lt;br&gt;
        {self.msg_payment_info}
        &lt;br&gt;&lt;hr&gt;&lt;br&gt;
        &lt;h3&gt; Choose a wallet name to use for payment or proceed with payment through External wallet (QR Code) &lt;/h3&gt;
        &#34;&#34;&#34;
        result = bot.single_choice(message, wallet_names, html=True, required=True)
        if result == &#34;External Wallet (QR Code)&#34;:
            msg_text = f&#34;&#34;&#34;
            &lt;h3&gt;Make a Payment&lt;/h3&gt;
            Scan the QR code with your wallet (do not change the message) or enter the information below manually and proceed with the payment. Make sure to put p-{resv_id} as memo_text value.

            {self.msg_payment_info}

            &#34;&#34;&#34;
            bot.qrcode_show(data=qr_code, msg=msg_text, scale=4, update=True, html=True)
        else:
            wallet = wallets[result]
            wallet.transfer(
                destination_address=escrow_address, amount=total_amount, asset=escrow_asset, memo_text=f&#34;p-{resv_id}&#34;
            )
            return None
        return qr_code

    def list_pools(self, cu=None, su=None):
        all_pools = [p for p in j.sals.zos.get().pools.list() if p.node_ids]

        available_pools = {}
        for pool in all_pools:
            hidden = False
            name = &#34;&#34;
            if f&#34;pool_{pool.pool_id}&#34; in pool_factory.list_all():
                local_config = pool_factory.get(f&#34;pool_{pool.pool_id}&#34;)
                hidden = local_config.hidden
                name = local_config.name
            if hidden:
                continue
            res = self.check_pool_capacity(pool, cu, su)
            available = res[0]
            if available:
                resources = res[1:]
                if name:
                    resources += (name,)
                available_pools[pool.pool_id] = resources
        return available_pools

    def check_pool_capacity(self, pool, cu=None, su=None):
        available_su = pool.sus
        available_cu = pool.cus
        if pool.empty_at &lt; 0:
            return False, 0, 0
        if cu and available_cu &lt; cu:
            return False, available_cu, available_su
        if su and available_su &lt; su:
            return False, available_cu, available_su
        if (cu or su) and pool.empty_at &lt; j.data.time.now().timestamp:
            return False, 0, 0
        return True, available_cu, available_su

    def select_pool(
        self, bot, cu=None, su=None, sru=None, mru=None, hru=None, cru=None, available_pools=None, workload_name=None
    ):
        if j.config.get(&#34;OVER_PROVISIONING&#34;):
            cru = 0
            mru = 0
        available_pools = available_pools or self.list_pools(cu, su)
        if not available_pools:
            raise StopChatFlow(&#34;no available pools with enough capacity for your workload&#34;)
        pool_messages = {}
        for pool in available_pools:
            nodes = j.sals.zos.get().nodes_finder.nodes_by_capacity(pool_id=pool, sru=sru, mru=mru, hru=hru, cru=cru)
            if not nodes:
                continue

            pool_msg = f&#34;Pool: {pool} cu: {available_pools[pool][0]} su:&#34; f&#34; {available_pools[pool][1]}&#34;
            if len(available_pools[pool]) &gt; 2:
                pool_msg += f&#34; Name: {available_pools[pool][2]}&#34;
            pool_messages[pool_msg] = pool
        if not pool_messages:
            raise StopChatFlow(&#34;no available resources in the farms bound to your pools&#34;)
        msg = &#34;Please select a pool&#34;
        if workload_name:
            msg += f&#34; for {workload_name}&#34;
        pool = bot.drop_down_choice(msg, list(pool_messages.keys()), required=True)
        return pool_messages[pool]

    def get_pool_farm_id(self, pool_id=None, pool=None):
        pool = pool or j.sals.zos.get().pools.get(pool_id)
        pool_id = pool.pool_id
        if not pool.node_ids:
            raise StopChatFlow(f&#34;Pool {pool_id} doesn&#39;t contain any nodes&#34;)
        farm_id = None
        while not farm_id:
            for node_id in pool.node_ids:
                try:
                    node = self._explorer.nodes.get(node_id)
                    farm_id = node.farm_id
                    break
                except requests.exceptions.HTTPError:
                    continue
            return farm_id or -1

    def ask_name(self, bot, msg=None):
        msg = (
            msg
            or &#34;Please enter a name for your workload (Can be used to prepare domain for you and needed to track your solution on the grid)&#34;
        )
        name = bot.string_ask(msg, required=True, field=&#34;name&#34;, is_identifier=True)

        return name

    def ask_email(self, bot):
        valid = False
        email = None
        regex = r&#34;^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$&#34;
        while not valid:
            email = bot.string_ask(&#34;Please enter your email address&#34;, required=True, field=&#34;email&#34;)
            valid = re.search(regex, email) is not None
            if not valid:
                bot.md_show(&#34;Please enter a valid email address&#34;)
        return email

    def ask_ipv6(self, bot, workload_name=None):
        workload_name = workload_name or &#34;your workload&#34;
        ipv6 = bot.single_choice(
            f&#34;Do you want to assign a global IPv6 address to {workload_name}?&#34;,
            options=[&#34;YES&#34;, &#34;NO&#34;],
            default=&#34;NO&#34;,
            required=True,
        )
        return ipv6 == &#34;YES&#34;

    def encrypt_metadata(self, metadata):
        if isinstance(metadata, dict):
            metadata = j.data.serializers.json.dumps(metadata)
        pk = j.core.identity.me.nacl.signing_key.verify_key.to_curve25519_public_key()
        sk = j.core.identity.me.nacl.signing_key.to_curve25519_private_key()
        box = Box(sk, pk)
        encrypted_metadata = base64.b85encode(box.encrypt(metadata.encode())).decode()
        return encrypted_metadata

    def deploy_network(self, name, access_node, ip_range, ip_version, pool_id, **metadata):
        network = j.sals.zos.get().network.create(ip_range, name)
        node_subnets = netaddr.IPNetwork(ip_range).subnet(24)
        network_config = dict()
        use_ipv4 = ip_version == &#34;IPv4&#34;

        j.sals.zos.get().network.add_node(network, access_node.node_id, str(next(node_subnets)), pool_id)
        wg_quick = j.sals.zos.get().network.add_access(
            network, access_node.node_id, str(next(node_subnets)), ipv4=use_ipv4
        )

        network_config[&#34;wg&#34;] = wg_quick
        j.sals.fs.mkdir(f&#34;{j.core.dirs.CFGDIR}/wireguard/&#34;)
        j.sals.fs.write_file(f&#34;{j.core.dirs.CFGDIR}/{name}.conf&#34;, f&#34;{wg_quick}&#34;)

        ids = []
        parent_id = None
        for workload in network.network_resources:
            workload.info.description = j.data.serializers.json.dumps({&#34;parent_id&#34;: parent_id})
            metadata[&#34;parent_network&#34;] = parent_id
            workload.info.metadata = self.encrypt_metadata(metadata)
            ids.append(j.sals.zos.get().workloads.deploy(workload))
            parent_id = ids[-1]
        network_config[&#34;ids&#34;] = ids
        network_config[&#34;rid&#34;] = ids[0]
        return network_config

    def add_access(
        self, network_name, network_view=None, node_id=None, pool_id=None, use_ipv4=True, bot=None, **metadata
    ):
        network_view = network_view or NetworkView(network_name)
        network, wg = network_view.add_access(node_id, use_ipv4, pool_id)
        result = {&#34;ids&#34;: [], &#34;wg&#34;: wg}
        node_workloads = {}
        # deploy only latest resource generated by zos sal for each node
        for workload in network.network_resources:
            node_workloads[workload.info.node_id] = workload

        dry_run_name = uuid.uuid4().hex
        with NetworkView.dry_run_context(dry_run_name):
            network_view.dry_run(
                dry_run_name,
                list(node_workloads.keys()),
                [w.info.pool_id for w in node_workloads.values()],
                bot,
                breaking_node_ids=[node_id],
            )

        parent_id = network_view.network_workloads[-1].id
        for resource in node_workloads.values():
            resource.info.reference = &#34;&#34;
            resource.info.description = j.data.serializers.json.dumps({&#34;parent_id&#34;: parent_id})
            metadata[&#34;parent_network&#34;] = parent_id
            resource.info.metadata = self.encrypt_metadata(metadata)
            result[&#34;ids&#34;].append(j.sals.zos.get().workloads.deploy(resource))
            parent_id = result[&#34;ids&#34;][-1]
        result[&#34;rid&#34;] = result[&#34;ids&#34;][0]
        return result

    def delete_access(self, network_name, iprange, network_view=None, node_id=None, bot=None, **metadata):
        network_view = network_view or NetworkView(network_name)
        network = network_view.delete_access(iprange, node_id)

        node_workloads = {}
        # deploy only latest resource generated by zos sal for each node
        for workload in network.network_resources:
            node_workloads[workload.info.node_id] = workload
        dry_run_name = uuid.uuid4().hex
        with NetworkView.dry_run_context(dry_run_name):
            network_view.dry_run(
                dry_run_name,
                list(node_workloads.keys()),
                [w.info.pool_id for w in node_workloads.values()],
                bot,
                breaking_node_ids=[node_id],
            )
        parent_id = network_view.network_workloads[-1].id
        result = []
        for resource in node_workloads.values():
            resource.info.reference = &#34;&#34;
            resource.info.description = j.data.serializers.json.dumps({&#34;parent_id&#34;: parent_id})
            metadata[&#34;parent_network&#34;] = parent_id
            resource.info.metadata = self.encrypt_metadata(metadata)
            result.append(j.sals.zos.get().workloads.deploy(resource))
            parent_id = result[-1]
        return result

    def wait_workload(self, workload_id, bot=None, expiry=10, breaking_node_id=None):
        expiry = expiry or 10
        expiration_provisioning = j.data.time.now().timestamp + expiry * 60

        workload = j.sals.zos.get().workloads.get(workload_id)
        if workload.info.workload_type in GATEWAY_WORKLOAD_TYPES:
            node = self._explorer.gateway.get(workload.info.node_id)
        else:
            node = self._explorer.nodes.get(workload.info.node_id)
        # check if the node is up
        if not j.sals.zos.get().nodes_finder.filter_is_up(node):
            cancel = True
            if breaking_node_id and breaking_node_id == node.node_id:
                # if the node is down and it is the same as breaking_node_id
                if workload.info.workload_type == WorkloadType.Network_resource:
                    # if the workload is a newtork we don&#39;t cancel it
                    cancel = False
            # the node is down but it is not a breaking node_id
            elif workload.info.workload_type == WorkloadType.Network_resource:
                # if the workload is network we can overlook it
                return True
            if cancel:
                j.sals.reservation_chatflow.solutions.cancel_solution([workload_id])
            raise StopChatFlow(f&#34;Workload {workload_id} failed to deploy because the node is down {node.node_id}&#34;)

        # wait for workload
        while True:
            workload = j.sals.zos.get().workloads.get(workload_id)
            remaning_time = j.data.time.get(expiration_provisioning).humanize(granularity=[&#34;minute&#34;, &#34;second&#34;])
            if bot:
                deploying_message = f&#34;&#34;&#34;\
                # Deploying...

                &lt;br /&gt;Workload ID: {workload_id}


                Deployment should take around 2 to 3 minutes, but might take longer and will be cancelled if it is not successful in 10 mins
                &#34;&#34;&#34;
                bot.md_show_update(dedent(deploying_message), md=True)
            if workload.info.result.workload_id:
                success = workload.info.result.state.value == 1
                if not success:
                    error_message = workload.info.result.message
                    msg = f&#34;Workload {workload.id} failed to deploy due to error {error_message}. For more details: {j.core.identity.me.explorer_url}/reservations/workloads/{workload.id}&#34;
                    j.logger.error(msg)
                    j.tools.alerthandler.alert_raise(
                        appname=&#34;chatflows&#34;, category=&#34;internal_errors&#34;, message=msg, alert_type=&#34;exception&#34;
                    )
                elif workload.info.workload_type != WorkloadType.Network_resource:
                    j.sals.reservation_chatflow.reservation_chatflow.unblock_node(workload.info.node_id)
                return success
            if expiration_provisioning &lt; j.data.time.get().timestamp:
                j.sals.reservation_chatflow.reservation_chatflow.block_node(workload.info.node_id)
                if workload.info.workload_type != WorkloadType.Network_resource:
                    j.sals.reservation_chatflow.solutions.cancel_solution([workload_id])
                elif breaking_node_id and workload.info.node_id != breaking_node_id:
                    return True
                raise StopChatFlow(f&#34;Workload {workload_id} failed to deploy in time&#34;)
            gevent.sleep(1)

    def add_network_node(self, name, node, pool_id, network_view=None, bot=None, **metadata):
        if not network_view:
            network_view = NetworkView(name)
        network = network_view.add_node(node, pool_id)
        if not network:
            return
        parent_id = network_view.network_workloads[-1].id
        ids = []
        node_workloads = {}
        # deploy only latest resource generated by zos sal for each node
        for workload in network.network_resources:
            node_workloads[workload.info.node_id] = workload
        dry_run_name = uuid.uuid4().hex
        with NetworkView.dry_run_context(dry_run_name):
            network_view.dry_run(
                dry_run_name,
                list(node_workloads.keys()),
                [w.info.pool_id for w in node_workloads.values()],
                bot,
                breaking_node_ids=[node.node_id],
            )
        for workload in node_workloads.values():
            workload.info.reference = &#34;&#34;
            workload.info.description = j.data.serializers.json.dumps({&#34;parent_id&#34;: parent_id})
            metadata[&#34;parent_network&#34;] = parent_id
            workload.info.metadata = self.encrypt_metadata(metadata)
            ids.append(j.sals.zos.get().workloads.deploy(workload))
            parent_id = ids[-1]
        return {&#34;ids&#34;: ids, &#34;rid&#34;: ids[0]}

    def select_network(self, bot, network_views=None):
        network_views = network_views or self.list_networks()
        if not network_views:
            raise StopChatFlow(f&#34;You don&#39;t have any deployed network.&#34;)
        network_name = bot.single_choice(&#34;Please select a network&#34;, list(network_views.keys()), required=True)
        return network_views[network_name]

    def deploy_volume(self, pool_id, node_id, size, volume_type=DiskType.SSD, **metadata):
        volume = j.sals.zos.get().volume.create(node_id, pool_id, size, volume_type)
        if metadata:
            volume.info.metadata = self.encrypt_metadata(metadata)
        return j.sals.zos.get().workloads.deploy(volume)

    def deploy_container(
        self,
        pool_id,
        node_id,
        network_name,
        ip_address,
        flist,
        env=None,
        cpu=1,
        memory=1024,
        disk_size=256,
        disk_type=DiskType.SSD,
        entrypoint=&#34;&#34;,
        interactive=False,
        secret_env=None,
        volumes=None,
        log_config=None,
        public_ipv6=False,
        **metadata,
    ):
        &#34;&#34;&#34;
        volumes: dict {&#34;mountpoint (/)&#34;: volume_id}
        log_Config: dict. keys (&#34;channel_type&#34;, &#34;channel_host&#34;, &#34;channel_port&#34;, &#34;channel_name&#34;)
        &#34;&#34;&#34;
        env = env or {}
        encrypted_secret_env = {}
        if secret_env:
            for key, val in secret_env.items():
                encrypted_secret_env[key] = j.sals.zos.get().container.encrypt_secret(node_id, val)
        container = j.sals.zos.get().container.create(
            node_id,
            network_name,
            ip_address,
            flist,
            pool_id,
            env,
            cpu,
            memory,
            disk_size,
            entrypoint,
            interactive,
            encrypted_secret_env,
            public_ipv6=public_ipv6,
        )
        if volumes:
            for mount_point, vol_id in volumes.items():
                j.sals.zos.get().volume.attach_existing(container, f&#34;{vol_id}-1&#34;, mount_point)
        if metadata:
            container.info.metadata = self.encrypt_metadata(metadata)
        if log_config:
            j.sals.zos.get().container.add_logs(container, **log_config)
        return j.sals.zos.get().workloads.deploy(container)

    def ask_container_resources(
        self,
        bot,
        cpu=True,
        memory=True,
        disk_size=True,
        disk_type=False,
        default_cpu=1,
        default_memory=1024,
        default_disk_size=256,
        default_disk_type=&#34;SSD&#34;,
    ):
        form = bot.new_form()
        if cpu:
            cpu_answer = form.int_ask(&#34;Please specify how many CPUs&#34;, default=default_cpu, required=True, min=1)
        if memory:
            memory_answer = form.int_ask(
                &#34;Please specify how much memory (in MB)&#34;, default=default_memory, required=True, min=1024
            )
        if disk_size:
            disk_size_answer = form.int_ask(
                &#34;Please specify the size of root filesystem (in MB)&#34;, default=default_disk_size, required=True
            )
        if disk_type:
            disk_type_answer = form.single_choice(
                &#34;Please choose the root filesystem disktype&#34;, [&#34;SSD&#34;, &#34;HDD&#34;], default=default_disk_type, required=True
            )
        form.ask()
        resources = {}
        if cpu:
            resources[&#34;cpu&#34;] = cpu_answer.value
        if memory:
            resources[&#34;memory&#34;] = memory_answer.value
        if disk_size:
            resources[&#34;disk_size&#34;] = disk_size_answer.value
        if disk_type:
            resources[&#34;disk_type&#34;] = DiskType[disk_type_answer.value]
        return resources

    def ask_container_logs(self, bot, solution_name=None):
        logs_config = {}
        form = bot.new_form()
        channel_type = form.string_ask(&#34;Please add the channel type&#34;, default=&#34;redis&#34;, required=True)
        channel_host = form.string_ask(&#34;Please add the IP address where the logs will be output to&#34;, required=True)
        channel_port = form.int_ask(&#34;Please add the port available where the logs will be output to&#34;, required=True)
        channel_name = form.string_ask(
            &#34;Please add the channel name to be used. The channels will be in the form&#34; &#34; NAME-stdout and NAME-stderr&#34;,
            default=solution_name,
            required=True,
        )
        form.ask()
        logs_config[&#34;channel_type&#34;] = channel_type.value
        logs_config[&#34;channel_host&#34;] = channel_host.value
        logs_config[&#34;channel_port&#34;] = channel_port.value
        logs_config[&#34;channel_name&#34;] = channel_name.value
        return logs_config

    def schedule_container(self, pool_id, cru=None, sru=None, mru=None, hru=None, ip_version=None):
        query = {&#34;cru&#34;: cru, &#34;sru&#34;: sru, &#34;mru&#34;: mru, &#34;hru&#34;: hru, &#34;ip_version&#34;: ip_version}
        return j.sals.reservation_chatflow.reservation_chatflow.get_nodes(1, pool_ids=[pool_id], **query)[0]

    def ask_container_placement(
        self,
        bot,
        pool_id,
        cru=None,
        sru=None,
        mru=None,
        hru=None,
        ip_version=None,
        free_to_use=False,
        workload_name=None,
    ):
        if not workload_name:
            workload_name = &#34;your workload&#34;
        automatic_choice = bot.single_choice(
            &#34;Do you want to automatically select a node for deployment for&#34; f&#34; {workload_name}?&#34;,
            [&#34;YES&#34;, &#34;NO&#34;],
            default=&#34;YES&#34;,
            required=True,
        )
        if automatic_choice == &#34;YES&#34;:
            return None
        if j.config.get(&#34;OVER_PROVISIONING&#34;):
            cru = 0
            mru = 0
        nodes = j.sals.zos.get().nodes_finder.nodes_by_capacity(pool_id=pool_id, cru=cru, sru=sru, mru=mru, hru=hru)
        nodes = list(nodes)
        nodes = j.sals.reservation_chatflow.reservation_chatflow.filter_nodes(nodes, free_to_use, ip_version)
        blocked_nodes = j.sals.reservation_chatflow.reservation_chatflow.list_blocked_nodes()
        node_messages = {node.node_id: node for node in nodes if node.node_id not in blocked_nodes}
        if not node_messages:
            raise StopChatFlow(&#34;Failed to find resources for this reservation&#34;)
        node_id = bot.drop_down_choice(
            f&#34;Please choose the node you want to deploy {workload_name} on&#34;, list(node_messages.keys()), required=True
        )
        return node_messages[node_id]

    def calculate_capacity_units(self, cru=0, mru=0, sru=0, hru=0):
        &#34;&#34;&#34;
        return cu, su
        &#34;&#34;&#34;
        cu = min((mru - 1) / 4, cru * 4 / 2)
        su = (hru / 1000 + sru / 100 / 2) / 1.2
        if cu &lt; 0:
            cu = 0
        if su &lt; 0:
            su = 0
        return cu, su

    def get_network_view(self, network_name, workloads=None):
        return NetworkView(network_name, workloads)

    def delegate_domain(self, pool_id, gateway_id, domain_name, **metadata):
        domain_delegate = j.sals.zos.get().gateway.delegate_domain(gateway_id, domain_name, pool_id)
        if metadata:
            domain_delegate.info.metadata = self.encrypt_metadata(metadata)
        return j.sals.zos.get().workloads.deploy(domain_delegate)

    def deploy_kubernetes_master(
        self, pool_id, node_id, network_name, cluster_secret, ssh_keys, ip_address, size=1, **metadata
    ):
        master = j.sals.zos.get().kubernetes.add_master(
            node_id, network_name, cluster_secret, ip_address, size, ssh_keys, pool_id
        )
        master.info.description = j.data.serializers.json.dumps({&#34;role&#34;: &#34;master&#34;})
        if metadata:
            master.info.metadata = self.encrypt_metadata(metadata)
        return j.sals.zos.get().workloads.deploy(master)

    def deploy_kubernetes_worker(
        self, pool_id, node_id, network_name, cluster_secret, ssh_keys, ip_address, master_ip, size=1, **metadata
    ):
        worker = j.sals.zos.get().kubernetes.add_worker(
            node_id, network_name, cluster_secret, ip_address, size, master_ip, ssh_keys, pool_id
        )
        worker.info.description = j.data.serializers.json.dumps({&#34;role&#34;: &#34;worker&#34;})
        if metadata:
            worker.info.metadata = self.encrypt_metadata(metadata)
        return j.sals.zos.get().workloads.deploy(worker)

    def deploy_kubernetes_cluster(
        self,
        pool_id,
        node_ids,
        network_name,
        cluster_secret,
        ssh_keys,
        size=1,
        ip_addresses=None,
        slave_pool_ids=None,
        **metadata,
    ):
        &#34;&#34;&#34;
        deplou k8s cluster with the same number of nodes as specifed in node_ids

        Args:
            pool_id: this one is always used for master.
            node_ids: list() of node ids to deploy on. first node_id is used for master reservation
            ip_addresses: if specified it will be mapped 1-1 with node_ids for workloads. if not specified it will choose any free_ip from the node
            slave_pool_ids: if specified, k8s workers will deployed on each of these pools respectively. if empty it will use the master pool_id

        Return:
            list: [{&#34;node_id&#34;: &#34;ip_address&#34;}, ...] first dict is master&#39;s result
        &#34;&#34;&#34;
        slave_pool_ids = slave_pool_ids or ([pool_id] * (len(node_ids) - 1))
        pool_ids = [pool_id] + slave_pool_ids
        result = []  # [{&#34;node_id&#34;: id,  &#34;ip_address&#34;: ip, &#34;reservation_id&#34;: 16}] first dict is master&#39;s result
        if ip_addresses and len(ip_addresses) != len(node_ids):
            raise StopChatFlow(&#34;length of ips != node_ids&#34;)

        if not ip_addresses:
            # get free_ips for the nodes
            ip_addresses = []
            for i in range(len(node_ids)):
                node_id = node_ids[i]
                pool_id = pool_ids[i]
                node = self._explorer.nodes.get(node_id)
                res = self.add_network_node(network_name, node, pool_id)
                if res:
                    for wid in res[&#34;ids&#34;]:
                        success = self.wait_workload(wid, breaking_node_id=node.node_id)
                        if not success:
                            raise StopChatFlow(f&#34;Failed to add node {node.node_id} to network {wid}&#34;)
                network_view = NetworkView(network_name)
                address = network_view.get_free_ip(node)
                if not address:
                    raise StopChatFlow(f&#34;No free IPs for network {network_name} on the specifed node&#34; f&#34; {node_id}&#34;)
                ip_addresses.append(address)

        # deploy_master
        master_ip = ip_addresses[0]
        master_resv_id = self.deploy_kubernetes_master(
            pool_ids[0], node_ids[0], network_name, cluster_secret, ssh_keys, master_ip, size, **metadata
        )
        result.append({&#34;node_id&#34;: node_ids[0], &#34;ip_address&#34;: master_ip, &#34;reservation_id&#34;: master_resv_id})
        for i in range(1, len(node_ids)):
            node_id = node_ids[i]
            pool_id = pool_ids[i]
            ip_address = ip_addresses[i]
            resv_id = self.deploy_kubernetes_worker(
                pool_id, node_id, network_name, cluster_secret, ssh_keys, ip_address, master_ip, size, **metadata
            )
            result.append({&#34;node_id&#34;: node_id, &#34;ip_address&#34;: ip_address, &#34;reservation_id&#34;: resv_id})
        return result

    def ask_multi_pool_placement(
        self, bot, number_of_nodes, resource_query_list=None, pool_ids=None, workload_names=None, ip_version=None
    ):
        &#34;&#34;&#34;
        Ask and schedule workloads accross multiple pools

        Args:
            bot: chatflow object
            number_of_nodes: number of required nodes for deployment
            resource_query_list: list of query dicts {&#34;cru&#34;: 1, &#34;sru&#34;: 2, &#34;mru&#34;: 1, &#34;hru&#34;: 1}. if specified it must be same length as number_of_nodes
            pool_ids: if specfied it will limit the pools shown in the chatflow to only these pools
            workload_names: if specified they will shown when asking the user for node selection for each workload. if specified it must be same length as number_of_nodes

        Returns:
            ([], []): first list contains the selected node objects. second list contains selected pool ids
        &#34;&#34;&#34;
        resource_query_list = resource_query_list or [dict()] * number_of_nodes
        workload_names = workload_names or [None] * number_of_nodes
        if len(resource_query_list) != number_of_nodes:
            raise StopChatFlow(&#34;resource query_list must be same length as number of nodes&#34;)
        if len(workload_names) != number_of_nodes:
            raise StopChatFlow(&#34;workload_names must be same length as number of nodes&#34;)

        pools = self.list_pools()
        if pool_ids:
            filtered_pools = {}
            for pool_id in pools:
                if pool_id in pool_ids:
                    filtered_pools[pool_id] = pools[pool_id]
            pools = filtered_pools
        selected_nodes = []
        selected_pool_ids = []
        for i in range(number_of_nodes):
            cu, su = self.calculate_capacity_units(**resource_query_list[i])
            pool_choices = {}
            for p in pools:
                if pools[p][0] &lt; cu or pools[p][1] &lt; su:
                    continue
                nodes = j.sals.zos.get().nodes_finder.nodes_by_capacity(pool_id=p, **resource_query_list[i])
                if not nodes:
                    continue
                pool_choices[p] = pools[p]
            pool_id = self.select_pool(bot, available_pools=pool_choices, workload_name=workload_names[i], cu=cu, su=su)
            node = self.ask_container_placement(
                bot, pool_id, workload_name=workload_names[i], ip_version=ip_version, **resource_query_list[i]
            )
            if not node:
                node = self.schedule_container(pool_id, ip_version=ip_version, **resource_query_list[i])
            selected_nodes.append(node)
            selected_pool_ids.append(pool_id)
        return selected_nodes, selected_pool_ids

    def list_pool_gateways(self, pool_id):
        &#34;&#34;&#34;
        return dict of gateways where keys are descriptive string of each gateway
        &#34;&#34;&#34;
        pool = j.sals.zos.get().pools.get(pool_id)
        farm_id = self.get_pool_farm_id(pool_id)
        if farm_id &lt; 0:
            raise StopChatFlow(f&#34;no available gateways in pool {pool_id} farm: {farm_id}&#34;)
        gateways = self._explorer.gateway.list(farm_id=farm_id)
        if not gateways:
            raise StopChatFlow(f&#34;no available gateways in pool {pool_id} farm: {farm_id}&#34;)
        result = {}
        for g in gateways:
            if not g.dns_nameserver:
                continue
            if g.node_id not in pool.node_ids:
                continue
            result[f&#34;{g.dns_nameserver[0]} {g.location.continent} {g.location.country}&#34; f&#34; {g.node_id}&#34;] = g
        return result

    def list_all_gateways(self, pool_ids=None):
        &#34;&#34;&#34;
        Args:
            pool_ids: if specified it will only list gateways inside these pools

        Returns:
            dict: {&#34;gateway_message&#34;: {&#34;gateway&#34;: g, &#34;pool&#34;: pool},}
        &#34;&#34;&#34;
        all_gateways = filter(j.sals.zos.get().nodes_finder.filter_is_up, self._explorer.gateway.list())
        if not all_gateways:
            raise StopChatFlow(f&#34;no available gateways&#34;)
        all_pools = [p for p in j.sals.zos.get().pools.list() if p.node_ids]
        available_node_ids = {}  # node_id: pool
        if pool_ids is not None:
            for pool in all_pools:
                if pool.pool_id in pool_ids:
                    available_node_ids.update({node_id: pool for node_id in pool.node_ids})
        else:
            for pool in all_pools:
                available_node_ids.update({node_id: pool for node_id in pool.node_ids})
        result = {}
        for gateway in all_gateways:
            if gateway.node_id in available_node_ids:
                if not gateway.dns_nameserver:
                    continue
                pool = available_node_ids[gateway.node_id]
                hidden = False
                name = &#34;&#34;
                if f&#34;pool_{pool.pool_id}&#34; in pool_factory.list_all():
                    local_config = pool_factory.get(f&#34;pool_{pool.pool_id}&#34;)
                    hidden = local_config.hidden
                    name = local_config.name
                if hidden:
                    continue
                if name:
                    message = (
                        f&#34;Pool: {pool.pool_id} Name: {name} {gateway.dns_nameserver[0]}&#34;
                        f&#34; {gateway.location.continent} {gateway.location.country}&#34;
                        f&#34; {gateway.node_id}&#34;
                    )
                else:
                    message = (
                        f&#34;Pool: {pool.pool_id} {gateway.dns_nameserver[0]}&#34;
                        f&#34; {gateway.location.continent} {gateway.location.country}&#34;
                        f&#34; {gateway.node_id}&#34;
                    )
                result[message] = {&#34;gateway&#34;: gateway, &#34;pool&#34;: pool}
        if not result:
            raise StopChatFlow(f&#34;no gateways available in your pools&#34;)
        return result

    def select_gateway(self, bot, pool_ids=None):
        &#34;&#34;&#34;
        Args:
            pool_ids: if specified it will only list gateways inside these pools

        Returns:
            gateway, pool_objects
        &#34;&#34;&#34;
        gateways = self.list_all_gateways(pool_ids)

        selected = bot.single_choice(&#34;Please select a gateway&#34;, list(gateways.keys()), required=True)
        return gateways[selected][&#34;gateway&#34;], gateways[selected][&#34;pool&#34;]

    def create_ipv6_gateway(self, gateway_id, pool_id, public_key, **metadata):
        if isinstance(public_key, bytes):
            public_key = public_key.decode()
        workload = j.sals.zos.get().gateway.gateway_4to6(gateway_id, public_key, pool_id)
        if metadata:
            workload.info.metadata = self.encrypt_metadata(metadata)
        return j.sals.zos.get().workloads.deploy(workload)

    def deploy_zdb(self, pool_id, node_id, size, mode, password, disk_type=&#34;SSD&#34;, public=False, **metadata):
        workload = j.sals.zos.get().zdb.create(node_id, size, mode, password, pool_id, disk_type, public)
        if metadata:
            workload.info.metadata = self.encrypt_metadata(metadata)
        return j.sals.zos.get().workloads.deploy(workload)

    def create_subdomain(self, pool_id, gateway_id, subdomain, addresses=None, **metadata):
        &#34;&#34;&#34;
        creates an A record pointing to the specified addresses
        if no addresses are specified, the record will point the gateway IP address (used for exposing solutions)
        &#34;&#34;&#34;
        if not addresses:
            gateway = self._explorer.gateway.get(gateway_id)
            addresses = [j.sals.nettools.get_host_by_name(ns) for ns in gateway.dns_nameserver]
        workload = j.sals.zos.get().gateway.sub_domain(gateway_id, subdomain, addresses, pool_id)
        if metadata:
            workload.info.metadata = self.encrypt_metadata(metadata)
        return j.sals.zos.get().workloads.deploy(workload)

    def create_proxy(self, pool_id, gateway_id, domain_name, trc_secret, **metadata):
        &#34;&#34;&#34;
        creates a reverse tunnel on the gateway node
        &#34;&#34;&#34;
        workload = j.sals.zos.get().gateway.tcp_proxy_reverse(gateway_id, domain_name, trc_secret, pool_id)
        if metadata:
            workload.info.metadata = self.encrypt_metadata(metadata)
        return j.sals.zos.get().workloads.deploy(workload)

    def expose_and_create_certificate(
        self,
        pool_id,
        gateway_id,
        network_name,
        trc_secret,
        domain,
        email,
        solution_ip,
        solution_port,
        enforce_https=False,
        node_id=None,
        proxy_pool_id=None,
        log_config=None,
        bot=None,
        public_key=&#34;&#34;,
        **metadata,
    ):
        &#34;&#34;&#34;
        exposes the solution and enable ssl for it&#39;s domain
        Args:
            pool_id: the pool used to create your solution
            gateway_id: Gateway id
            network_name: Name of the network selected while creating the solution
            trc_secret: Secret for tcp router
            domain: the domain we will issue certificate for
            email: used to issue certificate
            solution_ip: where your server is hosted (the actual server)
            solution_port: the port your application is listening on
            enforce_https: whether you want to only use https or not
            node_id: your node id
            solution_uuid: solution id
            public_key: your public key in case you want to have ssh access on the nginx container

        &#34;&#34;&#34;
        test_cert = j.config.get(&#34;TEST_CERT&#34;)
        proxy_pool_id = proxy_pool_id or pool_id
        gateway = self._explorer.gateway.get(gateway_id)

        proxy_id = self.create_proxy(
            pool_id=proxy_pool_id, gateway_id=gateway_id, domain_name=domain, trc_secret=trc_secret, **metadata
        )
        success = self.wait_workload(proxy_id)
        if not success:
            raise DeploymentFailed(
                f&#34;failed to create reverse proxy on gateway {gateway_id} workload {proxy_id}&#34;,
                wid=proxy_id,
                solution_uuid=metadata.get(&#34;solution_uuid&#34;),
            )

        tf_gateway = f&#34;{gateway.dns_nameserver[0]}:{gateway.tcp_router_port}&#34;
        secret_env = {
            &#34;TRC_SECRET&#34;: trc_secret,
            &#34;TFGATEWAY&#34;: tf_gateway,
            &#34;EMAIL&#34;: email,
            &#34;SOLUTION_IP&#34;: solution_ip,
            &#34;SOLUTION_PORT&#34;: str(solution_port),
            &#34;DOMAIN&#34;: domain,
            &#34;ENFORCE_HTTPS&#34;: &#34;true&#34; if enforce_https else &#34;false&#34;,
            &#34;PUBKEY&#34;: public_key,
            &#34;TEST_CERT&#34;: &#34;true&#34; if test_cert else &#34;false&#34;,
        }
        if not node_id:
            node = self.schedule_container(pool_id=pool_id, cru=1, mru=1, hru=1)
            node_id = node.node_id
        else:
            node = self._explorer.nodes.get(node_id)

        res = self.add_network_node(network_name, node, pool_id, bot=bot)
        if res:
            for wid in res[&#34;ids&#34;]:
                success = self.wait_workload(wid, bot, breaking_node_id=node.node_id)
                if not success:
                    raise DeploymentFailed(
                        f&#34;failed to add node {node.node_id} to network workload {wid}&#34;,
                        wid=wid,
                        solution_uuid=metadata.get(&#34;solution_uuid&#34;),
                    )
        network_view = NetworkView(network_name)
        network_view = network_view.copy()
        ip_address = network_view.get_free_ip(node)
        resv_id = self.deploy_container(
            pool_id=pool_id,
            node_id=node_id,
            network_name=network_name,
            ip_address=ip_address,
            flist=&#34;https://hub.grid.tf/omar0.3bot/omarelawady-nginx-certbot-zinit.flist&#34;,
            disk_type=DiskType.HDD,
            disk_size=512,
            secret_env=secret_env,
            public_ipv6=False,
            log_config=log_config,
            **metadata,
        )
        return resv_id

    def expose_address(
        self,
        pool_id,
        gateway_id,
        network_name,
        local_ip,
        port,
        tls_port,
        trc_secret,
        node_id=None,
        reserve_proxy=False,
        proxy_pool_id=None,
        domain_name=None,
        bot=None,
        log_config=None,
        **metadata,
    ):
        proxy_pool_id = proxy_pool_id or pool_id
        gateway = self._explorer.gateway.get(gateway_id)

        if reserve_proxy:
            if not domain_name:
                raise StopChatFlow(&#34;you must pass domain_name when you ise reserv_proxy&#34;)
            resv_id = self.create_proxy(
                pool_id=proxy_pool_id, gateway_id=gateway_id, domain_name=domain_name, trc_secret=trc_secret, **metadata
            )
            success = self.wait_workload(resv_id)
            if not success:
                raise DeploymentFailed(
                    f&#34;failed to create reverse proxy on gateway {gateway_id} to network workload {resv_id}&#34;,
                    wid=resv_id,
                    solution_uuid=metadata.get(&#34;solution_uuid&#34;),
                )

        remote = f&#34;{gateway.dns_nameserver[0]}:{gateway.tcp_router_port}&#34;
        secret_env = {&#34;TRC_SECRET&#34;: trc_secret}
        if not node_id:
            node = self.schedule_container(pool_id=pool_id, cru=1, mru=1, hru=1)
            node_id = node.node_id
        else:
            node = self._explorer.nodes.get(node_id)

        res = self.add_network_node(network_name, node, pool_id, bot=bot)
        if res:
            for wid in res[&#34;ids&#34;]:
                success = self.wait_workload(wid, bot, breaking_node_id=node.node_id)
                if not success:
                    if reserve_proxy:
                        j.sals.reservation_chatflow.solutions.cancel([resv_id])
                    raise DeploymentFailed(
                        f&#34;Failed to add node {node.node_id} to network {wid}&#34;,
                        wid=wid,
                        solution_uuid=metadata.get(&#34;solution_uuid&#34;),
                    )
        network_view = NetworkView(network_name)
        network_view = network_view.copy()
        network_view.used_ips.append(local_ip)
        ip_address = network_view.get_free_ip(node)
        env = {
            &#34;SOLUTION_IP&#34;: local_ip,
            &#34;HTTP_PORT&#34;: str(port),
            &#34;HTTPS_PORT&#34;: str(tls_port),
            &#34;REMOTE_IP&#34;: gateway.dns_nameserver[0],
            &#34;REMOTE_PORT&#34;: str(gateway.tcp_router_port),
        }
        print(log_config)
        resv_id = self.deploy_container(
            pool_id=pool_id,
            node_id=node_id,
            network_name=network_name,
            ip_address=ip_address,
            flist=&#34;https://hub.grid.tf/omar0.3bot/omarelawady-trc-zinit.flist&#34;,
            disk_type=DiskType.HDD,
            secret_env=secret_env,
            env=env,
            public_ipv6=False,
            log_config=log_config,
            **metadata,
        )
        return resv_id

    def deploy_minio_zdb(
        self,
        pool_id,
        password,
        node_ids=None,
        zdb_no=None,
        disk_type=DiskType.HDD,
        disk_size=10,
        pool_ids=None,
        **metadata,
    ):
        &#34;&#34;&#34;
        deploy zdb workloads on the specified node_ids if specified or deploy workloads as specifdied by the zdb_no
        Args:
            pool_id: used to deploy all workloads in this pool (overriden when pool_ids is specified)
            node_ids: if specified, it will be used for deployment of workloads.
            pool_ids: if specified, zdb workloads will be
            zdb_no: if specified and no node_ids, it will automatically schedule zdb workloads matching pool config

        Returns:
            []: list of workload ids deployed
        &#34;&#34;&#34;
        node_ids = node_ids or []
        if not (zdb_no or node_ids):
            raise StopChatFlow(&#34;you must pass at least one of zdb_no or node_ids&#34;)

        if node_ids:
            pool_ids = pool_ids or [pool_id] * len(node_ids)
        else:
            pool_ids = pool_ids or [pool_id] * zdb_no

        if len(pool_ids) != len(node_ids):
            raise StopChatFlow(&#34;pool_ids must be same length as node_ids&#34;)

        if not node_ids and zdb_no:
            query = {}
            if disk_type == DiskType.SSD:
                query[&#34;sru&#34;] = disk_size
            else:
                query[&#34;hru&#34;] = disk_size
            for pool_id in pool_ids:
                node = j.sals.reservation_chatflow.reservation_chatflow.nodes_get(
                    pool_ids=[pool_id], number_of_nodes=1, **query
                )[0]
                node_ids.append(node.node_id)

        result = []
        for i in range(len(node_ids)):
            node_id = node_ids[i]
            pool_id = pool_ids[i]
            resv_id = self.deploy_zdb(
                pool_id=pool_id,
                node_id=node_id,
                size=disk_size,
                mode=ZDBMode.Seq,
                password=password,
                disk_type=disk_type,
                **metadata,
            )
            result.append(resv_id)
        return result

    def deploy_minio_containers(
        self,
        pool_id,
        network_name,
        minio_nodes,
        minio_ip_addresses,
        zdb_configs,
        ak,
        sk,
        ssh_key,
        cpu,
        memory,
        data,
        parity,
        disk_type=DiskType.SSD,
        disk_size=10,
        log_config=None,
        mode=&#34;Single&#34;,
        bot=None,
        public_ipv6=False,
        secondary_pool_id=None,
        **metadata,
    ):
        secondary_pool_id = secondary_pool_id or pool_id
        secret_env = {}
        if mode == &#34;Master/Slave&#34;:
            secret_env[&#34;TLOG&#34;] = zdb_configs.pop(-1)
        shards = &#34;,&#34;.join(zdb_configs)
        secret_env[&#34;SHARDS&#34;] = shards
        secret_env[&#34;SECRET_KEY&#34;] = sk
        env = {
            &#34;DATA&#34;: str(data),
            &#34;PARITY&#34;: str(parity),
            &#34;ACCESS_KEY&#34;: ak,
            &#34;SSH_KEY&#34;: ssh_key,
            &#34;MINIO_PROMETHEUS_AUTH_TYPE&#34;: &#34;public&#34;,
        }
        result = []
        master_volume_id = self.deploy_volume(pool_id, minio_nodes[0], disk_size, disk_type, **metadata)
        success = self.wait_workload(master_volume_id, bot)
        if not success:
            raise DeploymentFailed(
                f&#34;Failed to create volume {master_volume_id} for minio container on&#34; f&#34; node {minio_nodes[0]}&#34;,
                wid=master_volume_id,
                solution_uuid=metadata.get(&#34;solution_uuid&#34;),
            )
        master_cont_id = self.deploy_container(
            pool_id=pool_id,
            node_id=minio_nodes[0],
            network_name=network_name,
            ip_address=minio_ip_addresses[0],
            env=env,
            cpu=cpu,
            memory=memory,
            secret_env=secret_env,
            log_config=log_config,
            volumes={&#34;/data&#34;: master_volume_id},
            public_ipv6=public_ipv6,
            flist=&#34;https://hub.grid.tf/tf-official-apps/minio:latest.flist&#34;,
            **metadata,
        )
        result.append(master_cont_id)
        if mode == &#34;Master/Slave&#34;:
            secret_env[&#34;MASTER&#34;] = secret_env.pop(&#34;TLOG&#34;)
            slave_volume_id = self.deploy_volume(pool_id, minio_nodes[1], disk_size, disk_type, **metadata)
            success = self.wait_workload(slave_volume_id, bot)
            if not success:
                raise DeploymentFailed(
                    f&#34;Failed to create volume {slave_volume_id} for minio container on&#34; f&#34; node {minio_nodes[1]}&#34;,
                    solution_uuid=metadata.get(&#34;solution_uuid&#34;),
                    wid=slave_volume_id,
                )
            slave_cont_id = self.deploy_container(
                pool_id=secondary_pool_id,
                node_id=minio_nodes[1],
                network_name=network_name,
                ip_address=minio_ip_addresses[1],
                env=env,
                cpu=cpu,
                memory=memory,
                secret_env=secret_env,
                log_config=log_config,
                volumes={&#34;/data&#34;: slave_volume_id},
                public_ipv6=public_ipv6,
                flist=&#34;https://hub.grid.tf/tf-official-apps/minio:latest.flist&#34;,
                **metadata,
            )
            result.append(slave_cont_id)
        return result

    def get_zdb_url(self, zdb_id, password):
        workload = j.sals.zos.get().workloads.get(zdb_id)
        result_json = j.data.serializers.json.loads(workload.info.result.data_json)
        if &#34;IPs&#34; in result_json:
            ip = result_json[&#34;IPs&#34;][0]
        else:
            ip = result_json[&#34;IP&#34;]
        namespace = result_json[&#34;Namespace&#34;]
        port = result_json[&#34;Port&#34;]
        url = f&#34;{namespace}:{password}@[{ip}]:{port}&#34;
        return url

    def ask_multi_pool_distribution(
        self, bot, number_of_nodes, resource_query=None, pool_ids=None, workload_name=None, ip_version=None
    ):
        &#34;&#34;&#34;
        Choose multiple pools to distribute workload automatically

        Args:
            bot: chatflow object
            resource_query: query dict {&#34;cru&#34;: 1, &#34;sru&#34;: 2, &#34;mru&#34;: 1, &#34;hru&#34;: 1}.
            pool_ids: if specfied it will limit the pools shown in the chatflow to only these pools
            workload_name: name shown in the message
        Returns:
            ([], []): first list contains the selected node objects. second list contains selected pool ids
        &#34;&#34;&#34;
        resource_query = resource_query or {}
        cu, su = self.calculate_capacity_units(**resource_query)
        pools = self.list_pools(cu, su)
        if pool_ids:
            filtered_pools = {}
            for pool_id in pools:
                if pool_id in pool_ids:
                    filtered_pools[pool_id] = pools[pool_id]
            pools = filtered_pools

        workload_name = workload_name or &#34;workloads&#34;
        messages = {}
        pool_factory = StoredFactory(PoolConfig)
        for p in pools:
            hidden = False
            name = &#34;&#34;
            if f&#34;pool_{p}&#34; in pool_factory.list_all():
                pool_config = pool_factory.get(f&#34;pool_{p}&#34;)
                hidden = pool_config.hidden
                name = pool_config.name
            if hidden:
                continue
            if name:
                messages[f&#34;Name: {name} Pool: {p} CU: {pools[p][0]} SU: {pools[p][1]}&#34;] = p
            else:
                messages[f&#34;Pool: {p} CU: {pools[p][0]} SU: {pools[p][1]}&#34;] = p

        while True:
            pool_choices = bot.multi_list_choice(
                &#34;Please select the pools you wish to distribute you&#34; f&#34; {workload_name} on&#34;,
                options=list(messages.keys()),
                required=True,
            )
            if not pool_choices:
                bot.md_show(&#34;You must select at least one pool. please click next to try again.&#34;)
            else:
                break

        pool_ids = {}
        node_to_pool = {}
        for p in pool_choices:
            pool = pool_ids.get(messages[p], j.sals.zos.get().pools.get(messages[p]))
            pool_ids[messages[p]] = pool.pool_id
            for node_id in pool.node_ids:
                node_to_pool[node_id] = pool

        nodes = j.sals.reservation_chatflow.reservation_chatflow.get_nodes(
            number_of_nodes, pool_ids=list(pool_ids.values()), ip_version=ip_version, **resource_query
        )
        selected_nodes = []
        selected_pool_ids = []
        for node in nodes:
            selected_nodes.append(node)
            pool = node_to_pool[node.node_id]
            selected_pool_ids.append(pool.pool_id)
        return selected_nodes, selected_pool_ids

    def chatflow_pools_check(self):
        if not self.list_pools():
            raise StopChatFlow(&#34;You don&#39;t have any capacity pools. Please create one first.&#34;)

    def chatflow_network_check(self, bot):
        networks = self.list_networks()
        if not networks:
            raise StopChatFlow(&#34;You don&#39;t have any deployed networks. Please create one first.&#34;)
        bot.all_network_viewes = networks

    def wait_demo_payment(self, bot, pool_id, exp=5, trigger_cus=0, trigger_sus=1):
        expiration = j.data.time.now().timestamp + exp * 60
        msg = &#34;&lt;h2&gt; Waiting for resources provisioning...&lt;/h2&gt;&#34;
        while j.data.time.get().timestamp &lt; expiration:
            bot.md_show_update(msg, html=True)
            pool = j.sals.zos.get().pools.get(pool_id)
            if pool.cus &gt;= trigger_cus and pool.sus &gt;= trigger_sus:
                bot.md_show_update(&#34;Preparing app resources&#34;)
                return True
            gevent.sleep(2)

        return False

    def wait_pool_payment(self, bot, pool_id, exp=5, qr_code=None, trigger_cus=0, trigger_sus=1):
        expiration = j.data.time.now().timestamp + exp * 60
        msg = &#34;&lt;h2&gt; Waiting for payment...&lt;/h2&gt;&#34;
        if qr_code:
            qr_encoded = j.tools.qrcode.base64_get(qr_code, scale=2)
            msg += f&#34;Please scan the QR Code below for the payment details if you missed it from the previous screen&#34;
            qr_code_msg = f&#34;&#34;&#34;
            &lt;div class=&#34;text-center&#34;&gt;
                &lt;img style=&#34;border:1px dashed #85929E&#34; src=&#34;data:image/png;base64,{qr_encoded}&#34;/&gt;
            &lt;/div&gt;
            &#34;&#34;&#34;
            pool = j.sals.zos.get().pools.get(pool_id)
            msg = msg + self.msg_payment_info + qr_code_msg
        while j.data.time.get().timestamp &lt; expiration:
            bot.md_show_update(msg, html=True)
            pool = j.sals.zos.get().pools.get(pool_id)
            if pool.cus &gt;= trigger_cus and pool.sus &gt;= trigger_sus:
                bot.md_show_update(&#34;Preparing app resources&#34;)
                return True
            gevent.sleep(2)

        return False

    def get_payment_info(self, pool):
        escrow_info = pool.escrow_information
        resv_id = pool.reservation_id
        escrow_address = escrow_info.address
        escrow_asset = escrow_info.asset
        total_amount = escrow_info.amount
        total_amount_dec = Decimal(total_amount) / Decimal(1e7)
        thecurrency = escrow_asset.split(&#34;:&#34;)[0]
        return {
            &#34;escrow_info&#34;: escrow_info,
            &#34;resv_id&#34;: resv_id,
            &#34;escrow_address&#34;: escrow_address,
            &#34;escrow_asset&#34;: escrow_asset,
            &#34;total_amount_dec&#34;: total_amount_dec,
            &#34;thecurrency&#34;: thecurrency,
            &#34;total_amount&#34;: total_amount,
        }

    def get_qr_code_payment_info(self, pool):
        info = self.get_payment_info(pool)
        total_amount = &#34;{0:f}&#34;.format(info[&#34;total_amount_dec&#34;])
        qr_code = f&#34;{info[&#39;thecurrency&#39;]}:{info[&#39;escrow_address&#39;]}?amount={total_amount}&amp;message=p-{info[&#39;resv_id&#39;]}&amp;sender=me&#34;
        msg_text = f&#34;&#34;&#34;

        &lt;h4&gt; Destination Wallet Address: &lt;/h4&gt;  {info[&#39;escrow_address&#39;]} \n
        &lt;h4&gt; Currency: &lt;/h4&gt;  {info[&#39;thecurrency&#39;]} \n
        &lt;h4&gt; Memo Text (Reservation ID): &lt;/h4&gt;  p-{info[&#39;resv_id&#39;]} \n
        &lt;h4&gt; Total Amount: &lt;/h4&gt; {total_amount} {info[&#39;thecurrency&#39;]} \n

        &lt;h5&gt;Inserting the memo-text is an important way to identify a transaction recipient beyond a wallet address. Failure to do so will result in a failed payment. Please also keep in mind that an additional Transaction fee of 0.1 {info[&#39;thecurrency&#39;]} will automatically occurs per transaction.&lt;/h5&gt;
        &#34;&#34;&#34;

        return msg_text, qr_code

    def test_managed_domain(self, gateway_id, managed_domain, pool_id, gateway=None):
        gateway = gateway or self._explorer.gateway.get(gateway_id)
        subdomain = f&#34;{uuid.uuid4().hex}.{managed_domain}&#34;
        addresses = [j.sals.nettools.get_host_by_name(gateway.dns_nameserver[0])]
        subdomain_id = self.create_subdomain(pool_id, gateway_id, subdomain, addresses)
        success = self.wait_workload(subdomain_id)
        if not success:
            return False
        try:
            j.sals.nettools.get_host_by_name(subdomain)
        except Exception as e:
            j.logger.error(f&#34;managed domain test failed for {managed_domain} due to error {str(e)}&#34;)
            j.sals.zos.get().workloads.decomission(subdomain_id)
            return False
        j.sals.zos.get().workloads.decomission(subdomain_id)
        return True

    def block_managed_domain(self, managed_domain):
        count = j.core.db.hincrby(DOMAINS_COUNT_KEY, managed_domain)
        expiration = count * DOMAINS_DISALLOW_EXPIRATION
        domain_key = f&#34;{DOMAINS_DISALLOW_PREFIX}:{managed_domain}&#34;
        j.core.db.set(domain_key, expiration, ex=expiration)

    def unblock_managed_domain(self, managed_domain, reset=True):
        domain_key = f&#34;{DOMAINS_DISALLOW_PREFIX}:{managed_domain}&#34;
        j.core.db.delete(domain_key)
        if reset:
            j.core.db.hdel(DOMAINS_COUNT_KEY, managed_domain)

    def list_blocked_managed_domains(self):
        blocked_domains_keys = j.core.db.keys(f&#34;{DOMAINS_DISALLOW_PREFIX}:*&#34;)
        failure_count_dict = j.core.db.hgetall(DOMAINS_COUNT_KEY)
        blocked_domains_values = j.core.db.mget(blocked_domains_keys)
        result = {}
        for idx, key in enumerate(blocked_domains_keys):
            key = key[len(DOMAINS_DISALLOW_PREFIX) + 1 :]
            node_id = key.decode()
            expiration = int(blocked_domains_values[idx])
            failure_count = int(failure_count_dict[key])
            result[node_id] = {&#34;expiration&#34;: expiration, &#34;failure_count&#34;: failure_count}
        return result</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="jumpscale.sals.marketplace.deployer.MarketPlaceDeployer" href="../marketplace/deployer.html#jumpscale.sals.marketplace.deployer.MarketPlaceDeployer">MarketPlaceDeployer</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="jumpscale.sals.reservation_chatflow.deployer.ChatflowDeployer.add_access"><code class="name flex">
<span>def <span class="ident">add_access</span></span>(<span>self, network_name, network_view=None, node_id=None, pool_id=None, use_ipv4=True, bot=None, **metadata)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def add_access(
    self, network_name, network_view=None, node_id=None, pool_id=None, use_ipv4=True, bot=None, **metadata
):
    network_view = network_view or NetworkView(network_name)
    network, wg = network_view.add_access(node_id, use_ipv4, pool_id)
    result = {&#34;ids&#34;: [], &#34;wg&#34;: wg}
    node_workloads = {}
    # deploy only latest resource generated by zos sal for each node
    for workload in network.network_resources:
        node_workloads[workload.info.node_id] = workload

    dry_run_name = uuid.uuid4().hex
    with NetworkView.dry_run_context(dry_run_name):
        network_view.dry_run(
            dry_run_name,
            list(node_workloads.keys()),
            [w.info.pool_id for w in node_workloads.values()],
            bot,
            breaking_node_ids=[node_id],
        )

    parent_id = network_view.network_workloads[-1].id
    for resource in node_workloads.values():
        resource.info.reference = &#34;&#34;
        resource.info.description = j.data.serializers.json.dumps({&#34;parent_id&#34;: parent_id})
        metadata[&#34;parent_network&#34;] = parent_id
        resource.info.metadata = self.encrypt_metadata(metadata)
        result[&#34;ids&#34;].append(j.sals.zos.get().workloads.deploy(resource))
        parent_id = result[&#34;ids&#34;][-1]
    result[&#34;rid&#34;] = result[&#34;ids&#34;][0]
    return result</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.reservation_chatflow.deployer.ChatflowDeployer.add_network_node"><code class="name flex">
<span>def <span class="ident">add_network_node</span></span>(<span>self, name, node, pool_id, network_view=None, bot=None, **metadata)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def add_network_node(self, name, node, pool_id, network_view=None, bot=None, **metadata):
    if not network_view:
        network_view = NetworkView(name)
    network = network_view.add_node(node, pool_id)
    if not network:
        return
    parent_id = network_view.network_workloads[-1].id
    ids = []
    node_workloads = {}
    # deploy only latest resource generated by zos sal for each node
    for workload in network.network_resources:
        node_workloads[workload.info.node_id] = workload
    dry_run_name = uuid.uuid4().hex
    with NetworkView.dry_run_context(dry_run_name):
        network_view.dry_run(
            dry_run_name,
            list(node_workloads.keys()),
            [w.info.pool_id for w in node_workloads.values()],
            bot,
            breaking_node_ids=[node.node_id],
        )
    for workload in node_workloads.values():
        workload.info.reference = &#34;&#34;
        workload.info.description = j.data.serializers.json.dumps({&#34;parent_id&#34;: parent_id})
        metadata[&#34;parent_network&#34;] = parent_id
        workload.info.metadata = self.encrypt_metadata(metadata)
        ids.append(j.sals.zos.get().workloads.deploy(workload))
        parent_id = ids[-1]
    return {&#34;ids&#34;: ids, &#34;rid&#34;: ids[0]}</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.reservation_chatflow.deployer.ChatflowDeployer.ask_container_logs"><code class="name flex">
<span>def <span class="ident">ask_container_logs</span></span>(<span>self, bot, solution_name=None)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def ask_container_logs(self, bot, solution_name=None):
    logs_config = {}
    form = bot.new_form()
    channel_type = form.string_ask(&#34;Please add the channel type&#34;, default=&#34;redis&#34;, required=True)
    channel_host = form.string_ask(&#34;Please add the IP address where the logs will be output to&#34;, required=True)
    channel_port = form.int_ask(&#34;Please add the port available where the logs will be output to&#34;, required=True)
    channel_name = form.string_ask(
        &#34;Please add the channel name to be used. The channels will be in the form&#34; &#34; NAME-stdout and NAME-stderr&#34;,
        default=solution_name,
        required=True,
    )
    form.ask()
    logs_config[&#34;channel_type&#34;] = channel_type.value
    logs_config[&#34;channel_host&#34;] = channel_host.value
    logs_config[&#34;channel_port&#34;] = channel_port.value
    logs_config[&#34;channel_name&#34;] = channel_name.value
    return logs_config</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.reservation_chatflow.deployer.ChatflowDeployer.ask_container_placement"><code class="name flex">
<span>def <span class="ident">ask_container_placement</span></span>(<span>self, bot, pool_id, cru=None, sru=None, mru=None, hru=None, ip_version=None, free_to_use=False, workload_name=None)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def ask_container_placement(
    self,
    bot,
    pool_id,
    cru=None,
    sru=None,
    mru=None,
    hru=None,
    ip_version=None,
    free_to_use=False,
    workload_name=None,
):
    if not workload_name:
        workload_name = &#34;your workload&#34;
    automatic_choice = bot.single_choice(
        &#34;Do you want to automatically select a node for deployment for&#34; f&#34; {workload_name}?&#34;,
        [&#34;YES&#34;, &#34;NO&#34;],
        default=&#34;YES&#34;,
        required=True,
    )
    if automatic_choice == &#34;YES&#34;:
        return None
    if j.config.get(&#34;OVER_PROVISIONING&#34;):
        cru = 0
        mru = 0
    nodes = j.sals.zos.get().nodes_finder.nodes_by_capacity(pool_id=pool_id, cru=cru, sru=sru, mru=mru, hru=hru)
    nodes = list(nodes)
    nodes = j.sals.reservation_chatflow.reservation_chatflow.filter_nodes(nodes, free_to_use, ip_version)
    blocked_nodes = j.sals.reservation_chatflow.reservation_chatflow.list_blocked_nodes()
    node_messages = {node.node_id: node for node in nodes if node.node_id not in blocked_nodes}
    if not node_messages:
        raise StopChatFlow(&#34;Failed to find resources for this reservation&#34;)
    node_id = bot.drop_down_choice(
        f&#34;Please choose the node you want to deploy {workload_name} on&#34;, list(node_messages.keys()), required=True
    )
    return node_messages[node_id]</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.reservation_chatflow.deployer.ChatflowDeployer.ask_container_resources"><code class="name flex">
<span>def <span class="ident">ask_container_resources</span></span>(<span>self, bot, cpu=True, memory=True, disk_size=True, disk_type=False, default_cpu=1, default_memory=1024, default_disk_size=256, default_disk_type=&#39;SSD&#39;)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def ask_container_resources(
    self,
    bot,
    cpu=True,
    memory=True,
    disk_size=True,
    disk_type=False,
    default_cpu=1,
    default_memory=1024,
    default_disk_size=256,
    default_disk_type=&#34;SSD&#34;,
):
    form = bot.new_form()
    if cpu:
        cpu_answer = form.int_ask(&#34;Please specify how many CPUs&#34;, default=default_cpu, required=True, min=1)
    if memory:
        memory_answer = form.int_ask(
            &#34;Please specify how much memory (in MB)&#34;, default=default_memory, required=True, min=1024
        )
    if disk_size:
        disk_size_answer = form.int_ask(
            &#34;Please specify the size of root filesystem (in MB)&#34;, default=default_disk_size, required=True
        )
    if disk_type:
        disk_type_answer = form.single_choice(
            &#34;Please choose the root filesystem disktype&#34;, [&#34;SSD&#34;, &#34;HDD&#34;], default=default_disk_type, required=True
        )
    form.ask()
    resources = {}
    if cpu:
        resources[&#34;cpu&#34;] = cpu_answer.value
    if memory:
        resources[&#34;memory&#34;] = memory_answer.value
    if disk_size:
        resources[&#34;disk_size&#34;] = disk_size_answer.value
    if disk_type:
        resources[&#34;disk_type&#34;] = DiskType[disk_type_answer.value]
    return resources</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.reservation_chatflow.deployer.ChatflowDeployer.ask_email"><code class="name flex">
<span>def <span class="ident">ask_email</span></span>(<span>self, bot)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def ask_email(self, bot):
    valid = False
    email = None
    regex = r&#34;^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$&#34;
    while not valid:
        email = bot.string_ask(&#34;Please enter your email address&#34;, required=True, field=&#34;email&#34;)
        valid = re.search(regex, email) is not None
        if not valid:
            bot.md_show(&#34;Please enter a valid email address&#34;)
    return email</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.reservation_chatflow.deployer.ChatflowDeployer.ask_ipv6"><code class="name flex">
<span>def <span class="ident">ask_ipv6</span></span>(<span>self, bot, workload_name=None)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def ask_ipv6(self, bot, workload_name=None):
    workload_name = workload_name or &#34;your workload&#34;
    ipv6 = bot.single_choice(
        f&#34;Do you want to assign a global IPv6 address to {workload_name}?&#34;,
        options=[&#34;YES&#34;, &#34;NO&#34;],
        default=&#34;NO&#34;,
        required=True,
    )
    return ipv6 == &#34;YES&#34;</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.reservation_chatflow.deployer.ChatflowDeployer.ask_multi_pool_distribution"><code class="name flex">
<span>def <span class="ident">ask_multi_pool_distribution</span></span>(<span>self, bot, number_of_nodes, resource_query=None, pool_ids=None, workload_name=None, ip_version=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Choose multiple pools to distribute workload automatically</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>bot</code></strong></dt>
<dd>chatflow object</dd>
<dt><strong><code>resource_query</code></strong></dt>
<dd>query dict {"cru": 1, "sru": 2, "mru": 1, "hru": 1}.</dd>
<dt><strong><code>pool_ids</code></strong></dt>
<dd>if specfied it will limit the pools shown in the chatflow to only these pools</dd>
<dt><strong><code>workload_name</code></strong></dt>
<dd>name shown in the message</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>([], []): first list contains the selected node objects. second list contains selected pool ids</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def ask_multi_pool_distribution(
    self, bot, number_of_nodes, resource_query=None, pool_ids=None, workload_name=None, ip_version=None
):
    &#34;&#34;&#34;
    Choose multiple pools to distribute workload automatically

    Args:
        bot: chatflow object
        resource_query: query dict {&#34;cru&#34;: 1, &#34;sru&#34;: 2, &#34;mru&#34;: 1, &#34;hru&#34;: 1}.
        pool_ids: if specfied it will limit the pools shown in the chatflow to only these pools
        workload_name: name shown in the message
    Returns:
        ([], []): first list contains the selected node objects. second list contains selected pool ids
    &#34;&#34;&#34;
    resource_query = resource_query or {}
    cu, su = self.calculate_capacity_units(**resource_query)
    pools = self.list_pools(cu, su)
    if pool_ids:
        filtered_pools = {}
        for pool_id in pools:
            if pool_id in pool_ids:
                filtered_pools[pool_id] = pools[pool_id]
        pools = filtered_pools

    workload_name = workload_name or &#34;workloads&#34;
    messages = {}
    pool_factory = StoredFactory(PoolConfig)
    for p in pools:
        hidden = False
        name = &#34;&#34;
        if f&#34;pool_{p}&#34; in pool_factory.list_all():
            pool_config = pool_factory.get(f&#34;pool_{p}&#34;)
            hidden = pool_config.hidden
            name = pool_config.name
        if hidden:
            continue
        if name:
            messages[f&#34;Name: {name} Pool: {p} CU: {pools[p][0]} SU: {pools[p][1]}&#34;] = p
        else:
            messages[f&#34;Pool: {p} CU: {pools[p][0]} SU: {pools[p][1]}&#34;] = p

    while True:
        pool_choices = bot.multi_list_choice(
            &#34;Please select the pools you wish to distribute you&#34; f&#34; {workload_name} on&#34;,
            options=list(messages.keys()),
            required=True,
        )
        if not pool_choices:
            bot.md_show(&#34;You must select at least one pool. please click next to try again.&#34;)
        else:
            break

    pool_ids = {}
    node_to_pool = {}
    for p in pool_choices:
        pool = pool_ids.get(messages[p], j.sals.zos.get().pools.get(messages[p]))
        pool_ids[messages[p]] = pool.pool_id
        for node_id in pool.node_ids:
            node_to_pool[node_id] = pool

    nodes = j.sals.reservation_chatflow.reservation_chatflow.get_nodes(
        number_of_nodes, pool_ids=list(pool_ids.values()), ip_version=ip_version, **resource_query
    )
    selected_nodes = []
    selected_pool_ids = []
    for node in nodes:
        selected_nodes.append(node)
        pool = node_to_pool[node.node_id]
        selected_pool_ids.append(pool.pool_id)
    return selected_nodes, selected_pool_ids</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.reservation_chatflow.deployer.ChatflowDeployer.ask_multi_pool_placement"><code class="name flex">
<span>def <span class="ident">ask_multi_pool_placement</span></span>(<span>self, bot, number_of_nodes, resource_query_list=None, pool_ids=None, workload_names=None, ip_version=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Ask and schedule workloads accross multiple pools</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>bot</code></strong></dt>
<dd>chatflow object</dd>
<dt><strong><code>number_of_nodes</code></strong></dt>
<dd>number of required nodes for deployment</dd>
<dt><strong><code>resource_query_list</code></strong></dt>
<dd>list of query dicts {"cru": 1, "sru": 2, "mru": 1, "hru": 1}. if specified it must be same length as number_of_nodes</dd>
<dt><strong><code>pool_ids</code></strong></dt>
<dd>if specfied it will limit the pools shown in the chatflow to only these pools</dd>
<dt><strong><code>workload_names</code></strong></dt>
<dd>if specified they will shown when asking the user for node selection for each workload. if specified it must be same length as number_of_nodes</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>([], []): first list contains the selected node objects. second list contains selected pool ids</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def ask_multi_pool_placement(
    self, bot, number_of_nodes, resource_query_list=None, pool_ids=None, workload_names=None, ip_version=None
):
    &#34;&#34;&#34;
    Ask and schedule workloads accross multiple pools

    Args:
        bot: chatflow object
        number_of_nodes: number of required nodes for deployment
        resource_query_list: list of query dicts {&#34;cru&#34;: 1, &#34;sru&#34;: 2, &#34;mru&#34;: 1, &#34;hru&#34;: 1}. if specified it must be same length as number_of_nodes
        pool_ids: if specfied it will limit the pools shown in the chatflow to only these pools
        workload_names: if specified they will shown when asking the user for node selection for each workload. if specified it must be same length as number_of_nodes

    Returns:
        ([], []): first list contains the selected node objects. second list contains selected pool ids
    &#34;&#34;&#34;
    resource_query_list = resource_query_list or [dict()] * number_of_nodes
    workload_names = workload_names or [None] * number_of_nodes
    if len(resource_query_list) != number_of_nodes:
        raise StopChatFlow(&#34;resource query_list must be same length as number of nodes&#34;)
    if len(workload_names) != number_of_nodes:
        raise StopChatFlow(&#34;workload_names must be same length as number of nodes&#34;)

    pools = self.list_pools()
    if pool_ids:
        filtered_pools = {}
        for pool_id in pools:
            if pool_id in pool_ids:
                filtered_pools[pool_id] = pools[pool_id]
        pools = filtered_pools
    selected_nodes = []
    selected_pool_ids = []
    for i in range(number_of_nodes):
        cu, su = self.calculate_capacity_units(**resource_query_list[i])
        pool_choices = {}
        for p in pools:
            if pools[p][0] &lt; cu or pools[p][1] &lt; su:
                continue
            nodes = j.sals.zos.get().nodes_finder.nodes_by_capacity(pool_id=p, **resource_query_list[i])
            if not nodes:
                continue
            pool_choices[p] = pools[p]
        pool_id = self.select_pool(bot, available_pools=pool_choices, workload_name=workload_names[i], cu=cu, su=su)
        node = self.ask_container_placement(
            bot, pool_id, workload_name=workload_names[i], ip_version=ip_version, **resource_query_list[i]
        )
        if not node:
            node = self.schedule_container(pool_id, ip_version=ip_version, **resource_query_list[i])
        selected_nodes.append(node)
        selected_pool_ids.append(pool_id)
    return selected_nodes, selected_pool_ids</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.reservation_chatflow.deployer.ChatflowDeployer.ask_name"><code class="name flex">
<span>def <span class="ident">ask_name</span></span>(<span>self, bot, msg=None)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def ask_name(self, bot, msg=None):
    msg = (
        msg
        or &#34;Please enter a name for your workload (Can be used to prepare domain for you and needed to track your solution on the grid)&#34;
    )
    name = bot.string_ask(msg, required=True, field=&#34;name&#34;, is_identifier=True)

    return name</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.reservation_chatflow.deployer.ChatflowDeployer.block_managed_domain"><code class="name flex">
<span>def <span class="ident">block_managed_domain</span></span>(<span>self, managed_domain)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def block_managed_domain(self, managed_domain):
    count = j.core.db.hincrby(DOMAINS_COUNT_KEY, managed_domain)
    expiration = count * DOMAINS_DISALLOW_EXPIRATION
    domain_key = f&#34;{DOMAINS_DISALLOW_PREFIX}:{managed_domain}&#34;
    j.core.db.set(domain_key, expiration, ex=expiration)</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.reservation_chatflow.deployer.ChatflowDeployer.calculate_capacity_units"><code class="name flex">
<span>def <span class="ident">calculate_capacity_units</span></span>(<span>self, cru=0, mru=0, sru=0, hru=0)</span>
</code></dt>
<dd>
<section class="desc"><p>return cu, su</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def calculate_capacity_units(self, cru=0, mru=0, sru=0, hru=0):
    &#34;&#34;&#34;
    return cu, su
    &#34;&#34;&#34;
    cu = min((mru - 1) / 4, cru * 4 / 2)
    su = (hru / 1000 + sru / 100 / 2) / 1.2
    if cu &lt; 0:
        cu = 0
    if su &lt; 0:
        su = 0
    return cu, su</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.reservation_chatflow.deployer.ChatflowDeployer.chatflow_network_check"><code class="name flex">
<span>def <span class="ident">chatflow_network_check</span></span>(<span>self, bot)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def chatflow_network_check(self, bot):
    networks = self.list_networks()
    if not networks:
        raise StopChatFlow(&#34;You don&#39;t have any deployed networks. Please create one first.&#34;)
    bot.all_network_viewes = networks</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.reservation_chatflow.deployer.ChatflowDeployer.chatflow_pools_check"><code class="name flex">
<span>def <span class="ident">chatflow_pools_check</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def chatflow_pools_check(self):
    if not self.list_pools():
        raise StopChatFlow(&#34;You don&#39;t have any capacity pools. Please create one first.&#34;)</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.reservation_chatflow.deployer.ChatflowDeployer.check_farm_capacity"><code class="name flex">
<span>def <span class="ident">check_farm_capacity</span></span>(<span>self, farm_name, currencies=None, sru=None, cru=None, mru=None, hru=None, ip_version=None)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def check_farm_capacity(self, farm_name, currencies=None, sru=None, cru=None, mru=None, hru=None, ip_version=None):
    node_filter = None
    if ip_version and ip_version not in [&#34;IPv4&#34;, &#34;IPv6&#34;]:
        raise j.exceptions.Runtime(f&#34;{ip_version} is not a valid IP Version&#34;)
    else:
        if ip_version == &#34;IPv4&#34;:
            node_filter = j.sals.zos.get().nodes_finder.filter_public_ip4
        elif ip_version == &#34;IPv6&#34;:
            node_filter = j.sals.zos.get().nodes_finder.filter_public_ip6
    currencies = currencies or []
    farm_nodes = j.sals.zos.get().nodes_finder.nodes_search(farm_name=farm_name)
    available_cru = 0
    available_sru = 0
    available_mru = 0
    available_hru = 0
    running_nodes = 0
    blocked_nodes = j.sals.reservation_chatflow.reservation_chatflow.list_blocked_nodes()
    access_node = None
    for node in farm_nodes:
        if &#34;FreeTFT&#34; in currencies and not node.free_to_use:
            continue
        if not j.sals.zos.get().nodes_finder.filter_is_up(node):
            continue
        if node.node_id in blocked_nodes:
            continue
        if not access_node and ip_version and node_filter(node):
            access_node = node
        running_nodes += 1
        available_cru += node.total_resources.cru - node.used_resources.cru
        available_sru += node.total_resources.sru - node.used_resources.sru
        available_mru += node.total_resources.mru - node.used_resources.mru
        available_hru += node.total_resources.hru - node.used_resources.hru

    if not running_nodes:
        return False, available_cru, available_sru, available_mru, available_hru
    if sru and available_sru &lt; sru:
        return False, available_cru, available_sru, available_mru, available_hru
    if cru and available_cru &lt; cru:
        return False, available_cru, available_sru, available_mru, available_hru
    if mru and available_mru &lt; mru:
        return False, available_cru, available_sru, available_mru, available_hru
    if hru and available_hru &lt; hru:
        return False, available_cru, available_sru, available_mru, available_hru
    if ip_version and not access_node:
        return False, available_cru, available_sru, available_mru, available_hru
    return True, available_cru, available_sru, available_mru, available_hru</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.reservation_chatflow.deployer.ChatflowDeployer.check_pool_capacity"><code class="name flex">
<span>def <span class="ident">check_pool_capacity</span></span>(<span>self, pool, cu=None, su=None)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def check_pool_capacity(self, pool, cu=None, su=None):
    available_su = pool.sus
    available_cu = pool.cus
    if pool.empty_at &lt; 0:
        return False, 0, 0
    if cu and available_cu &lt; cu:
        return False, available_cu, available_su
    if su and available_su &lt; su:
        return False, available_cu, available_su
    if (cu or su) and pool.empty_at &lt; j.data.time.now().timestamp:
        return False, 0, 0
    return True, available_cu, available_su</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.reservation_chatflow.deployer.ChatflowDeployer.create_ipv6_gateway"><code class="name flex">
<span>def <span class="ident">create_ipv6_gateway</span></span>(<span>self, gateway_id, pool_id, public_key, **metadata)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def create_ipv6_gateway(self, gateway_id, pool_id, public_key, **metadata):
    if isinstance(public_key, bytes):
        public_key = public_key.decode()
    workload = j.sals.zos.get().gateway.gateway_4to6(gateway_id, public_key, pool_id)
    if metadata:
        workload.info.metadata = self.encrypt_metadata(metadata)
    return j.sals.zos.get().workloads.deploy(workload)</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.reservation_chatflow.deployer.ChatflowDeployer.create_pool"><code class="name flex">
<span>def <span class="ident">create_pool</span></span>(<span>self, bot)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def create_pool(self, bot):
    cu, su, currencies = self._pool_form(bot)
    all_farms = self._explorer.farms.list()
    available_farms = {}
    farms_by_name = {}
    for farm in all_farms:
        farm_assets = [w.asset for w in farm.wallet_addresses]
        if currencies[0] not in farm_assets:
            continue
        res = self.check_farm_capacity(farm.name, currencies)
        available = res[0]
        resources = res[1:]
        if available:
            available_farms[farm.name] = resources
            farms_by_name[farm.name] = farm
    farm_messages = {}
    for farm in available_farms:
        farm_assets = [w.asset for w in farms_by_name[farm].wallet_addresses]
        if currencies[0] not in farm_assets:
            continue
        resources = available_farms[farm]
        farm_obj = farms_by_name[farm]
        location_list = [farm_obj.location.continent, farm_obj.location.country, farm_obj.location.city]
        location = &#34;-&#34;.join([info for info in location_list if info])
        if location:
            location = f&#34; location: {location}&#34;
        farm_messages[
            f&#34;{farm.capitalize()}{location}: CRU: {resources[0]} SRU: {resources[1]} HRU: {resources[2]} MRU {resources[3]}&#34;
        ] = farm
    if not farm_messages:
        raise StopChatFlow(f&#34;There are no farms available that the support {currencies[0]} currency&#34;)
    selected_farm = bot.drop_down_choice(
        &#34;Please choose a farm to reserve capacity from. By reserving IT Capacity, you are purchasing the capacity from one of the farms. The available Resource Units (RU): CRU, MRU, HRU, SRU, NRU are displayed for you to make a more-informed decision on farm selection. &#34;,
        list(farm_messages.keys()),
        required=True,
    )
    farm = farm_messages[selected_farm]
    try:
        pool_info = j.sals.zos.get().pools.create(cu, su, farm, currencies)
    except Exception as e:
        raise StopChatFlow(f&#34;failed to reserve pool.\n{str(e)}&#34;)
    qr_code = self.show_payment(pool_info, bot)
    self.wait_pool_payment(bot, pool_info.reservation_id, 10, qr_code, trigger_cus=cu, trigger_sus=su)
    return pool_info</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.reservation_chatflow.deployer.ChatflowDeployer.create_proxy"><code class="name flex">
<span>def <span class="ident">create_proxy</span></span>(<span>self, pool_id, gateway_id, domain_name, trc_secret, **metadata)</span>
</code></dt>
<dd>
<section class="desc"><p>creates a reverse tunnel on the gateway node</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def create_proxy(self, pool_id, gateway_id, domain_name, trc_secret, **metadata):
    &#34;&#34;&#34;
    creates a reverse tunnel on the gateway node
    &#34;&#34;&#34;
    workload = j.sals.zos.get().gateway.tcp_proxy_reverse(gateway_id, domain_name, trc_secret, pool_id)
    if metadata:
        workload.info.metadata = self.encrypt_metadata(metadata)
    return j.sals.zos.get().workloads.deploy(workload)</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.reservation_chatflow.deployer.ChatflowDeployer.create_subdomain"><code class="name flex">
<span>def <span class="ident">create_subdomain</span></span>(<span>self, pool_id, gateway_id, subdomain, addresses=None, **metadata)</span>
</code></dt>
<dd>
<section class="desc"><p>creates an A record pointing to the specified addresses
if no addresses are specified, the record will point the gateway IP address (used for exposing solutions)</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def create_subdomain(self, pool_id, gateway_id, subdomain, addresses=None, **metadata):
    &#34;&#34;&#34;
    creates an A record pointing to the specified addresses
    if no addresses are specified, the record will point the gateway IP address (used for exposing solutions)
    &#34;&#34;&#34;
    if not addresses:
        gateway = self._explorer.gateway.get(gateway_id)
        addresses = [j.sals.nettools.get_host_by_name(ns) for ns in gateway.dns_nameserver]
    workload = j.sals.zos.get().gateway.sub_domain(gateway_id, subdomain, addresses, pool_id)
    if metadata:
        workload.info.metadata = self.encrypt_metadata(metadata)
    return j.sals.zos.get().workloads.deploy(workload)</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.reservation_chatflow.deployer.ChatflowDeployer.decrypt_metadata"><code class="name flex">
<span>def <span class="ident">decrypt_metadata</span></span>(<span>self, encrypted_metadata)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def decrypt_metadata(self, encrypted_metadata):
    try:
        pk = j.core.identity.me.nacl.signing_key.verify_key.to_curve25519_public_key()
        sk = j.core.identity.me.nacl.signing_key.to_curve25519_private_key()
        box = Box(sk, pk)
        return box.decrypt(base64.b85decode(encrypted_metadata.encode())).decode()
    except:
        return &#34;{}&#34;</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.reservation_chatflow.deployer.ChatflowDeployer.delegate_domain"><code class="name flex">
<span>def <span class="ident">delegate_domain</span></span>(<span>self, pool_id, gateway_id, domain_name, **metadata)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def delegate_domain(self, pool_id, gateway_id, domain_name, **metadata):
    domain_delegate = j.sals.zos.get().gateway.delegate_domain(gateway_id, domain_name, pool_id)
    if metadata:
        domain_delegate.info.metadata = self.encrypt_metadata(metadata)
    return j.sals.zos.get().workloads.deploy(domain_delegate)</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.reservation_chatflow.deployer.ChatflowDeployer.delete_access"><code class="name flex">
<span>def <span class="ident">delete_access</span></span>(<span>self, network_name, iprange, network_view=None, node_id=None, bot=None, **metadata)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def delete_access(self, network_name, iprange, network_view=None, node_id=None, bot=None, **metadata):
    network_view = network_view or NetworkView(network_name)
    network = network_view.delete_access(iprange, node_id)

    node_workloads = {}
    # deploy only latest resource generated by zos sal for each node
    for workload in network.network_resources:
        node_workloads[workload.info.node_id] = workload
    dry_run_name = uuid.uuid4().hex
    with NetworkView.dry_run_context(dry_run_name):
        network_view.dry_run(
            dry_run_name,
            list(node_workloads.keys()),
            [w.info.pool_id for w in node_workloads.values()],
            bot,
            breaking_node_ids=[node_id],
        )
    parent_id = network_view.network_workloads[-1].id
    result = []
    for resource in node_workloads.values():
        resource.info.reference = &#34;&#34;
        resource.info.description = j.data.serializers.json.dumps({&#34;parent_id&#34;: parent_id})
        metadata[&#34;parent_network&#34;] = parent_id
        resource.info.metadata = self.encrypt_metadata(metadata)
        result.append(j.sals.zos.get().workloads.deploy(resource))
        parent_id = result[-1]
    return result</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.reservation_chatflow.deployer.ChatflowDeployer.deploy_container"><code class="name flex">
<span>def <span class="ident">deploy_container</span></span>(<span>self, pool_id, node_id, network_name, ip_address, flist, env=None, cpu=1, memory=1024, disk_size=256, disk_type=&lt;DiskType.SSD: 1&gt;, entrypoint=&#39;&#39;, interactive=False, secret_env=None, volumes=None, log_config=None, public_ipv6=False, **metadata)</span>
</code></dt>
<dd>
<section class="desc"><p>volumes: dict {"mountpoint (/)": volume_id}
log_Config: dict. keys ("channel_type", "channel_host", "channel_port", "channel_name")</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def deploy_container(
    self,
    pool_id,
    node_id,
    network_name,
    ip_address,
    flist,
    env=None,
    cpu=1,
    memory=1024,
    disk_size=256,
    disk_type=DiskType.SSD,
    entrypoint=&#34;&#34;,
    interactive=False,
    secret_env=None,
    volumes=None,
    log_config=None,
    public_ipv6=False,
    **metadata,
):
    &#34;&#34;&#34;
    volumes: dict {&#34;mountpoint (/)&#34;: volume_id}
    log_Config: dict. keys (&#34;channel_type&#34;, &#34;channel_host&#34;, &#34;channel_port&#34;, &#34;channel_name&#34;)
    &#34;&#34;&#34;
    env = env or {}
    encrypted_secret_env = {}
    if secret_env:
        for key, val in secret_env.items():
            encrypted_secret_env[key] = j.sals.zos.get().container.encrypt_secret(node_id, val)
    container = j.sals.zos.get().container.create(
        node_id,
        network_name,
        ip_address,
        flist,
        pool_id,
        env,
        cpu,
        memory,
        disk_size,
        entrypoint,
        interactive,
        encrypted_secret_env,
        public_ipv6=public_ipv6,
    )
    if volumes:
        for mount_point, vol_id in volumes.items():
            j.sals.zos.get().volume.attach_existing(container, f&#34;{vol_id}-1&#34;, mount_point)
    if metadata:
        container.info.metadata = self.encrypt_metadata(metadata)
    if log_config:
        j.sals.zos.get().container.add_logs(container, **log_config)
    return j.sals.zos.get().workloads.deploy(container)</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.reservation_chatflow.deployer.ChatflowDeployer.deploy_kubernetes_cluster"><code class="name flex">
<span>def <span class="ident">deploy_kubernetes_cluster</span></span>(<span>self, pool_id, node_ids, network_name, cluster_secret, ssh_keys, size=1, ip_addresses=None, slave_pool_ids=None, **metadata)</span>
</code></dt>
<dd>
<section class="desc"><p>deplou k8s cluster with the same number of nodes as specifed in node_ids</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>pool_id</code></strong></dt>
<dd>this one is always used for master.</dd>
<dt><strong><code>node_ids</code></strong></dt>
<dd>list() of node ids to deploy on. first node_id is used for master reservation</dd>
<dt><strong><code>ip_addresses</code></strong></dt>
<dd>if specified it will be mapped 1-1 with node_ids for workloads. if not specified it will choose any free_ip from the node</dd>
<dt><strong><code>slave_pool_ids</code></strong></dt>
<dd>if specified, k8s workers will deployed on each of these pools respectively. if empty it will use the master pool_id</dd>
</dl>
<h2 id="return">Return</h2>
<dl>
<dt><strong><code>list</code></strong></dt>
<dd>[{"node_id": "ip_address"}, &hellip;] first dict is master's result</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def deploy_kubernetes_cluster(
    self,
    pool_id,
    node_ids,
    network_name,
    cluster_secret,
    ssh_keys,
    size=1,
    ip_addresses=None,
    slave_pool_ids=None,
    **metadata,
):
    &#34;&#34;&#34;
    deplou k8s cluster with the same number of nodes as specifed in node_ids

    Args:
        pool_id: this one is always used for master.
        node_ids: list() of node ids to deploy on. first node_id is used for master reservation
        ip_addresses: if specified it will be mapped 1-1 with node_ids for workloads. if not specified it will choose any free_ip from the node
        slave_pool_ids: if specified, k8s workers will deployed on each of these pools respectively. if empty it will use the master pool_id

    Return:
        list: [{&#34;node_id&#34;: &#34;ip_address&#34;}, ...] first dict is master&#39;s result
    &#34;&#34;&#34;
    slave_pool_ids = slave_pool_ids or ([pool_id] * (len(node_ids) - 1))
    pool_ids = [pool_id] + slave_pool_ids
    result = []  # [{&#34;node_id&#34;: id,  &#34;ip_address&#34;: ip, &#34;reservation_id&#34;: 16}] first dict is master&#39;s result
    if ip_addresses and len(ip_addresses) != len(node_ids):
        raise StopChatFlow(&#34;length of ips != node_ids&#34;)

    if not ip_addresses:
        # get free_ips for the nodes
        ip_addresses = []
        for i in range(len(node_ids)):
            node_id = node_ids[i]
            pool_id = pool_ids[i]
            node = self._explorer.nodes.get(node_id)
            res = self.add_network_node(network_name, node, pool_id)
            if res:
                for wid in res[&#34;ids&#34;]:
                    success = self.wait_workload(wid, breaking_node_id=node.node_id)
                    if not success:
                        raise StopChatFlow(f&#34;Failed to add node {node.node_id} to network {wid}&#34;)
            network_view = NetworkView(network_name)
            address = network_view.get_free_ip(node)
            if not address:
                raise StopChatFlow(f&#34;No free IPs for network {network_name} on the specifed node&#34; f&#34; {node_id}&#34;)
            ip_addresses.append(address)

    # deploy_master
    master_ip = ip_addresses[0]
    master_resv_id = self.deploy_kubernetes_master(
        pool_ids[0], node_ids[0], network_name, cluster_secret, ssh_keys, master_ip, size, **metadata
    )
    result.append({&#34;node_id&#34;: node_ids[0], &#34;ip_address&#34;: master_ip, &#34;reservation_id&#34;: master_resv_id})
    for i in range(1, len(node_ids)):
        node_id = node_ids[i]
        pool_id = pool_ids[i]
        ip_address = ip_addresses[i]
        resv_id = self.deploy_kubernetes_worker(
            pool_id, node_id, network_name, cluster_secret, ssh_keys, ip_address, master_ip, size, **metadata
        )
        result.append({&#34;node_id&#34;: node_id, &#34;ip_address&#34;: ip_address, &#34;reservation_id&#34;: resv_id})
    return result</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.reservation_chatflow.deployer.ChatflowDeployer.deploy_kubernetes_master"><code class="name flex">
<span>def <span class="ident">deploy_kubernetes_master</span></span>(<span>self, pool_id, node_id, network_name, cluster_secret, ssh_keys, ip_address, size=1, **metadata)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def deploy_kubernetes_master(
    self, pool_id, node_id, network_name, cluster_secret, ssh_keys, ip_address, size=1, **metadata
):
    master = j.sals.zos.get().kubernetes.add_master(
        node_id, network_name, cluster_secret, ip_address, size, ssh_keys, pool_id
    )
    master.info.description = j.data.serializers.json.dumps({&#34;role&#34;: &#34;master&#34;})
    if metadata:
        master.info.metadata = self.encrypt_metadata(metadata)
    return j.sals.zos.get().workloads.deploy(master)</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.reservation_chatflow.deployer.ChatflowDeployer.deploy_kubernetes_worker"><code class="name flex">
<span>def <span class="ident">deploy_kubernetes_worker</span></span>(<span>self, pool_id, node_id, network_name, cluster_secret, ssh_keys, ip_address, master_ip, size=1, **metadata)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def deploy_kubernetes_worker(
    self, pool_id, node_id, network_name, cluster_secret, ssh_keys, ip_address, master_ip, size=1, **metadata
):
    worker = j.sals.zos.get().kubernetes.add_worker(
        node_id, network_name, cluster_secret, ip_address, size, master_ip, ssh_keys, pool_id
    )
    worker.info.description = j.data.serializers.json.dumps({&#34;role&#34;: &#34;worker&#34;})
    if metadata:
        worker.info.metadata = self.encrypt_metadata(metadata)
    return j.sals.zos.get().workloads.deploy(worker)</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.reservation_chatflow.deployer.ChatflowDeployer.deploy_minio_containers"><code class="name flex">
<span>def <span class="ident">deploy_minio_containers</span></span>(<span>self, pool_id, network_name, minio_nodes, minio_ip_addresses, zdb_configs, ak, sk, ssh_key, cpu, memory, data, parity, disk_type=&lt;DiskType.SSD: 1&gt;, disk_size=10, log_config=None, mode=&#39;Single&#39;, bot=None, public_ipv6=False, secondary_pool_id=None, **metadata)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def deploy_minio_containers(
    self,
    pool_id,
    network_name,
    minio_nodes,
    minio_ip_addresses,
    zdb_configs,
    ak,
    sk,
    ssh_key,
    cpu,
    memory,
    data,
    parity,
    disk_type=DiskType.SSD,
    disk_size=10,
    log_config=None,
    mode=&#34;Single&#34;,
    bot=None,
    public_ipv6=False,
    secondary_pool_id=None,
    **metadata,
):
    secondary_pool_id = secondary_pool_id or pool_id
    secret_env = {}
    if mode == &#34;Master/Slave&#34;:
        secret_env[&#34;TLOG&#34;] = zdb_configs.pop(-1)
    shards = &#34;,&#34;.join(zdb_configs)
    secret_env[&#34;SHARDS&#34;] = shards
    secret_env[&#34;SECRET_KEY&#34;] = sk
    env = {
        &#34;DATA&#34;: str(data),
        &#34;PARITY&#34;: str(parity),
        &#34;ACCESS_KEY&#34;: ak,
        &#34;SSH_KEY&#34;: ssh_key,
        &#34;MINIO_PROMETHEUS_AUTH_TYPE&#34;: &#34;public&#34;,
    }
    result = []
    master_volume_id = self.deploy_volume(pool_id, minio_nodes[0], disk_size, disk_type, **metadata)
    success = self.wait_workload(master_volume_id, bot)
    if not success:
        raise DeploymentFailed(
            f&#34;Failed to create volume {master_volume_id} for minio container on&#34; f&#34; node {minio_nodes[0]}&#34;,
            wid=master_volume_id,
            solution_uuid=metadata.get(&#34;solution_uuid&#34;),
        )
    master_cont_id = self.deploy_container(
        pool_id=pool_id,
        node_id=minio_nodes[0],
        network_name=network_name,
        ip_address=minio_ip_addresses[0],
        env=env,
        cpu=cpu,
        memory=memory,
        secret_env=secret_env,
        log_config=log_config,
        volumes={&#34;/data&#34;: master_volume_id},
        public_ipv6=public_ipv6,
        flist=&#34;https://hub.grid.tf/tf-official-apps/minio:latest.flist&#34;,
        **metadata,
    )
    result.append(master_cont_id)
    if mode == &#34;Master/Slave&#34;:
        secret_env[&#34;MASTER&#34;] = secret_env.pop(&#34;TLOG&#34;)
        slave_volume_id = self.deploy_volume(pool_id, minio_nodes[1], disk_size, disk_type, **metadata)
        success = self.wait_workload(slave_volume_id, bot)
        if not success:
            raise DeploymentFailed(
                f&#34;Failed to create volume {slave_volume_id} for minio container on&#34; f&#34; node {minio_nodes[1]}&#34;,
                solution_uuid=metadata.get(&#34;solution_uuid&#34;),
                wid=slave_volume_id,
            )
        slave_cont_id = self.deploy_container(
            pool_id=secondary_pool_id,
            node_id=minio_nodes[1],
            network_name=network_name,
            ip_address=minio_ip_addresses[1],
            env=env,
            cpu=cpu,
            memory=memory,
            secret_env=secret_env,
            log_config=log_config,
            volumes={&#34;/data&#34;: slave_volume_id},
            public_ipv6=public_ipv6,
            flist=&#34;https://hub.grid.tf/tf-official-apps/minio:latest.flist&#34;,
            **metadata,
        )
        result.append(slave_cont_id)
    return result</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.reservation_chatflow.deployer.ChatflowDeployer.deploy_minio_zdb"><code class="name flex">
<span>def <span class="ident">deploy_minio_zdb</span></span>(<span>self, pool_id, password, node_ids=None, zdb_no=None, disk_type=&lt;DiskType.HDD: 0&gt;, disk_size=10, pool_ids=None, **metadata)</span>
</code></dt>
<dd>
<section class="desc"><p>deploy zdb workloads on the specified node_ids if specified or deploy workloads as specifdied by the zdb_no</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>pool_id</code></strong></dt>
<dd>used to deploy all workloads in this pool (overriden when pool_ids is specified)</dd>
<dt><strong><code>node_ids</code></strong></dt>
<dd>if specified, it will be used for deployment of workloads.</dd>
<dt><strong><code>pool_ids</code></strong></dt>
<dd>if specified, zdb workloads will be</dd>
<dt><strong><code>zdb_no</code></strong></dt>
<dd>if specified and no node_ids, it will automatically schedule zdb workloads matching pool config</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>[]: list of workload ids deployed</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def deploy_minio_zdb(
    self,
    pool_id,
    password,
    node_ids=None,
    zdb_no=None,
    disk_type=DiskType.HDD,
    disk_size=10,
    pool_ids=None,
    **metadata,
):
    &#34;&#34;&#34;
    deploy zdb workloads on the specified node_ids if specified or deploy workloads as specifdied by the zdb_no
    Args:
        pool_id: used to deploy all workloads in this pool (overriden when pool_ids is specified)
        node_ids: if specified, it will be used for deployment of workloads.
        pool_ids: if specified, zdb workloads will be
        zdb_no: if specified and no node_ids, it will automatically schedule zdb workloads matching pool config

    Returns:
        []: list of workload ids deployed
    &#34;&#34;&#34;
    node_ids = node_ids or []
    if not (zdb_no or node_ids):
        raise StopChatFlow(&#34;you must pass at least one of zdb_no or node_ids&#34;)

    if node_ids:
        pool_ids = pool_ids or [pool_id] * len(node_ids)
    else:
        pool_ids = pool_ids or [pool_id] * zdb_no

    if len(pool_ids) != len(node_ids):
        raise StopChatFlow(&#34;pool_ids must be same length as node_ids&#34;)

    if not node_ids and zdb_no:
        query = {}
        if disk_type == DiskType.SSD:
            query[&#34;sru&#34;] = disk_size
        else:
            query[&#34;hru&#34;] = disk_size
        for pool_id in pool_ids:
            node = j.sals.reservation_chatflow.reservation_chatflow.nodes_get(
                pool_ids=[pool_id], number_of_nodes=1, **query
            )[0]
            node_ids.append(node.node_id)

    result = []
    for i in range(len(node_ids)):
        node_id = node_ids[i]
        pool_id = pool_ids[i]
        resv_id = self.deploy_zdb(
            pool_id=pool_id,
            node_id=node_id,
            size=disk_size,
            mode=ZDBMode.Seq,
            password=password,
            disk_type=disk_type,
            **metadata,
        )
        result.append(resv_id)
    return result</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.reservation_chatflow.deployer.ChatflowDeployer.deploy_network"><code class="name flex">
<span>def <span class="ident">deploy_network</span></span>(<span>self, name, access_node, ip_range, ip_version, pool_id, **metadata)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def deploy_network(self, name, access_node, ip_range, ip_version, pool_id, **metadata):
    network = j.sals.zos.get().network.create(ip_range, name)
    node_subnets = netaddr.IPNetwork(ip_range).subnet(24)
    network_config = dict()
    use_ipv4 = ip_version == &#34;IPv4&#34;

    j.sals.zos.get().network.add_node(network, access_node.node_id, str(next(node_subnets)), pool_id)
    wg_quick = j.sals.zos.get().network.add_access(
        network, access_node.node_id, str(next(node_subnets)), ipv4=use_ipv4
    )

    network_config[&#34;wg&#34;] = wg_quick
    j.sals.fs.mkdir(f&#34;{j.core.dirs.CFGDIR}/wireguard/&#34;)
    j.sals.fs.write_file(f&#34;{j.core.dirs.CFGDIR}/{name}.conf&#34;, f&#34;{wg_quick}&#34;)

    ids = []
    parent_id = None
    for workload in network.network_resources:
        workload.info.description = j.data.serializers.json.dumps({&#34;parent_id&#34;: parent_id})
        metadata[&#34;parent_network&#34;] = parent_id
        workload.info.metadata = self.encrypt_metadata(metadata)
        ids.append(j.sals.zos.get().workloads.deploy(workload))
        parent_id = ids[-1]
    network_config[&#34;ids&#34;] = ids
    network_config[&#34;rid&#34;] = ids[0]
    return network_config</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.reservation_chatflow.deployer.ChatflowDeployer.deploy_volume"><code class="name flex">
<span>def <span class="ident">deploy_volume</span></span>(<span>self, pool_id, node_id, size, volume_type=&lt;DiskType.SSD: 1&gt;, **metadata)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def deploy_volume(self, pool_id, node_id, size, volume_type=DiskType.SSD, **metadata):
    volume = j.sals.zos.get().volume.create(node_id, pool_id, size, volume_type)
    if metadata:
        volume.info.metadata = self.encrypt_metadata(metadata)
    return j.sals.zos.get().workloads.deploy(volume)</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.reservation_chatflow.deployer.ChatflowDeployer.deploy_zdb"><code class="name flex">
<span>def <span class="ident">deploy_zdb</span></span>(<span>self, pool_id, node_id, size, mode, password, disk_type=&#39;SSD&#39;, public=False, **metadata)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def deploy_zdb(self, pool_id, node_id, size, mode, password, disk_type=&#34;SSD&#34;, public=False, **metadata):
    workload = j.sals.zos.get().zdb.create(node_id, size, mode, password, pool_id, disk_type, public)
    if metadata:
        workload.info.metadata = self.encrypt_metadata(metadata)
    return j.sals.zos.get().workloads.deploy(workload)</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.reservation_chatflow.deployer.ChatflowDeployer.encrypt_metadata"><code class="name flex">
<span>def <span class="ident">encrypt_metadata</span></span>(<span>self, metadata)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def encrypt_metadata(self, metadata):
    if isinstance(metadata, dict):
        metadata = j.data.serializers.json.dumps(metadata)
    pk = j.core.identity.me.nacl.signing_key.verify_key.to_curve25519_public_key()
    sk = j.core.identity.me.nacl.signing_key.to_curve25519_private_key()
    box = Box(sk, pk)
    encrypted_metadata = base64.b85encode(box.encrypt(metadata.encode())).decode()
    return encrypted_metadata</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.reservation_chatflow.deployer.ChatflowDeployer.expose_address"><code class="name flex">
<span>def <span class="ident">expose_address</span></span>(<span>self, pool_id, gateway_id, network_name, local_ip, port, tls_port, trc_secret, node_id=None, reserve_proxy=False, proxy_pool_id=None, domain_name=None, bot=None, log_config=None, **metadata)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def expose_address(
    self,
    pool_id,
    gateway_id,
    network_name,
    local_ip,
    port,
    tls_port,
    trc_secret,
    node_id=None,
    reserve_proxy=False,
    proxy_pool_id=None,
    domain_name=None,
    bot=None,
    log_config=None,
    **metadata,
):
    proxy_pool_id = proxy_pool_id or pool_id
    gateway = self._explorer.gateway.get(gateway_id)

    if reserve_proxy:
        if not domain_name:
            raise StopChatFlow(&#34;you must pass domain_name when you ise reserv_proxy&#34;)
        resv_id = self.create_proxy(
            pool_id=proxy_pool_id, gateway_id=gateway_id, domain_name=domain_name, trc_secret=trc_secret, **metadata
        )
        success = self.wait_workload(resv_id)
        if not success:
            raise DeploymentFailed(
                f&#34;failed to create reverse proxy on gateway {gateway_id} to network workload {resv_id}&#34;,
                wid=resv_id,
                solution_uuid=metadata.get(&#34;solution_uuid&#34;),
            )

    remote = f&#34;{gateway.dns_nameserver[0]}:{gateway.tcp_router_port}&#34;
    secret_env = {&#34;TRC_SECRET&#34;: trc_secret}
    if not node_id:
        node = self.schedule_container(pool_id=pool_id, cru=1, mru=1, hru=1)
        node_id = node.node_id
    else:
        node = self._explorer.nodes.get(node_id)

    res = self.add_network_node(network_name, node, pool_id, bot=bot)
    if res:
        for wid in res[&#34;ids&#34;]:
            success = self.wait_workload(wid, bot, breaking_node_id=node.node_id)
            if not success:
                if reserve_proxy:
                    j.sals.reservation_chatflow.solutions.cancel([resv_id])
                raise DeploymentFailed(
                    f&#34;Failed to add node {node.node_id} to network {wid}&#34;,
                    wid=wid,
                    solution_uuid=metadata.get(&#34;solution_uuid&#34;),
                )
    network_view = NetworkView(network_name)
    network_view = network_view.copy()
    network_view.used_ips.append(local_ip)
    ip_address = network_view.get_free_ip(node)
    env = {
        &#34;SOLUTION_IP&#34;: local_ip,
        &#34;HTTP_PORT&#34;: str(port),
        &#34;HTTPS_PORT&#34;: str(tls_port),
        &#34;REMOTE_IP&#34;: gateway.dns_nameserver[0],
        &#34;REMOTE_PORT&#34;: str(gateway.tcp_router_port),
    }
    print(log_config)
    resv_id = self.deploy_container(
        pool_id=pool_id,
        node_id=node_id,
        network_name=network_name,
        ip_address=ip_address,
        flist=&#34;https://hub.grid.tf/omar0.3bot/omarelawady-trc-zinit.flist&#34;,
        disk_type=DiskType.HDD,
        secret_env=secret_env,
        env=env,
        public_ipv6=False,
        log_config=log_config,
        **metadata,
    )
    return resv_id</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.reservation_chatflow.deployer.ChatflowDeployer.expose_and_create_certificate"><code class="name flex">
<span>def <span class="ident">expose_and_create_certificate</span></span>(<span>self, pool_id, gateway_id, network_name, trc_secret, domain, email, solution_ip, solution_port, enforce_https=False, node_id=None, proxy_pool_id=None, log_config=None, bot=None, public_key=&#39;&#39;, **metadata)</span>
</code></dt>
<dd>
<section class="desc"><p>exposes the solution and enable ssl for it's domain</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>pool_id</code></strong></dt>
<dd>the pool used to create your solution</dd>
<dt><strong><code>gateway_id</code></strong></dt>
<dd>Gateway id</dd>
<dt><strong><code>network_name</code></strong></dt>
<dd>Name of the network selected while creating the solution</dd>
<dt><strong><code>trc_secret</code></strong></dt>
<dd>Secret for tcp router</dd>
<dt><strong><code>domain</code></strong></dt>
<dd>the domain we will issue certificate for</dd>
<dt><strong><code>email</code></strong></dt>
<dd>used to issue certificate</dd>
<dt><strong><code>solution_ip</code></strong></dt>
<dd>where your server is hosted (the actual server)</dd>
<dt><strong><code>solution_port</code></strong></dt>
<dd>the port your application is listening on</dd>
<dt><strong><code>enforce_https</code></strong></dt>
<dd>whether you want to only use https or not</dd>
<dt><strong><code>node_id</code></strong></dt>
<dd>your node id</dd>
<dt><strong><code>solution_uuid</code></strong></dt>
<dd>solution id</dd>
<dt><strong><code>public_key</code></strong></dt>
<dd>your public key in case you want to have ssh access on the nginx container</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def expose_and_create_certificate(
    self,
    pool_id,
    gateway_id,
    network_name,
    trc_secret,
    domain,
    email,
    solution_ip,
    solution_port,
    enforce_https=False,
    node_id=None,
    proxy_pool_id=None,
    log_config=None,
    bot=None,
    public_key=&#34;&#34;,
    **metadata,
):
    &#34;&#34;&#34;
    exposes the solution and enable ssl for it&#39;s domain
    Args:
        pool_id: the pool used to create your solution
        gateway_id: Gateway id
        network_name: Name of the network selected while creating the solution
        trc_secret: Secret for tcp router
        domain: the domain we will issue certificate for
        email: used to issue certificate
        solution_ip: where your server is hosted (the actual server)
        solution_port: the port your application is listening on
        enforce_https: whether you want to only use https or not
        node_id: your node id
        solution_uuid: solution id
        public_key: your public key in case you want to have ssh access on the nginx container

    &#34;&#34;&#34;
    test_cert = j.config.get(&#34;TEST_CERT&#34;)
    proxy_pool_id = proxy_pool_id or pool_id
    gateway = self._explorer.gateway.get(gateway_id)

    proxy_id = self.create_proxy(
        pool_id=proxy_pool_id, gateway_id=gateway_id, domain_name=domain, trc_secret=trc_secret, **metadata
    )
    success = self.wait_workload(proxy_id)
    if not success:
        raise DeploymentFailed(
            f&#34;failed to create reverse proxy on gateway {gateway_id} workload {proxy_id}&#34;,
            wid=proxy_id,
            solution_uuid=metadata.get(&#34;solution_uuid&#34;),
        )

    tf_gateway = f&#34;{gateway.dns_nameserver[0]}:{gateway.tcp_router_port}&#34;
    secret_env = {
        &#34;TRC_SECRET&#34;: trc_secret,
        &#34;TFGATEWAY&#34;: tf_gateway,
        &#34;EMAIL&#34;: email,
        &#34;SOLUTION_IP&#34;: solution_ip,
        &#34;SOLUTION_PORT&#34;: str(solution_port),
        &#34;DOMAIN&#34;: domain,
        &#34;ENFORCE_HTTPS&#34;: &#34;true&#34; if enforce_https else &#34;false&#34;,
        &#34;PUBKEY&#34;: public_key,
        &#34;TEST_CERT&#34;: &#34;true&#34; if test_cert else &#34;false&#34;,
    }
    if not node_id:
        node = self.schedule_container(pool_id=pool_id, cru=1, mru=1, hru=1)
        node_id = node.node_id
    else:
        node = self._explorer.nodes.get(node_id)

    res = self.add_network_node(network_name, node, pool_id, bot=bot)
    if res:
        for wid in res[&#34;ids&#34;]:
            success = self.wait_workload(wid, bot, breaking_node_id=node.node_id)
            if not success:
                raise DeploymentFailed(
                    f&#34;failed to add node {node.node_id} to network workload {wid}&#34;,
                    wid=wid,
                    solution_uuid=metadata.get(&#34;solution_uuid&#34;),
                )
    network_view = NetworkView(network_name)
    network_view = network_view.copy()
    ip_address = network_view.get_free_ip(node)
    resv_id = self.deploy_container(
        pool_id=pool_id,
        node_id=node_id,
        network_name=network_name,
        ip_address=ip_address,
        flist=&#34;https://hub.grid.tf/omar0.3bot/omarelawady-nginx-certbot-zinit.flist&#34;,
        disk_type=DiskType.HDD,
        disk_size=512,
        secret_env=secret_env,
        public_ipv6=False,
        log_config=log_config,
        **metadata,
    )
    return resv_id</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.reservation_chatflow.deployer.ChatflowDeployer.extend_pool"><code class="name flex">
<span>def <span class="ident">extend_pool</span></span>(<span>self, bot, pool_id)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def extend_pool(self, bot, pool_id):
    cu, su, currencies = self._pool_form(bot)
    currencies = [&#34;TFT&#34;]
    try:
        pool_info = j.sals.zos.get().pools.extend(pool_id, cu, su, currencies=currencies)
    except Exception as e:
        raise StopChatFlow(f&#34;failed to extend pool.\n{str(e)}&#34;)
    qr_code = self.show_payment(pool_info, bot)
    pool = j.sals.zos.get().pools.get(pool_id)
    trigger_cus = pool.cus + (cu * 0.75) if cu else 0
    trigger_sus = pool.sus + (su * 0.75) if su else 0
    self.wait_pool_payment(bot, pool_id, 10, qr_code, trigger_cus=trigger_cus, trigger_sus=trigger_sus)
    return pool_info</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.reservation_chatflow.deployer.ChatflowDeployer.get_network_view"><code class="name flex">
<span>def <span class="ident">get_network_view</span></span>(<span>self, network_name, workloads=None)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def get_network_view(self, network_name, workloads=None):
    return NetworkView(network_name, workloads)</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.reservation_chatflow.deployer.ChatflowDeployer.get_payment_info"><code class="name flex">
<span>def <span class="ident">get_payment_info</span></span>(<span>self, pool)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def get_payment_info(self, pool):
    escrow_info = pool.escrow_information
    resv_id = pool.reservation_id
    escrow_address = escrow_info.address
    escrow_asset = escrow_info.asset
    total_amount = escrow_info.amount
    total_amount_dec = Decimal(total_amount) / Decimal(1e7)
    thecurrency = escrow_asset.split(&#34;:&#34;)[0]
    return {
        &#34;escrow_info&#34;: escrow_info,
        &#34;resv_id&#34;: resv_id,
        &#34;escrow_address&#34;: escrow_address,
        &#34;escrow_asset&#34;: escrow_asset,
        &#34;total_amount_dec&#34;: total_amount_dec,
        &#34;thecurrency&#34;: thecurrency,
        &#34;total_amount&#34;: total_amount,
    }</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.reservation_chatflow.deployer.ChatflowDeployer.get_pool_farm_id"><code class="name flex">
<span>def <span class="ident">get_pool_farm_id</span></span>(<span>self, pool_id=None, pool=None)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def get_pool_farm_id(self, pool_id=None, pool=None):
    pool = pool or j.sals.zos.get().pools.get(pool_id)
    pool_id = pool.pool_id
    if not pool.node_ids:
        raise StopChatFlow(f&#34;Pool {pool_id} doesn&#39;t contain any nodes&#34;)
    farm_id = None
    while not farm_id:
        for node_id in pool.node_ids:
            try:
                node = self._explorer.nodes.get(node_id)
                farm_id = node.farm_id
                break
            except requests.exceptions.HTTPError:
                continue
        return farm_id or -1</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.reservation_chatflow.deployer.ChatflowDeployer.get_qr_code_payment_info"><code class="name flex">
<span>def <span class="ident">get_qr_code_payment_info</span></span>(<span>self, pool)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def get_qr_code_payment_info(self, pool):
    info = self.get_payment_info(pool)
    total_amount = &#34;{0:f}&#34;.format(info[&#34;total_amount_dec&#34;])
    qr_code = f&#34;{info[&#39;thecurrency&#39;]}:{info[&#39;escrow_address&#39;]}?amount={total_amount}&amp;message=p-{info[&#39;resv_id&#39;]}&amp;sender=me&#34;
    msg_text = f&#34;&#34;&#34;

    &lt;h4&gt; Destination Wallet Address: &lt;/h4&gt;  {info[&#39;escrow_address&#39;]} \n
    &lt;h4&gt; Currency: &lt;/h4&gt;  {info[&#39;thecurrency&#39;]} \n
    &lt;h4&gt; Memo Text (Reservation ID): &lt;/h4&gt;  p-{info[&#39;resv_id&#39;]} \n
    &lt;h4&gt; Total Amount: &lt;/h4&gt; {total_amount} {info[&#39;thecurrency&#39;]} \n

    &lt;h5&gt;Inserting the memo-text is an important way to identify a transaction recipient beyond a wallet address. Failure to do so will result in a failed payment. Please also keep in mind that an additional Transaction fee of 0.1 {info[&#39;thecurrency&#39;]} will automatically occurs per transaction.&lt;/h5&gt;
    &#34;&#34;&#34;

    return msg_text, qr_code</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.reservation_chatflow.deployer.ChatflowDeployer.get_zdb_url"><code class="name flex">
<span>def <span class="ident">get_zdb_url</span></span>(<span>self, zdb_id, password)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def get_zdb_url(self, zdb_id, password):
    workload = j.sals.zos.get().workloads.get(zdb_id)
    result_json = j.data.serializers.json.loads(workload.info.result.data_json)
    if &#34;IPs&#34; in result_json:
        ip = result_json[&#34;IPs&#34;][0]
    else:
        ip = result_json[&#34;IP&#34;]
    namespace = result_json[&#34;Namespace&#34;]
    port = result_json[&#34;Port&#34;]
    url = f&#34;{namespace}:{password}@[{ip}]:{port}&#34;
    return url</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.reservation_chatflow.deployer.ChatflowDeployer.list_all_gateways"><code class="name flex">
<span>def <span class="ident">list_all_gateways</span></span>(<span>self, pool_ids=None)</span>
</code></dt>
<dd>
<section class="desc"><h2 id="args">Args</h2>
<dl>
<dt><strong><code>pool_ids</code></strong></dt>
<dd>if specified it will only list gateways inside these pools</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>dict</code></strong></dt>
<dd>{"gateway_message": {"gateway": g, "pool": pool},}</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def list_all_gateways(self, pool_ids=None):
    &#34;&#34;&#34;
    Args:
        pool_ids: if specified it will only list gateways inside these pools

    Returns:
        dict: {&#34;gateway_message&#34;: {&#34;gateway&#34;: g, &#34;pool&#34;: pool},}
    &#34;&#34;&#34;
    all_gateways = filter(j.sals.zos.get().nodes_finder.filter_is_up, self._explorer.gateway.list())
    if not all_gateways:
        raise StopChatFlow(f&#34;no available gateways&#34;)
    all_pools = [p for p in j.sals.zos.get().pools.list() if p.node_ids]
    available_node_ids = {}  # node_id: pool
    if pool_ids is not None:
        for pool in all_pools:
            if pool.pool_id in pool_ids:
                available_node_ids.update({node_id: pool for node_id in pool.node_ids})
    else:
        for pool in all_pools:
            available_node_ids.update({node_id: pool for node_id in pool.node_ids})
    result = {}
    for gateway in all_gateways:
        if gateway.node_id in available_node_ids:
            if not gateway.dns_nameserver:
                continue
            pool = available_node_ids[gateway.node_id]
            hidden = False
            name = &#34;&#34;
            if f&#34;pool_{pool.pool_id}&#34; in pool_factory.list_all():
                local_config = pool_factory.get(f&#34;pool_{pool.pool_id}&#34;)
                hidden = local_config.hidden
                name = local_config.name
            if hidden:
                continue
            if name:
                message = (
                    f&#34;Pool: {pool.pool_id} Name: {name} {gateway.dns_nameserver[0]}&#34;
                    f&#34; {gateway.location.continent} {gateway.location.country}&#34;
                    f&#34; {gateway.node_id}&#34;
                )
            else:
                message = (
                    f&#34;Pool: {pool.pool_id} {gateway.dns_nameserver[0]}&#34;
                    f&#34; {gateway.location.continent} {gateway.location.country}&#34;
                    f&#34; {gateway.node_id}&#34;
                )
            result[message] = {&#34;gateway&#34;: gateway, &#34;pool&#34;: pool}
    if not result:
        raise StopChatFlow(f&#34;no gateways available in your pools&#34;)
    return result</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.reservation_chatflow.deployer.ChatflowDeployer.list_blocked_managed_domains"><code class="name flex">
<span>def <span class="ident">list_blocked_managed_domains</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def list_blocked_managed_domains(self):
    blocked_domains_keys = j.core.db.keys(f&#34;{DOMAINS_DISALLOW_PREFIX}:*&#34;)
    failure_count_dict = j.core.db.hgetall(DOMAINS_COUNT_KEY)
    blocked_domains_values = j.core.db.mget(blocked_domains_keys)
    result = {}
    for idx, key in enumerate(blocked_domains_keys):
        key = key[len(DOMAINS_DISALLOW_PREFIX) + 1 :]
        node_id = key.decode()
        expiration = int(blocked_domains_values[idx])
        failure_count = int(failure_count_dict[key])
        result[node_id] = {&#34;expiration&#34;: expiration, &#34;failure_count&#34;: failure_count}
    return result</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.reservation_chatflow.deployer.ChatflowDeployer.list_networks"><code class="name flex">
<span>def <span class="ident">list_networks</span></span>(<span>self, next_action=&lt;NextAction.DEPLOY: 3&gt;, sync=True)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def list_networks(self, next_action=NextAction.DEPLOY, sync=True):
    if sync:
        self.load_user_workloads(next_action=next_action)
    networks = {}  # name: last child network resource
    for pool_id in self.workloads[next_action][WorkloadType.Network_resource]:
        for workload in self.workloads[next_action][WorkloadType.Network_resource][pool_id]:
            networks[workload.name] = workload
    all_workloads = []
    for pools_workloads in self.workloads[next_action].values():
        for pool_id, workload_list in pools_workloads.items():
            all_workloads += workload_list
    network_views = {}
    nodes = {node.node_id for node in j.sals.zos.get()._explorer.nodes.list()}
    for network_name in networks:
        network_views[network_name] = NetworkView(network_name, all_workloads, nodes)
    return network_views</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.reservation_chatflow.deployer.ChatflowDeployer.list_pool_gateways"><code class="name flex">
<span>def <span class="ident">list_pool_gateways</span></span>(<span>self, pool_id)</span>
</code></dt>
<dd>
<section class="desc"><p>return dict of gateways where keys are descriptive string of each gateway</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def list_pool_gateways(self, pool_id):
    &#34;&#34;&#34;
    return dict of gateways where keys are descriptive string of each gateway
    &#34;&#34;&#34;
    pool = j.sals.zos.get().pools.get(pool_id)
    farm_id = self.get_pool_farm_id(pool_id)
    if farm_id &lt; 0:
        raise StopChatFlow(f&#34;no available gateways in pool {pool_id} farm: {farm_id}&#34;)
    gateways = self._explorer.gateway.list(farm_id=farm_id)
    if not gateways:
        raise StopChatFlow(f&#34;no available gateways in pool {pool_id} farm: {farm_id}&#34;)
    result = {}
    for g in gateways:
        if not g.dns_nameserver:
            continue
        if g.node_id not in pool.node_ids:
            continue
        result[f&#34;{g.dns_nameserver[0]} {g.location.continent} {g.location.country}&#34; f&#34; {g.node_id}&#34;] = g
    return result</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.reservation_chatflow.deployer.ChatflowDeployer.list_pools"><code class="name flex">
<span>def <span class="ident">list_pools</span></span>(<span>self, cu=None, su=None)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def list_pools(self, cu=None, su=None):
    all_pools = [p for p in j.sals.zos.get().pools.list() if p.node_ids]

    available_pools = {}
    for pool in all_pools:
        hidden = False
        name = &#34;&#34;
        if f&#34;pool_{pool.pool_id}&#34; in pool_factory.list_all():
            local_config = pool_factory.get(f&#34;pool_{pool.pool_id}&#34;)
            hidden = local_config.hidden
            name = local_config.name
        if hidden:
            continue
        res = self.check_pool_capacity(pool, cu, su)
        available = res[0]
        if available:
            resources = res[1:]
            if name:
                resources += (name,)
            available_pools[pool.pool_id] = resources
    return available_pools</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.reservation_chatflow.deployer.ChatflowDeployer.load_user_workloads"><code class="name flex">
<span>def <span class="ident">load_user_workloads</span></span>(<span>self, next_action=&lt;NextAction.DEPLOY: 3&gt;)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def load_user_workloads(self, next_action=NextAction.DEPLOY):
    all_workloads = j.sals.zos.get().workloads.list(j.core.identity.me.tid, next_action)
    self.workloads.pop(next_action, None)
    for workload in all_workloads:
        if workload.info.metadata:
            workload.info.metadata = self.decrypt_metadata(workload.info.metadata)
            try:
                j.data.serializers.json.loads(workload.info.metadata)
            except:
                workload.info.metadata = &#34;{}&#34;
        else:
            workload.info.metadata = &#34;{}&#34;
        self.workloads[workload.info.next_action][workload.info.workload_type][workload.info.pool_id].append(
            workload
        )</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.reservation_chatflow.deployer.ChatflowDeployer.schedule_container"><code class="name flex">
<span>def <span class="ident">schedule_container</span></span>(<span>self, pool_id, cru=None, sru=None, mru=None, hru=None, ip_version=None)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def schedule_container(self, pool_id, cru=None, sru=None, mru=None, hru=None, ip_version=None):
    query = {&#34;cru&#34;: cru, &#34;sru&#34;: sru, &#34;mru&#34;: mru, &#34;hru&#34;: hru, &#34;ip_version&#34;: ip_version}
    return j.sals.reservation_chatflow.reservation_chatflow.get_nodes(1, pool_ids=[pool_id], **query)[0]</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.reservation_chatflow.deployer.ChatflowDeployer.select_gateway"><code class="name flex">
<span>def <span class="ident">select_gateway</span></span>(<span>self, bot, pool_ids=None)</span>
</code></dt>
<dd>
<section class="desc"><h2 id="args">Args</h2>
<dl>
<dt><strong><code>pool_ids</code></strong></dt>
<dd>if specified it will only list gateways inside these pools</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>gateway</code>, <code>pool_objects</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def select_gateway(self, bot, pool_ids=None):
    &#34;&#34;&#34;
    Args:
        pool_ids: if specified it will only list gateways inside these pools

    Returns:
        gateway, pool_objects
    &#34;&#34;&#34;
    gateways = self.list_all_gateways(pool_ids)

    selected = bot.single_choice(&#34;Please select a gateway&#34;, list(gateways.keys()), required=True)
    return gateways[selected][&#34;gateway&#34;], gateways[selected][&#34;pool&#34;]</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.reservation_chatflow.deployer.ChatflowDeployer.select_network"><code class="name flex">
<span>def <span class="ident">select_network</span></span>(<span>self, bot, network_views=None)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def select_network(self, bot, network_views=None):
    network_views = network_views or self.list_networks()
    if not network_views:
        raise StopChatFlow(f&#34;You don&#39;t have any deployed network.&#34;)
    network_name = bot.single_choice(&#34;Please select a network&#34;, list(network_views.keys()), required=True)
    return network_views[network_name]</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.reservation_chatflow.deployer.ChatflowDeployer.select_pool"><code class="name flex">
<span>def <span class="ident">select_pool</span></span>(<span>self, bot, cu=None, su=None, sru=None, mru=None, hru=None, cru=None, available_pools=None, workload_name=None)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def select_pool(
    self, bot, cu=None, su=None, sru=None, mru=None, hru=None, cru=None, available_pools=None, workload_name=None
):
    if j.config.get(&#34;OVER_PROVISIONING&#34;):
        cru = 0
        mru = 0
    available_pools = available_pools or self.list_pools(cu, su)
    if not available_pools:
        raise StopChatFlow(&#34;no available pools with enough capacity for your workload&#34;)
    pool_messages = {}
    for pool in available_pools:
        nodes = j.sals.zos.get().nodes_finder.nodes_by_capacity(pool_id=pool, sru=sru, mru=mru, hru=hru, cru=cru)
        if not nodes:
            continue

        pool_msg = f&#34;Pool: {pool} cu: {available_pools[pool][0]} su:&#34; f&#34; {available_pools[pool][1]}&#34;
        if len(available_pools[pool]) &gt; 2:
            pool_msg += f&#34; Name: {available_pools[pool][2]}&#34;
        pool_messages[pool_msg] = pool
    if not pool_messages:
        raise StopChatFlow(&#34;no available resources in the farms bound to your pools&#34;)
    msg = &#34;Please select a pool&#34;
    if workload_name:
        msg += f&#34; for {workload_name}&#34;
    pool = bot.drop_down_choice(msg, list(pool_messages.keys()), required=True)
    return pool_messages[pool]</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.reservation_chatflow.deployer.ChatflowDeployer.show_payment"><code class="name flex">
<span>def <span class="ident">show_payment</span></span>(<span>self, pool, bot)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def show_payment(self, pool, bot):
    escrow_info = pool.escrow_information
    resv_id = pool.reservation_id
    escrow_address = escrow_info.address
    escrow_asset = escrow_info.asset
    total_amount = escrow_info.amount
    if not total_amount:
        return
    total_amount_dec = Decimal(total_amount) / Decimal(1e7)
    total_amount = &#34;{0:f}&#34;.format(total_amount_dec)

    wallets = j.sals.reservation_chatflow.reservation_chatflow.list_wallets()
    wallet_names = []
    for w in wallets.keys():
        wallet = j.clients.stellar.get(w)
        try:
            balances = wallet.get_balance().balances
        except:
            continue
        for balance in balances:
            if balance.asset_code in escrow_asset:
                if float(balance.balance) &gt; float(total_amount):
                    wallet_names.append(w)
                else:
                    break
    wallet_names.append(&#34;External Wallet (QR Code)&#34;)
    self.msg_payment_info, qr_code = self.get_qr_code_payment_info(pool)
    message = f&#34;&#34;&#34;
    &lt;h3&gt;Billing details:&lt;/h3&gt;&lt;br&gt;
    {self.msg_payment_info}
    &lt;br&gt;&lt;hr&gt;&lt;br&gt;
    &lt;h3&gt; Choose a wallet name to use for payment or proceed with payment through External wallet (QR Code) &lt;/h3&gt;
    &#34;&#34;&#34;
    result = bot.single_choice(message, wallet_names, html=True, required=True)
    if result == &#34;External Wallet (QR Code)&#34;:
        msg_text = f&#34;&#34;&#34;
        &lt;h3&gt;Make a Payment&lt;/h3&gt;
        Scan the QR code with your wallet (do not change the message) or enter the information below manually and proceed with the payment. Make sure to put p-{resv_id} as memo_text value.

        {self.msg_payment_info}

        &#34;&#34;&#34;
        bot.qrcode_show(data=qr_code, msg=msg_text, scale=4, update=True, html=True)
    else:
        wallet = wallets[result]
        wallet.transfer(
            destination_address=escrow_address, amount=total_amount, asset=escrow_asset, memo_text=f&#34;p-{resv_id}&#34;
        )
        return None
    return qr_code</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.reservation_chatflow.deployer.ChatflowDeployer.test_managed_domain"><code class="name flex">
<span>def <span class="ident">test_managed_domain</span></span>(<span>self, gateway_id, managed_domain, pool_id, gateway=None)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def test_managed_domain(self, gateway_id, managed_domain, pool_id, gateway=None):
    gateway = gateway or self._explorer.gateway.get(gateway_id)
    subdomain = f&#34;{uuid.uuid4().hex}.{managed_domain}&#34;
    addresses = [j.sals.nettools.get_host_by_name(gateway.dns_nameserver[0])]
    subdomain_id = self.create_subdomain(pool_id, gateway_id, subdomain, addresses)
    success = self.wait_workload(subdomain_id)
    if not success:
        return False
    try:
        j.sals.nettools.get_host_by_name(subdomain)
    except Exception as e:
        j.logger.error(f&#34;managed domain test failed for {managed_domain} due to error {str(e)}&#34;)
        j.sals.zos.get().workloads.decomission(subdomain_id)
        return False
    j.sals.zos.get().workloads.decomission(subdomain_id)
    return True</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.reservation_chatflow.deployer.ChatflowDeployer.unblock_managed_domain"><code class="name flex">
<span>def <span class="ident">unblock_managed_domain</span></span>(<span>self, managed_domain, reset=True)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def unblock_managed_domain(self, managed_domain, reset=True):
    domain_key = f&#34;{DOMAINS_DISALLOW_PREFIX}:{managed_domain}&#34;
    j.core.db.delete(domain_key)
    if reset:
        j.core.db.hdel(DOMAINS_COUNT_KEY, managed_domain)</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.reservation_chatflow.deployer.ChatflowDeployer.wait_demo_payment"><code class="name flex">
<span>def <span class="ident">wait_demo_payment</span></span>(<span>self, bot, pool_id, exp=5, trigger_cus=0, trigger_sus=1)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def wait_demo_payment(self, bot, pool_id, exp=5, trigger_cus=0, trigger_sus=1):
    expiration = j.data.time.now().timestamp + exp * 60
    msg = &#34;&lt;h2&gt; Waiting for resources provisioning...&lt;/h2&gt;&#34;
    while j.data.time.get().timestamp &lt; expiration:
        bot.md_show_update(msg, html=True)
        pool = j.sals.zos.get().pools.get(pool_id)
        if pool.cus &gt;= trigger_cus and pool.sus &gt;= trigger_sus:
            bot.md_show_update(&#34;Preparing app resources&#34;)
            return True
        gevent.sleep(2)

    return False</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.reservation_chatflow.deployer.ChatflowDeployer.wait_pool_payment"><code class="name flex">
<span>def <span class="ident">wait_pool_payment</span></span>(<span>self, bot, pool_id, exp=5, qr_code=None, trigger_cus=0, trigger_sus=1)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def wait_pool_payment(self, bot, pool_id, exp=5, qr_code=None, trigger_cus=0, trigger_sus=1):
    expiration = j.data.time.now().timestamp + exp * 60
    msg = &#34;&lt;h2&gt; Waiting for payment...&lt;/h2&gt;&#34;
    if qr_code:
        qr_encoded = j.tools.qrcode.base64_get(qr_code, scale=2)
        msg += f&#34;Please scan the QR Code below for the payment details if you missed it from the previous screen&#34;
        qr_code_msg = f&#34;&#34;&#34;
        &lt;div class=&#34;text-center&#34;&gt;
            &lt;img style=&#34;border:1px dashed #85929E&#34; src=&#34;data:image/png;base64,{qr_encoded}&#34;/&gt;
        &lt;/div&gt;
        &#34;&#34;&#34;
        pool = j.sals.zos.get().pools.get(pool_id)
        msg = msg + self.msg_payment_info + qr_code_msg
    while j.data.time.get().timestamp &lt; expiration:
        bot.md_show_update(msg, html=True)
        pool = j.sals.zos.get().pools.get(pool_id)
        if pool.cus &gt;= trigger_cus and pool.sus &gt;= trigger_sus:
            bot.md_show_update(&#34;Preparing app resources&#34;)
            return True
        gevent.sleep(2)

    return False</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.reservation_chatflow.deployer.ChatflowDeployer.wait_workload"><code class="name flex">
<span>def <span class="ident">wait_workload</span></span>(<span>self, workload_id, bot=None, expiry=10, breaking_node_id=None)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def wait_workload(self, workload_id, bot=None, expiry=10, breaking_node_id=None):
    expiry = expiry or 10
    expiration_provisioning = j.data.time.now().timestamp + expiry * 60

    workload = j.sals.zos.get().workloads.get(workload_id)
    if workload.info.workload_type in GATEWAY_WORKLOAD_TYPES:
        node = self._explorer.gateway.get(workload.info.node_id)
    else:
        node = self._explorer.nodes.get(workload.info.node_id)
    # check if the node is up
    if not j.sals.zos.get().nodes_finder.filter_is_up(node):
        cancel = True
        if breaking_node_id and breaking_node_id == node.node_id:
            # if the node is down and it is the same as breaking_node_id
            if workload.info.workload_type == WorkloadType.Network_resource:
                # if the workload is a newtork we don&#39;t cancel it
                cancel = False
        # the node is down but it is not a breaking node_id
        elif workload.info.workload_type == WorkloadType.Network_resource:
            # if the workload is network we can overlook it
            return True
        if cancel:
            j.sals.reservation_chatflow.solutions.cancel_solution([workload_id])
        raise StopChatFlow(f&#34;Workload {workload_id} failed to deploy because the node is down {node.node_id}&#34;)

    # wait for workload
    while True:
        workload = j.sals.zos.get().workloads.get(workload_id)
        remaning_time = j.data.time.get(expiration_provisioning).humanize(granularity=[&#34;minute&#34;, &#34;second&#34;])
        if bot:
            deploying_message = f&#34;&#34;&#34;\
            # Deploying...

            &lt;br /&gt;Workload ID: {workload_id}


            Deployment should take around 2 to 3 minutes, but might take longer and will be cancelled if it is not successful in 10 mins
            &#34;&#34;&#34;
            bot.md_show_update(dedent(deploying_message), md=True)
        if workload.info.result.workload_id:
            success = workload.info.result.state.value == 1
            if not success:
                error_message = workload.info.result.message
                msg = f&#34;Workload {workload.id} failed to deploy due to error {error_message}. For more details: {j.core.identity.me.explorer_url}/reservations/workloads/{workload.id}&#34;
                j.logger.error(msg)
                j.tools.alerthandler.alert_raise(
                    appname=&#34;chatflows&#34;, category=&#34;internal_errors&#34;, message=msg, alert_type=&#34;exception&#34;
                )
            elif workload.info.workload_type != WorkloadType.Network_resource:
                j.sals.reservation_chatflow.reservation_chatflow.unblock_node(workload.info.node_id)
            return success
        if expiration_provisioning &lt; j.data.time.get().timestamp:
            j.sals.reservation_chatflow.reservation_chatflow.block_node(workload.info.node_id)
            if workload.info.workload_type != WorkloadType.Network_resource:
                j.sals.reservation_chatflow.solutions.cancel_solution([workload_id])
            elif breaking_node_id and workload.info.node_id != breaking_node_id:
                return True
            raise StopChatFlow(f&#34;Workload {workload_id} failed to deploy in time&#34;)
        gevent.sleep(1)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="jumpscale.sals.reservation_chatflow.deployer.DeploymentFailed"><code class="flex name class">
<span>class <span class="ident">DeploymentFailed</span></span>
<span>(</span><span>msg=None, solution_uuid=None, wid=None, identity_name=None, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Common base class for all non-exit exceptions.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">class DeploymentFailed(StopChatFlow):
    def __init__(self, msg=None, solution_uuid=None, wid=None, identity_name=None, **kwargs):
        super().__init__(msg, **kwargs)
        self.solution_uuid = solution_uuid
        self.wid = wid
        self.identity_name = identity_name</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="jumpscale.sals.chatflows.chatflows.StopChatFlow" href="../chatflows/chatflows.html#jumpscale.sals.chatflows.chatflows.StopChatFlow">StopChatFlow</a></li>
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
<dt id="jumpscale.sals.reservation_chatflow.deployer.NetworkView"><code class="flex name class">
<span>class <span class="ident">NetworkView</span></span>
<span>(</span><span>name, workloads=None, nodes=None)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">class NetworkView:
    class dry_run_context(ContextDecorator):
        def __init__(self, test_network_name, *args, **kwargs):
            super().__init__(*args, **kwargs)
            self.test_network_name = test_network_name

        def __enter__(self):
            return self

        def __exit__(self, *exc):
            network_view = NetworkView(self.test_network_name)
            for workload in network_view.network_workloads:
                j.sals.zos.get().workloads.decomission(workload.id)

    def __init__(self, name, workloads=None, nodes=None):
        self.name = name
        if not workloads:
            workloads = j.sals.zos.get().workloads.list(j.core.identity.me.tid, NextAction.DEPLOY)
        self.workloads = workloads
        self.used_ips = []
        self.network_workloads = []
        nodes = nodes or {node.node_id for node in j.sals.zos.get()._explorer.nodes.list()}
        self._fill_used_ips(self.workloads, nodes)
        self._init_network_workloads(self.workloads, nodes)
        if self.network_workloads:
            self.iprange = self.network_workloads[0].network_iprange
        else:
            self.iprange = &#34;can&#39;t be retrieved&#34;

    def _init_network_workloads(self, workloads, nodes=None):
        nodes = nodes or {node.node_id for node in j.sals.zos.get()._explorer.nodes.list()}
        for workload in workloads:
            if workload.info.node_id not in nodes:
                continue
            if workload.info.next_action != NextAction.DEPLOY:
                continue
            if workload.info.workload_type == WorkloadType.Network_resource and workload.name == self.name:
                self.network_workloads.append(workload)

    def _fill_used_ips(self, workloads, nodes=None):
        nodes = nodes or {node.node_id for node in j.sals.zos.get()._explorer.nodes.list()}
        for workload in workloads:
            if workload.info.node_id not in nodes:
                continue
            if workload.info.next_action != NextAction.DEPLOY:
                continue
            if workload.info.workload_type == WorkloadType.Kubernetes:
                self.used_ips.append(workload.ipaddress)
            elif workload.info.workload_type == WorkloadType.Container:
                for conn in workload.network_connection:
                    if conn.network_id == self.name:
                        self.used_ips.append(conn.ipaddress)

    def add_node(self, node, pool_id):
        used_ip_ranges = set()
        for workload in self.network_workloads:
            if workload.info.node_id == node.node_id:
                return
            used_ip_ranges.add(workload.iprange)
            for peer in workload.peers:
                used_ip_ranges.add(peer.iprange)
        else:
            network_range = netaddr.IPNetwork(self.iprange)
            for idx, subnet in enumerate(network_range.subnet(24)):
                if str(subnet) not in used_ip_ranges:
                    break
            else:
                raise StopChatFlow(&#34;Failed to find free network&#34;)
            network = j.sals.zos.get().network.create(self.iprange, self.name)
            node_workloads = {}
            for net_workload in self.network_workloads:
                node_workloads[net_workload.info.node_id] = net_workload
            network.network_resources = list(node_workloads.values())  # add only latest network resource for each node
            j.sals.zos.get().network.add_node(network, node.node_id, str(subnet), pool_id)
            return network

    def add_access(self, node_id=None, use_ipv4=True, pool_id=None):
        if node_id and not pool_id:
            raise StopChatFlow(&#34;You must specify the pool id if you specify the node id&#34;)
        node_id = node_id or self.network_workloads[0].info.node_id
        pool_id = pool_id or self.network_workloads[0].info.pool_id
        used_ip_ranges = set()
        for workload in self.network_workloads:
            used_ip_ranges.add(workload.iprange)
            for peer in workload.peers:
                used_ip_ranges.add(peer.iprange)
        else:
            network_range = netaddr.IPNetwork(self.iprange)
            for idx, subnet in enumerate(network_range.subnet(24)):
                if str(subnet) not in used_ip_ranges:
                    break
            else:
                raise StopChatFlow(&#34;Failed to find free network&#34;)
        network = j.sals.zos.get().network.create(self.iprange, self.name)
        node_workloads = {}
        for net_workload in self.network_workloads:
            node_workloads[net_workload.info.node_id] = net_workload
        network.network_resources = list(node_workloads.values())  # add only latest network resource for each node
        if node_id not in node_workloads:
            j.sals.zos.get().network.add_node(network, node_id, str(subnet), pool_id=pool_id)
        wg_quick = j.sals.zos.get().network.add_access(network, node_id, str(subnet), ipv4=use_ipv4)
        return network, wg_quick

    def delete_access(self, ip_range, node_id=None):
        node_id = node_id or self.network_workloads[0].info.node_id
        node_workloads = {}
        for net_workload in self.network_workloads:
            node_workloads[net_workload.info.node_id] = net_workload
        network = j.sals.zos.get().network.create(self.iprange, self.name)
        network.network_resources = list(node_workloads.values())
        network = j.sals.zos.get().network.delete_access(network, node_id, ip_range)
        return network

    def get_node_range(self, node):
        for workload in self.network_workloads:
            if workload.info.next_action != NextAction.DEPLOY:
                continue
            if workload.info.node_id == node.node_id:
                return workload.iprange
        raise StopChatFlow(f&#34;Node {node.node_id} is not part of network&#34;)

    def copy(self):
        return NetworkView(self.name)

    def get_node_free_ips(self, node):
        ip_range = self.get_node_range(node)
        freeips = []
        hosts = netaddr.IPNetwork(ip_range).iter_hosts()
        next(hosts)  # skip ip used by node
        for host in hosts:
            ip = str(host)
            if ip not in self.used_ips:
                freeips.append(ip)
        return freeips

    def get_free_ip(self, node):
        ip_range = self.get_node_range(node)
        hosts = netaddr.IPNetwork(ip_range).iter_hosts()
        next(hosts)  # skip ip used by node
        for host in hosts:
            ip = str(host)
            if ip not in self.used_ips:
                self.used_ips.append(ip)
                return ip
        return None

    def dry_run(self, test_network_name=None, node_ids=None, pool_ids=None, bot=None, breaking_node_ids=None):
        name = test_network_name or uuid.uuid4().hex
        breaking_node_ids = breaking_node_ids or node_ids
        if bot:
            bot.md_show_update(&#34;Starting dry run to check nodes status&#34;)
        ip_range = netaddr.IPNetwork(&#34;10.10.0.0/16&#34;)

        if any([node_ids, pool_ids]) and not all([node_ids, pool_ids]):
            raise StopChatFlow(&#34;you must specify both pool ids and node ids together&#34;)
        node_pool_dict = {}
        if node_ids:
            for idx, node_id in enumerate(node_ids):
                node_pool_dict[node_id] = pool_ids[idx]
        else:
            for workload in self.network_workloads:
                node_pool_dict[workload.info.node_id] = workload.info.pool_id
            node_ids = list(node_pool_dict.keys())
            pool_ids = list(node_pool_dict.values())

        node_ids = list(set(node_ids))
        network = j.sals.zos.get().network.create(str(ip_range), name)
        for idx, subnet in enumerate(ip_range.subnet(24)):
            if idx == len(node_ids):
                break
            j.sals.zos.get().network.add_node(network, node_ids[idx], str(subnet), node_pool_dict[node_ids[idx]])
        result = []
        for resource in network.network_resources:
            if bot:
                bot.md_show_update(f&#34;testing deployment on node {resource.info.node_id}&#34;)
            try:
                result.append(j.sals.zos.get().workloads.deploy(resource))
            except Exception as e:
                raise StopChatFlow(
                    f&#34;failed to deploy workload on node {resource.info.node_id} due to&#34; f&#34; error {str(e)}&#34;
                )
        for idx, wid in enumerate(result):
            try:
                deployer.wait_workload(wid, bot, 2)
            except StopChatFlow:
                workload = j.sals.zos.get().workloads.get(wid)
                # if not a breaking nodes (old node not used for deployment) we can overlook it
                if workload.info.node_id not in breaking_node_ids:
                    continue
                j.sals.reservation_chatflow.reservation_chatflow.block_node(network.network_resources[idx].info.node_id)
                raise StopChatFlow(
                    &#34;Network nodes dry run failed on node&#34; f&#34; {network.network_resources[idx].info.node_id}&#34;
                )</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="jumpscale.sals.reservation_chatflow.deployer.NetworkView.dry_run_context"><code class="name">var <span class="ident">dry_run_context</span></code></dt>
<dd>
<section class="desc"><p>A base class or mixin that enables context managers to work as decorators.</p></section>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="jumpscale.sals.reservation_chatflow.deployer.NetworkView.add_access"><code class="name flex">
<span>def <span class="ident">add_access</span></span>(<span>self, node_id=None, use_ipv4=True, pool_id=None)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def add_access(self, node_id=None, use_ipv4=True, pool_id=None):
    if node_id and not pool_id:
        raise StopChatFlow(&#34;You must specify the pool id if you specify the node id&#34;)
    node_id = node_id or self.network_workloads[0].info.node_id
    pool_id = pool_id or self.network_workloads[0].info.pool_id
    used_ip_ranges = set()
    for workload in self.network_workloads:
        used_ip_ranges.add(workload.iprange)
        for peer in workload.peers:
            used_ip_ranges.add(peer.iprange)
    else:
        network_range = netaddr.IPNetwork(self.iprange)
        for idx, subnet in enumerate(network_range.subnet(24)):
            if str(subnet) not in used_ip_ranges:
                break
        else:
            raise StopChatFlow(&#34;Failed to find free network&#34;)
    network = j.sals.zos.get().network.create(self.iprange, self.name)
    node_workloads = {}
    for net_workload in self.network_workloads:
        node_workloads[net_workload.info.node_id] = net_workload
    network.network_resources = list(node_workloads.values())  # add only latest network resource for each node
    if node_id not in node_workloads:
        j.sals.zos.get().network.add_node(network, node_id, str(subnet), pool_id=pool_id)
    wg_quick = j.sals.zos.get().network.add_access(network, node_id, str(subnet), ipv4=use_ipv4)
    return network, wg_quick</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.reservation_chatflow.deployer.NetworkView.add_node"><code class="name flex">
<span>def <span class="ident">add_node</span></span>(<span>self, node, pool_id)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def add_node(self, node, pool_id):
    used_ip_ranges = set()
    for workload in self.network_workloads:
        if workload.info.node_id == node.node_id:
            return
        used_ip_ranges.add(workload.iprange)
        for peer in workload.peers:
            used_ip_ranges.add(peer.iprange)
    else:
        network_range = netaddr.IPNetwork(self.iprange)
        for idx, subnet in enumerate(network_range.subnet(24)):
            if str(subnet) not in used_ip_ranges:
                break
        else:
            raise StopChatFlow(&#34;Failed to find free network&#34;)
        network = j.sals.zos.get().network.create(self.iprange, self.name)
        node_workloads = {}
        for net_workload in self.network_workloads:
            node_workloads[net_workload.info.node_id] = net_workload
        network.network_resources = list(node_workloads.values())  # add only latest network resource for each node
        j.sals.zos.get().network.add_node(network, node.node_id, str(subnet), pool_id)
        return network</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.reservation_chatflow.deployer.NetworkView.copy"><code class="name flex">
<span>def <span class="ident">copy</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def copy(self):
    return NetworkView(self.name)</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.reservation_chatflow.deployer.NetworkView.delete_access"><code class="name flex">
<span>def <span class="ident">delete_access</span></span>(<span>self, ip_range, node_id=None)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def delete_access(self, ip_range, node_id=None):
    node_id = node_id or self.network_workloads[0].info.node_id
    node_workloads = {}
    for net_workload in self.network_workloads:
        node_workloads[net_workload.info.node_id] = net_workload
    network = j.sals.zos.get().network.create(self.iprange, self.name)
    network.network_resources = list(node_workloads.values())
    network = j.sals.zos.get().network.delete_access(network, node_id, ip_range)
    return network</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.reservation_chatflow.deployer.NetworkView.dry_run"><code class="name flex">
<span>def <span class="ident">dry_run</span></span>(<span>self, test_network_name=None, node_ids=None, pool_ids=None, bot=None, breaking_node_ids=None)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def dry_run(self, test_network_name=None, node_ids=None, pool_ids=None, bot=None, breaking_node_ids=None):
    name = test_network_name or uuid.uuid4().hex
    breaking_node_ids = breaking_node_ids or node_ids
    if bot:
        bot.md_show_update(&#34;Starting dry run to check nodes status&#34;)
    ip_range = netaddr.IPNetwork(&#34;10.10.0.0/16&#34;)

    if any([node_ids, pool_ids]) and not all([node_ids, pool_ids]):
        raise StopChatFlow(&#34;you must specify both pool ids and node ids together&#34;)
    node_pool_dict = {}
    if node_ids:
        for idx, node_id in enumerate(node_ids):
            node_pool_dict[node_id] = pool_ids[idx]
    else:
        for workload in self.network_workloads:
            node_pool_dict[workload.info.node_id] = workload.info.pool_id
        node_ids = list(node_pool_dict.keys())
        pool_ids = list(node_pool_dict.values())

    node_ids = list(set(node_ids))
    network = j.sals.zos.get().network.create(str(ip_range), name)
    for idx, subnet in enumerate(ip_range.subnet(24)):
        if idx == len(node_ids):
            break
        j.sals.zos.get().network.add_node(network, node_ids[idx], str(subnet), node_pool_dict[node_ids[idx]])
    result = []
    for resource in network.network_resources:
        if bot:
            bot.md_show_update(f&#34;testing deployment on node {resource.info.node_id}&#34;)
        try:
            result.append(j.sals.zos.get().workloads.deploy(resource))
        except Exception as e:
            raise StopChatFlow(
                f&#34;failed to deploy workload on node {resource.info.node_id} due to&#34; f&#34; error {str(e)}&#34;
            )
    for idx, wid in enumerate(result):
        try:
            deployer.wait_workload(wid, bot, 2)
        except StopChatFlow:
            workload = j.sals.zos.get().workloads.get(wid)
            # if not a breaking nodes (old node not used for deployment) we can overlook it
            if workload.info.node_id not in breaking_node_ids:
                continue
            j.sals.reservation_chatflow.reservation_chatflow.block_node(network.network_resources[idx].info.node_id)
            raise StopChatFlow(
                &#34;Network nodes dry run failed on node&#34; f&#34; {network.network_resources[idx].info.node_id}&#34;
            )</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.reservation_chatflow.deployer.NetworkView.get_free_ip"><code class="name flex">
<span>def <span class="ident">get_free_ip</span></span>(<span>self, node)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def get_free_ip(self, node):
    ip_range = self.get_node_range(node)
    hosts = netaddr.IPNetwork(ip_range).iter_hosts()
    next(hosts)  # skip ip used by node
    for host in hosts:
        ip = str(host)
        if ip not in self.used_ips:
            self.used_ips.append(ip)
            return ip
    return None</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.reservation_chatflow.deployer.NetworkView.get_node_free_ips"><code class="name flex">
<span>def <span class="ident">get_node_free_ips</span></span>(<span>self, node)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def get_node_free_ips(self, node):
    ip_range = self.get_node_range(node)
    freeips = []
    hosts = netaddr.IPNetwork(ip_range).iter_hosts()
    next(hosts)  # skip ip used by node
    for host in hosts:
        ip = str(host)
        if ip not in self.used_ips:
            freeips.append(ip)
    return freeips</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.reservation_chatflow.deployer.NetworkView.get_node_range"><code class="name flex">
<span>def <span class="ident">get_node_range</span></span>(<span>self, node)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def get_node_range(self, node):
    for workload in self.network_workloads:
        if workload.info.next_action != NextAction.DEPLOY:
            continue
        if workload.info.node_id == node.node_id:
            return workload.iprange
    raise StopChatFlow(f&#34;Node {node.node_id} is not part of network&#34;)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="jumpscale.sals.reservation_chatflow.deployer.deployment_context"><code class="flex name class">
<span>class <span class="ident">deployment_context</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>A base class or mixin that enables context managers to work as decorators.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">class deployment_context(ContextDecorator):
    def __enter__(self):
        return self

    def __exit__(self, exc_type, exc, exc_tb):
        if exc_type != DeploymentFailed:
            return
        if exc.solution_uuid:
            # cancel related workloads
            j.logger.info(f&#34;canceling workload ids of solution_uuid: {exc.solution_uuid}&#34;)
            j.sals.reservation_chatflow.solutions.cancel_solution_by_uuid(exc.solution_uuid)
        if exc.wid:
            # block the failed node if the workload is network or container
            zos = j.sals.zos.get(exc.identity_name)
            workload = zos.workloads.get(exc.wid)
            if workload.info.workload_type in NODE_BLOCKING_WORKLOAD_TYPES:
                j.logger.info(f&#34;blocking node {workload.info.node_id} for failed workload {workload.id}&#34;)
                j.sals.reservation_chatflow.reservation_chatflow.block_node(workload.info.node_id)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>contextlib.ContextDecorator</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="jumpscale.sals.reservation_chatflow" href="index.html">jumpscale.sals.reservation_chatflow</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="jumpscale.sals.reservation_chatflow.deployer.ChatflowDeployer" href="#jumpscale.sals.reservation_chatflow.deployer.ChatflowDeployer">ChatflowDeployer</a></code></h4>
<ul class="">
<li><code><a title="jumpscale.sals.reservation_chatflow.deployer.ChatflowDeployer.add_access" href="#jumpscale.sals.reservation_chatflow.deployer.ChatflowDeployer.add_access">add_access</a></code></li>
<li><code><a title="jumpscale.sals.reservation_chatflow.deployer.ChatflowDeployer.add_network_node" href="#jumpscale.sals.reservation_chatflow.deployer.ChatflowDeployer.add_network_node">add_network_node</a></code></li>
<li><code><a title="jumpscale.sals.reservation_chatflow.deployer.ChatflowDeployer.ask_container_logs" href="#jumpscale.sals.reservation_chatflow.deployer.ChatflowDeployer.ask_container_logs">ask_container_logs</a></code></li>
<li><code><a title="jumpscale.sals.reservation_chatflow.deployer.ChatflowDeployer.ask_container_placement" href="#jumpscale.sals.reservation_chatflow.deployer.ChatflowDeployer.ask_container_placement">ask_container_placement</a></code></li>
<li><code><a title="jumpscale.sals.reservation_chatflow.deployer.ChatflowDeployer.ask_container_resources" href="#jumpscale.sals.reservation_chatflow.deployer.ChatflowDeployer.ask_container_resources">ask_container_resources</a></code></li>
<li><code><a title="jumpscale.sals.reservation_chatflow.deployer.ChatflowDeployer.ask_email" href="#jumpscale.sals.reservation_chatflow.deployer.ChatflowDeployer.ask_email">ask_email</a></code></li>
<li><code><a title="jumpscale.sals.reservation_chatflow.deployer.ChatflowDeployer.ask_ipv6" href="#jumpscale.sals.reservation_chatflow.deployer.ChatflowDeployer.ask_ipv6">ask_ipv6</a></code></li>
<li><code><a title="jumpscale.sals.reservation_chatflow.deployer.ChatflowDeployer.ask_multi_pool_distribution" href="#jumpscale.sals.reservation_chatflow.deployer.ChatflowDeployer.ask_multi_pool_distribution">ask_multi_pool_distribution</a></code></li>
<li><code><a title="jumpscale.sals.reservation_chatflow.deployer.ChatflowDeployer.ask_multi_pool_placement" href="#jumpscale.sals.reservation_chatflow.deployer.ChatflowDeployer.ask_multi_pool_placement">ask_multi_pool_placement</a></code></li>
<li><code><a title="jumpscale.sals.reservation_chatflow.deployer.ChatflowDeployer.ask_name" href="#jumpscale.sals.reservation_chatflow.deployer.ChatflowDeployer.ask_name">ask_name</a></code></li>
<li><code><a title="jumpscale.sals.reservation_chatflow.deployer.ChatflowDeployer.block_managed_domain" href="#jumpscale.sals.reservation_chatflow.deployer.ChatflowDeployer.block_managed_domain">block_managed_domain</a></code></li>
<li><code><a title="jumpscale.sals.reservation_chatflow.deployer.ChatflowDeployer.calculate_capacity_units" href="#jumpscale.sals.reservation_chatflow.deployer.ChatflowDeployer.calculate_capacity_units">calculate_capacity_units</a></code></li>
<li><code><a title="jumpscale.sals.reservation_chatflow.deployer.ChatflowDeployer.chatflow_network_check" href="#jumpscale.sals.reservation_chatflow.deployer.ChatflowDeployer.chatflow_network_check">chatflow_network_check</a></code></li>
<li><code><a title="jumpscale.sals.reservation_chatflow.deployer.ChatflowDeployer.chatflow_pools_check" href="#jumpscale.sals.reservation_chatflow.deployer.ChatflowDeployer.chatflow_pools_check">chatflow_pools_check</a></code></li>
<li><code><a title="jumpscale.sals.reservation_chatflow.deployer.ChatflowDeployer.check_farm_capacity" href="#jumpscale.sals.reservation_chatflow.deployer.ChatflowDeployer.check_farm_capacity">check_farm_capacity</a></code></li>
<li><code><a title="jumpscale.sals.reservation_chatflow.deployer.ChatflowDeployer.check_pool_capacity" href="#jumpscale.sals.reservation_chatflow.deployer.ChatflowDeployer.check_pool_capacity">check_pool_capacity</a></code></li>
<li><code><a title="jumpscale.sals.reservation_chatflow.deployer.ChatflowDeployer.create_ipv6_gateway" href="#jumpscale.sals.reservation_chatflow.deployer.ChatflowDeployer.create_ipv6_gateway">create_ipv6_gateway</a></code></li>
<li><code><a title="jumpscale.sals.reservation_chatflow.deployer.ChatflowDeployer.create_pool" href="#jumpscale.sals.reservation_chatflow.deployer.ChatflowDeployer.create_pool">create_pool</a></code></li>
<li><code><a title="jumpscale.sals.reservation_chatflow.deployer.ChatflowDeployer.create_proxy" href="#jumpscale.sals.reservation_chatflow.deployer.ChatflowDeployer.create_proxy">create_proxy</a></code></li>
<li><code><a title="jumpscale.sals.reservation_chatflow.deployer.ChatflowDeployer.create_subdomain" href="#jumpscale.sals.reservation_chatflow.deployer.ChatflowDeployer.create_subdomain">create_subdomain</a></code></li>
<li><code><a title="jumpscale.sals.reservation_chatflow.deployer.ChatflowDeployer.decrypt_metadata" href="#jumpscale.sals.reservation_chatflow.deployer.ChatflowDeployer.decrypt_metadata">decrypt_metadata</a></code></li>
<li><code><a title="jumpscale.sals.reservation_chatflow.deployer.ChatflowDeployer.delegate_domain" href="#jumpscale.sals.reservation_chatflow.deployer.ChatflowDeployer.delegate_domain">delegate_domain</a></code></li>
<li><code><a title="jumpscale.sals.reservation_chatflow.deployer.ChatflowDeployer.delete_access" href="#jumpscale.sals.reservation_chatflow.deployer.ChatflowDeployer.delete_access">delete_access</a></code></li>
<li><code><a title="jumpscale.sals.reservation_chatflow.deployer.ChatflowDeployer.deploy_container" href="#jumpscale.sals.reservation_chatflow.deployer.ChatflowDeployer.deploy_container">deploy_container</a></code></li>
<li><code><a title="jumpscale.sals.reservation_chatflow.deployer.ChatflowDeployer.deploy_kubernetes_cluster" href="#jumpscale.sals.reservation_chatflow.deployer.ChatflowDeployer.deploy_kubernetes_cluster">deploy_kubernetes_cluster</a></code></li>
<li><code><a title="jumpscale.sals.reservation_chatflow.deployer.ChatflowDeployer.deploy_kubernetes_master" href="#jumpscale.sals.reservation_chatflow.deployer.ChatflowDeployer.deploy_kubernetes_master">deploy_kubernetes_master</a></code></li>
<li><code><a title="jumpscale.sals.reservation_chatflow.deployer.ChatflowDeployer.deploy_kubernetes_worker" href="#jumpscale.sals.reservation_chatflow.deployer.ChatflowDeployer.deploy_kubernetes_worker">deploy_kubernetes_worker</a></code></li>
<li><code><a title="jumpscale.sals.reservation_chatflow.deployer.ChatflowDeployer.deploy_minio_containers" href="#jumpscale.sals.reservation_chatflow.deployer.ChatflowDeployer.deploy_minio_containers">deploy_minio_containers</a></code></li>
<li><code><a title="jumpscale.sals.reservation_chatflow.deployer.ChatflowDeployer.deploy_minio_zdb" href="#jumpscale.sals.reservation_chatflow.deployer.ChatflowDeployer.deploy_minio_zdb">deploy_minio_zdb</a></code></li>
<li><code><a title="jumpscale.sals.reservation_chatflow.deployer.ChatflowDeployer.deploy_network" href="#jumpscale.sals.reservation_chatflow.deployer.ChatflowDeployer.deploy_network">deploy_network</a></code></li>
<li><code><a title="jumpscale.sals.reservation_chatflow.deployer.ChatflowDeployer.deploy_volume" href="#jumpscale.sals.reservation_chatflow.deployer.ChatflowDeployer.deploy_volume">deploy_volume</a></code></li>
<li><code><a title="jumpscale.sals.reservation_chatflow.deployer.ChatflowDeployer.deploy_zdb" href="#jumpscale.sals.reservation_chatflow.deployer.ChatflowDeployer.deploy_zdb">deploy_zdb</a></code></li>
<li><code><a title="jumpscale.sals.reservation_chatflow.deployer.ChatflowDeployer.encrypt_metadata" href="#jumpscale.sals.reservation_chatflow.deployer.ChatflowDeployer.encrypt_metadata">encrypt_metadata</a></code></li>
<li><code><a title="jumpscale.sals.reservation_chatflow.deployer.ChatflowDeployer.expose_address" href="#jumpscale.sals.reservation_chatflow.deployer.ChatflowDeployer.expose_address">expose_address</a></code></li>
<li><code><a title="jumpscale.sals.reservation_chatflow.deployer.ChatflowDeployer.expose_and_create_certificate" href="#jumpscale.sals.reservation_chatflow.deployer.ChatflowDeployer.expose_and_create_certificate">expose_and_create_certificate</a></code></li>
<li><code><a title="jumpscale.sals.reservation_chatflow.deployer.ChatflowDeployer.extend_pool" href="#jumpscale.sals.reservation_chatflow.deployer.ChatflowDeployer.extend_pool">extend_pool</a></code></li>
<li><code><a title="jumpscale.sals.reservation_chatflow.deployer.ChatflowDeployer.get_network_view" href="#jumpscale.sals.reservation_chatflow.deployer.ChatflowDeployer.get_network_view">get_network_view</a></code></li>
<li><code><a title="jumpscale.sals.reservation_chatflow.deployer.ChatflowDeployer.get_payment_info" href="#jumpscale.sals.reservation_chatflow.deployer.ChatflowDeployer.get_payment_info">get_payment_info</a></code></li>
<li><code><a title="jumpscale.sals.reservation_chatflow.deployer.ChatflowDeployer.get_pool_farm_id" href="#jumpscale.sals.reservation_chatflow.deployer.ChatflowDeployer.get_pool_farm_id">get_pool_farm_id</a></code></li>
<li><code><a title="jumpscale.sals.reservation_chatflow.deployer.ChatflowDeployer.get_qr_code_payment_info" href="#jumpscale.sals.reservation_chatflow.deployer.ChatflowDeployer.get_qr_code_payment_info">get_qr_code_payment_info</a></code></li>
<li><code><a title="jumpscale.sals.reservation_chatflow.deployer.ChatflowDeployer.get_zdb_url" href="#jumpscale.sals.reservation_chatflow.deployer.ChatflowDeployer.get_zdb_url">get_zdb_url</a></code></li>
<li><code><a title="jumpscale.sals.reservation_chatflow.deployer.ChatflowDeployer.list_all_gateways" href="#jumpscale.sals.reservation_chatflow.deployer.ChatflowDeployer.list_all_gateways">list_all_gateways</a></code></li>
<li><code><a title="jumpscale.sals.reservation_chatflow.deployer.ChatflowDeployer.list_blocked_managed_domains" href="#jumpscale.sals.reservation_chatflow.deployer.ChatflowDeployer.list_blocked_managed_domains">list_blocked_managed_domains</a></code></li>
<li><code><a title="jumpscale.sals.reservation_chatflow.deployer.ChatflowDeployer.list_networks" href="#jumpscale.sals.reservation_chatflow.deployer.ChatflowDeployer.list_networks">list_networks</a></code></li>
<li><code><a title="jumpscale.sals.reservation_chatflow.deployer.ChatflowDeployer.list_pool_gateways" href="#jumpscale.sals.reservation_chatflow.deployer.ChatflowDeployer.list_pool_gateways">list_pool_gateways</a></code></li>
<li><code><a title="jumpscale.sals.reservation_chatflow.deployer.ChatflowDeployer.list_pools" href="#jumpscale.sals.reservation_chatflow.deployer.ChatflowDeployer.list_pools">list_pools</a></code></li>
<li><code><a title="jumpscale.sals.reservation_chatflow.deployer.ChatflowDeployer.load_user_workloads" href="#jumpscale.sals.reservation_chatflow.deployer.ChatflowDeployer.load_user_workloads">load_user_workloads</a></code></li>
<li><code><a title="jumpscale.sals.reservation_chatflow.deployer.ChatflowDeployer.schedule_container" href="#jumpscale.sals.reservation_chatflow.deployer.ChatflowDeployer.schedule_container">schedule_container</a></code></li>
<li><code><a title="jumpscale.sals.reservation_chatflow.deployer.ChatflowDeployer.select_gateway" href="#jumpscale.sals.reservation_chatflow.deployer.ChatflowDeployer.select_gateway">select_gateway</a></code></li>
<li><code><a title="jumpscale.sals.reservation_chatflow.deployer.ChatflowDeployer.select_network" href="#jumpscale.sals.reservation_chatflow.deployer.ChatflowDeployer.select_network">select_network</a></code></li>
<li><code><a title="jumpscale.sals.reservation_chatflow.deployer.ChatflowDeployer.select_pool" href="#jumpscale.sals.reservation_chatflow.deployer.ChatflowDeployer.select_pool">select_pool</a></code></li>
<li><code><a title="jumpscale.sals.reservation_chatflow.deployer.ChatflowDeployer.show_payment" href="#jumpscale.sals.reservation_chatflow.deployer.ChatflowDeployer.show_payment">show_payment</a></code></li>
<li><code><a title="jumpscale.sals.reservation_chatflow.deployer.ChatflowDeployer.test_managed_domain" href="#jumpscale.sals.reservation_chatflow.deployer.ChatflowDeployer.test_managed_domain">test_managed_domain</a></code></li>
<li><code><a title="jumpscale.sals.reservation_chatflow.deployer.ChatflowDeployer.unblock_managed_domain" href="#jumpscale.sals.reservation_chatflow.deployer.ChatflowDeployer.unblock_managed_domain">unblock_managed_domain</a></code></li>
<li><code><a title="jumpscale.sals.reservation_chatflow.deployer.ChatflowDeployer.wait_demo_payment" href="#jumpscale.sals.reservation_chatflow.deployer.ChatflowDeployer.wait_demo_payment">wait_demo_payment</a></code></li>
<li><code><a title="jumpscale.sals.reservation_chatflow.deployer.ChatflowDeployer.wait_pool_payment" href="#jumpscale.sals.reservation_chatflow.deployer.ChatflowDeployer.wait_pool_payment">wait_pool_payment</a></code></li>
<li><code><a title="jumpscale.sals.reservation_chatflow.deployer.ChatflowDeployer.wait_workload" href="#jumpscale.sals.reservation_chatflow.deployer.ChatflowDeployer.wait_workload">wait_workload</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="jumpscale.sals.reservation_chatflow.deployer.DeploymentFailed" href="#jumpscale.sals.reservation_chatflow.deployer.DeploymentFailed">DeploymentFailed</a></code></h4>
</li>
<li>
<h4><code><a title="jumpscale.sals.reservation_chatflow.deployer.NetworkView" href="#jumpscale.sals.reservation_chatflow.deployer.NetworkView">NetworkView</a></code></h4>
<ul class="two-column">
<li><code><a title="jumpscale.sals.reservation_chatflow.deployer.NetworkView.add_access" href="#jumpscale.sals.reservation_chatflow.deployer.NetworkView.add_access">add_access</a></code></li>
<li><code><a title="jumpscale.sals.reservation_chatflow.deployer.NetworkView.add_node" href="#jumpscale.sals.reservation_chatflow.deployer.NetworkView.add_node">add_node</a></code></li>
<li><code><a title="jumpscale.sals.reservation_chatflow.deployer.NetworkView.copy" href="#jumpscale.sals.reservation_chatflow.deployer.NetworkView.copy">copy</a></code></li>
<li><code><a title="jumpscale.sals.reservation_chatflow.deployer.NetworkView.delete_access" href="#jumpscale.sals.reservation_chatflow.deployer.NetworkView.delete_access">delete_access</a></code></li>
<li><code><a title="jumpscale.sals.reservation_chatflow.deployer.NetworkView.dry_run" href="#jumpscale.sals.reservation_chatflow.deployer.NetworkView.dry_run">dry_run</a></code></li>
<li><code><a title="jumpscale.sals.reservation_chatflow.deployer.NetworkView.dry_run_context" href="#jumpscale.sals.reservation_chatflow.deployer.NetworkView.dry_run_context">dry_run_context</a></code></li>
<li><code><a title="jumpscale.sals.reservation_chatflow.deployer.NetworkView.get_free_ip" href="#jumpscale.sals.reservation_chatflow.deployer.NetworkView.get_free_ip">get_free_ip</a></code></li>
<li><code><a title="jumpscale.sals.reservation_chatflow.deployer.NetworkView.get_node_free_ips" href="#jumpscale.sals.reservation_chatflow.deployer.NetworkView.get_node_free_ips">get_node_free_ips</a></code></li>
<li><code><a title="jumpscale.sals.reservation_chatflow.deployer.NetworkView.get_node_range" href="#jumpscale.sals.reservation_chatflow.deployer.NetworkView.get_node_range">get_node_range</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="jumpscale.sals.reservation_chatflow.deployer.deployment_context" href="#jumpscale.sals.reservation_chatflow.deployer.deployment_context">deployment_context</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.6.4</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>
