<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.6.4" />
<title>jumpscale.sals.reservation_chatflow.reservation_chatflow API documentation</title>
<meta name="description" content="" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase;cursor:pointer}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>jumpscale.sals.reservation_chatflow.reservation_chatflow</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>Source code</summary>
<pre><code class="python">import base64
import copy
import json
import random
import time
from textwrap import dedent

import netaddr
import requests
from nacl.public import Box

from jumpscale.clients.explorer.models import DeployedReservation, NextAction
from jumpscale.clients.stellar.stellar import Network as StellarNetwork
from jumpscale.core.base import StoredFactory
from jumpscale.loader import j
from jumpscale.sals.chatflows.chatflows import StopChatFlow
from jumpscale.sals.reservation_chatflow.models import SolutionType, TfgridSolution1, TfgridSolutionsPayment1

NODES_DISALLOW_PREFIX = &#34;ZOS:NODES:DISALLOWED&#34;
NODES_DISALLOW_EXPIRATION = 60 * 60 * 4  # 4 hours
NODES_COUNT_KEY = &#34;ZOS:NODES:FAILURE_COUNT&#34;


class Network:
    def __init__(self, network, expiration, bot, reservations, currency, resv_id):
        &#34;&#34;&#34;Network class is responsible for creation and management of networks
            you can add, update, list, get, filter nodes
        Args:
            network (jumpscale.clients.explorer.models.TfgridWorkloadsReservationNetwork1): network object
            expiration (datetime): timestamp of the date for network expiration
            bot (GedisChatBot):Instance from the bot that uses network
            reservations (list of TfgridWorkloadsReservationData1): list of reservations
            currency (str): currency used &#34;TFT&#34;, &#34;FreeTFT&#34;
            resv_id (int): reservation ID
        &#34;&#34;&#34;
        self._network = network
        self._expiration = expiration
        self.name = network.name
        self._used_ips = []
        self._is_dirty = False
        self._sal = j.sals.reservation_chatflow
        self._bot = bot
        self._fill_used_ips(reservations)
        self.currency = currency
        self.resv_id = resv_id
        self.solutions = StoredFactory(TfgridSolution1)

    def _fill_used_ips(self, reservations):
        for reservation in reservations:
            if reservation.next_action != NextAction.DEPLOY:
                continue
            for kubernetes in reservation.data_reservation.kubernetes:
                if kubernetes.network_id == self._network.name:
                    self._used_ips.append(kubernetes.ipaddress)
            for container in reservation.data_reservation.containers:
                for nc in container.network_connection:
                    if nc.network_id == self._network.name:
                        self._used_ips.append(nc.ipaddress)

    def add_node(self, node):
        &#34;&#34;&#34;add node to the network

        Args:
            node (jumpscale.clients.explorer.models.TfgridDirectoryNode2): node object
        &#34;&#34;&#34;
        network_resources = self._network.network_resources
        used_ip_ranges = set()
        for network_resource in network_resources:
            if network_resource.node_id == node.node_id:
                return
            used_ip_ranges.add(network_resource.iprange)
            for peer in network_resource.peers:
                used_ip_ranges.add(peer.iprange)
        else:
            network_range = netaddr.IPNetwork(self._network.iprange)
            subnet = None
            for _, subnet in enumerate(network_range.subnet(24)):
                if str(subnet) not in used_ip_ranges:
                    break
            else:
                self._bot.stop(&#34;Failed to find free network&#34;)
            j.sals.zos.get().network.add_node(self._network, node.node_id, str(subnet))
            self._is_dirty = True

    def get_node_range(self, node):
        &#34;&#34;&#34;get ip range from specified node

        Args:
            node (jumpscale.client.explorer.models.TfgridDirectoryNode2): node object

        Returns:
            (IPRange): ip range field
        &#34;&#34;&#34;
        for network_resource in self._network.network_resources:
            if network_resource.node_id == node.node_id:
                return network_resource.iprange
        self._bot.stop(f&#34;Node {node.node_id} is not part of network&#34;)

    def update(self, tid, currency=None, bot=None):
        &#34;&#34;&#34;create reservations and update status and show payments stuff
        Args:
            tid (int): customer tid (j.core.identity.me.tid)
            currency (str, optional): &#34;TFT&#34; or &#34;FreeTFT&#34;. Defaults to None.
            bot (GedisChatBot, optional): bot instance. Defaults to None.

        Returns:
            bool: True if successful
        &#34;&#34;&#34;
        if self._is_dirty:
            reservation = j.sals.zos.get().reservation_create()
            reservation.data_reservation.networks.append(self._network)
            form_info = {
                &#34;chatflow&#34;: &#34;network&#34;,
                &#34;Currency&#34;: self.currency,
                &#34;Solution expiration&#34;: self._expiration.timestamp(),
            }
            metadata = j.sals.reservation_chatflow.get_solution_metadata(
                self.name, SolutionType.Network, form_info=form_info
            )

            metadata[&#34;parent_network&#34;] = self.resv_id
            self._sal.add_reservation_metadata(reservation, metadata)

            reservation_create = self._sal.register_reservation(
                reservation, self._expiration.timestamp(), tid, currency=currency, bot=bot
            )
            rid = reservation_create.reservation_id
            payment, _ = j.sals.reservation_chatflow.show_payments(self._bot, reservation_create, currency)
            if payment[&#34;free&#34;]:
                pass
            elif payment[&#34;wallet&#34;]:
                j.sals.zos.get().billing.payout_farmers(payment[&#34;wallet&#34;], reservation_create)
                j.sals.reservation_chatflow.wait_payment(bot, rid, threebot_app=False)
            else:
                j.sals.reservation_chatflow.wait_payment(
                    bot, rid, threebot_app=True, reservation_create_resp=reservation_create
                )
            wait_reservation_results = self._sal.wait_reservation(self._bot, rid)
            # Update solution saved locally
            explorer_name = self._sal._explorer.url.split(&#34;.&#34;)[1]
            old_solution = self.solutions.get(f&#34;{explorer_name}_{self.resv_id}&#34;)
            solution = self.solutions.get(
                f&#34;{explorer_name}_{rid}&#34;,
                explorer=old_solution.explorer,
                form_info=old_solution.form_info,
                rid=rid,
                solution_type=old_solution.solution_type,
            )
            solution.name = self.name
            solution.save()
            self.solutions.delete(f&#34;{explorer_name}_{self.resv_id}&#34;)
            return wait_reservation_results
        return True

    def copy(self, customer_tid):
        &#34;&#34;&#34;create a copy of network object

        Args:
            customer_tid (int): customet tid (j.core.identity.me.tid)

        Returns:
            (Network): copy of the network
        &#34;&#34;&#34;
        network_copy = None
        explorer = j.core.identity.me.explorer
        reservation = explorer.reservations.get(self.resv_id)
        networks = self._sal.list_networks(customer_tid, [reservation])
        for key in networks.keys():
            network, expiration, currency, resv_id = networks[key]
            if network.name == self.name:
                network_copy = Network(network, expiration, self._bot, [reservation], currency, resv_id)
                break
        if network_copy:
            network_copy._used_ips = copy.copy(self._used_ips)
        return network_copy

    def ask_ip_from_node(self, node, message):
        &#34;&#34;&#34;ask for free ip from a specific node and mark it as used in chatbot

        Args:
            node (jumpscale.client.explorer.models.TfgridDirectoryNode2): reqired node to ask ip from
            message (str): message to the chatflow slide

        Returns:
            [str]: free ip
        &#34;&#34;&#34;
        ip_range = self.get_node_range(node)
        freeips = []
        hosts = netaddr.IPNetwork(ip_range).iter_hosts()
        next(hosts)  # skip ip used by node
        for host in hosts:
            ip = str(host)
            if ip not in self._used_ips:
                freeips.append(ip)
        ip_address = self._bot.drop_down_choice(message, freeips, required=True)
        self._used_ips.append(ip_address)
        return ip_address

    def get_free_ip(self, node):
        &#34;&#34;&#34;return free ip

        Args:
            node (jumpscale.client.explorer.models.TfgridDirectoryNode2): reqired node to get free ip from

        Returns:
            [str]: free ip to use
        &#34;&#34;&#34;
        ip_range = self.get_node_range(node)
        hosts = netaddr.IPNetwork(ip_range).iter_hosts()
        next(hosts)  # skip ip used by node
        for host in hosts:
            ip = str(host)
            if ip not in self._used_ips:
                return ip
        return None


class ReservationChatflow:
    def __init__(self, **kwargs):
        &#34;&#34;&#34;This class is responsible for managing, creating, cancelling reservations&#34;&#34;&#34;
        self.solutions = StoredFactory(TfgridSolution1)
        self.payments = StoredFactory(TfgridSolutionsPayment1)
        self.deployed_reservations = StoredFactory(DeployedReservation)

    @property
    def me(self):
        return j.core.identity.me

    @property
    def _explorer(self):
        return j.core.identity.me.explorer

    def decrypt_reservation_metadata(self, metadata_encrypted):
        &#34;&#34;&#34;decrypt the reservation metadata using identity nacl

        Args:
            metadata_encrypted (bytes): encrypted metadata

        Returns:
            [str]: decrypted solution metadata
        &#34;&#34;&#34;
        pk = j.core.identity.me.nacl.signing_key.verify_key.to_curve25519_public_key()
        sk = j.core.identity.me.nacl.signing_key.to_curve25519_private_key()
        box = Box(sk, pk)
        return box.decrypt(base64.b85decode(metadata_encrypted.encode())).decode()

    def check_solution_type(self, reservation):
        &#34;&#34;&#34;categorize the solutions by types

        Args:
            reservation (jumpscale.clients.explorer.models.TfgridWorkloadsReservation1): user reservation

        Returns:
            [jumpscale.clients.explorer.models.SolutionType]: type of the solution
        &#34;&#34;&#34;
        containers = reservation.data_reservation.containers
        volumes = reservation.data_reservation.volumes
        zdbs = reservation.data_reservation.zdbs
        kubernetes = reservation.data_reservation.kubernetes
        networks = reservation.data_reservation.networks
        if containers == [] and volumes == [] and zdbs == [] and kubernetes == [] and networks:
            return SolutionType.Network
        elif kubernetes != []:
            return SolutionType.Kubernetes
        elif len(containers) != 0:
            if &#34;ubuntu&#34; in containers[0].flist:
                return SolutionType.Ubuntu
            elif &#34;minio&#34; in containers[0].flist:
                return SolutionType.Minio
            elif &#34;gitea&#34; in containers[0].flist:
                return SolutionType.Gitea
            elif &#34;tcprouter&#34; in containers[0].flist:
                return SolutionType.Exposed
            return &#34;flist&#34;
        elif reservation.data_reservation.domain_delegates:
            return SolutionType.DelegatedDomain
        return SolutionType.Unknown

    def get_solution_ubuntu_info(self, metadata, reservation):
        &#34;&#34;&#34;get ubuntu solutions information from metadata on explorer and update local ones

        Args:
            metadata (dict): ubuntu reservation metadata
            reservation (jumpscale.clients.explorer.models.TfgridWorkloadsReservation1): ubuntu reservation

        Returns:
            [dict]: updated metadata
        &#34;&#34;&#34;
        envs = reservation.data_reservation.containers[0].environment
        env_variable = &#34;&#34;
        metadata[&#34;form_info&#34;][&#34;Public key&#34;] = envs[&#34;pub_key&#34;].strip(&#34; &#34;)
        envs.pop(&#34;pub_key&#34;)
        metadata[&#34;form_info&#34;][&#34;CPU&#34;] = reservation.data_reservation.containers[0].capacity.cpu
        metadata[&#34;form_info&#34;][&#34;Memory&#34;] = reservation.data_reservation.containers[0].capacity.memory
        metadata[&#34;form_info&#34;][&#34;Root filesystem Type&#34;] = str(
            reservation.data_reservation.containers[0].capacity.disk_type
        )
        metadata[&#34;form_info&#34;][&#34;Root filesystem Size&#34;] = (
            reservation.data_reservation.containers[0].capacity.disk_size or 256
        )
        for key, value in envs.items():
            env_variable += f&#34;{key}={value},&#34;
        metadata[&#34;form_info&#34;][&#34;Env variables&#34;] = str(env_variable)
        metadata[&#34;form_info&#34;][&#34;IP Address&#34;] = reservation.data_reservation.containers[0].network_connection[0].ipaddress
        return metadata

    def get_solution_exposed_info(self, reservation):
        &#34;&#34;&#34;get information about solution exposed from reservation

        Args:
            reservation (jumpscale.clients.explorer.models.TfgridWorkloadsReservation1)

        return dict of info
        &#34;&#34;&#34;

        def get_arg(cmd, arg):
            idx = cmd.index(arg)
            if idx:
                return cmd[idx + 1]
            return None

        info = {}
        for container in reservation.data_reservation.containers:
            if &#34;tcprouter&#34; in container.flist:
                entrypoint = container.entrypoint.split()
                local = get_arg(entrypoint, &#34;-local&#34;)
                if local:
                    info[&#34;Port&#34;] = local.split(&#34;:&#34;)[-1]
                localtls = get_arg(entrypoint, &#34;-local-tls&#34;)
                if localtls:
                    info[&#34;port-tls&#34;] = localtls.split(&#34;:&#34;)[-1]
                remote = get_arg(entrypoint, &#34;-remote&#34;)
                if remote:
                    info[&#34;Name Server&#34;] = remote.split(&#34;:&#34;)[0]
        for proxy in reservation.data_reservation.reverse_proxies:
            info[&#34;Domain&#34;] = proxy.domain
        return info

    def get_solution_flist_info(self, metadata, reservation):
        &#34;&#34;&#34;get flist solutions information from metadata on explorer and update local ones

        Args:
            metadata (dict): flist reservation metadata
            reservation (jumpscale.clients.explorer.models.TfgridWorkloadsReservation1): ubuntu reservation

        Returns:
            [dict]: updated metadata
        &#34;&#34;&#34;
        envs = reservation.data_reservation.containers[0].environment
        env_variable = &#34;&#34;
        for key, value in envs.items():
            env_variable += f&#34;{key}={value}, &#34;
        metadata[&#34;form_info&#34;][&#34;CPU&#34;] = reservation.data_reservation.containers[0].capacity.cpu
        metadata[&#34;form_info&#34;][&#34;Memory&#34;] = reservation.data_reservation.containers[0].capacity.memory
        metadata[&#34;form_info&#34;][&#34;Root filesystem Type&#34;] = str(
            reservation.data_reservation.containers[0].capacity.disk_type
        )
        metadata[&#34;form_info&#34;][&#34;Root filesystem Size&#34;] = (
            reservation.data_reservation.containers[0].capacity.disk_size or 256
        )
        metadata[&#34;form_info&#34;][&#34;Env variables&#34;] = str(env_variable)
        metadata[&#34;form_info&#34;][&#34;Flist link&#34;] = reservation.data_reservation.containers[0].flist
        metadata[&#34;form_info&#34;][&#34;Interactive&#34;] = reservation.data_reservation.containers[0].interactive
        if metadata[&#34;form_info&#34;][&#34;Interactive&#34;]:
            metadata[&#34;form_info&#34;][&#34;Port&#34;] = &#34;7681&#34;
        metadata[&#34;form_info&#34;][&#34;Entry point&#34;] = reservation.data_reservation.containers[0].entrypoint
        metadata[&#34;form_info&#34;][&#34;IP Address&#34;] = reservation.data_reservation.containers[0].network_connection[0].ipaddress
        return metadata

    def get_solution_domain_delegates_info(self, reservation):
        &#34;&#34;&#34;get domain delegated metadata info

        Args:
            reservation (jumpscale.clients.explorer.models.TfgridWorkloadsReservation1): reservation object

        Returns:
            [dict]: domain delegated metadata info
        &#34;&#34;&#34;

        delegated_domain = reservation.data_reservation.domain_delegates[0]
        return {&#34;Domain&#34;: delegated_domain.domain, &#34;Gateway&#34;: delegated_domain.node_id}

    def save_reservation(self, rid, name, solution_type, form_info=None):
        &#34;&#34;&#34;save user reservation in local config manager

        Args:
            rid (int): user identity (j.core.identity.me.tid)
            name (str): reservation name
            solution_type (SolutionType): type of the solution from types enum
            form_info (dict, optional): reservation user info. Defaults to None.
        &#34;&#34;&#34;
        form_info = form_info or {}
        explorer_name = self._explorer.url.split(&#34;.&#34;)[1]
        reservation = self.solutions.get(f&#34;{explorer_name}_{rid}&#34;)
        reservation.rid = rid
        reservation.name = name
        reservation.solution_type = solution_type
        reservation.form_info = form_info
        reservation.explorer = self._explorer.url
        reservation.save()

    def get_solutions_explorer(self, deployed=True):
        &#34;&#34;&#34;get the updated reservations from explorer

        Args:
            deployed (bool, optional): set False to get all reservations. Defaults to True.

        Returns:
            list: list of reservations
        &#34;&#34;&#34;
        customer_tid = self.me.tid
        reservations_data = []
        reservations = []
        if deployed:
            reservations = self._explorer.reservations.list(customer_tid, &#34;DEPLOY&#34;)
        else:
            reservations = self._explorer.reservations.list(customer_tid)
        networks = []
        dupnames = {}
        for reservation in sorted(reservations, key=lambda res: res.id, reverse=True):
            info = {}
            if reservation.metadata:
                try:
                    metadata = self.decrypt_reservation_metadata(reservation.metadata)
                    metadata = json.loads(metadata)
                except Exception:
                    continue
                if &#34;form_info&#34; not in metadata:
                    solution_type = self.check_solution_type(reservation).value
                else:
                    solution_type = metadata[&#34;form_info&#34;].pop(&#34;chatflow&#34;, SolutionType.Unknown.value)
                if solution_type == SolutionType.Unknown.value:
                    continue
                elif solution_type == SolutionType.Ubuntu.value:
                    metadata = self.get_solution_ubuntu_info(metadata, reservation)
                elif solution_type == SolutionType.Flist.value:
                    metadata = self.get_solution_flist_info(metadata, reservation)
                elif solution_type == SolutionType.Network.value:
                    if metadata[&#34;name&#34;] in networks:
                        continue
                    networks.append(metadata[&#34;name&#34;])
                elif solution_type == SolutionType.Gitea.value:
                    metadata[&#34;form_info&#34;][&#34;Public key&#34;] = reservation.data_reservation.containers[0].environment[
                        &#34;pub_key&#34;
                    ]
                elif solution_type == SolutionType.Exposed.value:
                    meta = metadata
                    metadata = {&#34;form_info&#34;: meta}
                    metadata[&#34;form_info&#34;].update(self.get_solution_exposed_info(reservation))
                    metadata[&#34;name&#34;] = metadata[&#34;form_info&#34;].get(&#34;Domain&#34;)

                info = metadata[&#34;form_info&#34;]
                name = metadata[&#34;name&#34;]
            else:
                solution_type = self.check_solution_type(reservation)
                if type(solution_type) is not str:
                    solution_type = solution_type.value
                info = {}
                name = f&#34;unknown_{reservation.id}&#34;
                if solution_type == SolutionType.Unknown.value:
                    continue
                elif solution_type == SolutionType.Network.value:
                    name = reservation.data_reservation.networks[0].name
                    if name in networks:
                        continue
                    networks.append(name)
                elif solution_type == SolutionType.DelegatedDomain.value:
                    info = self.get_solution_domain_delegates_info(reservation)
                    if not info.get(&#34;Solution name&#34;):
                        name = f&#34;unknown_{reservation.id}&#34;
                    else:
                        name = info[&#34;Solution name&#34;]
                elif solution_type == SolutionType.Exposed.value:
                    info = self.get_solution_exposed_info(reservation)
                    info[&#34;Solution name&#34;] = name
                    name = info.get(&#34;Domain&#34;)

            count = dupnames.setdefault(solution_type, {}).setdefault(name, 1)
            if count != 1:
                dupnames[solution_type][name] = count + 1
                name = f&#34;{name}_{count}&#34;
            # append reservation
            reservations_data.append(
                {
                    &#34;id&#34;: reservation.id,
                    &#34;name&#34;: name,
                    &#34;solution_type&#34;: solution_type,
                    &#34;form_info&#34;: info,
                    &#34;status&#34;: reservation.next_action.name,
                    &#34;reservation_date&#34;: reservation.epoch.ctime(),
                    &#34;reservation&#34;: reservation._get_data(),
                }
            )
        return reservations_data

    def update_local_reservations(self):
        &#34;&#34;&#34;update local reserfvations with new ones&#34;&#34;&#34;
        for obj in self.solutions.list_all():
            self.solutions.delete(obj)
        reservations = self.get_solutions_explorer()
        for reservation in reservations:
            self.save_reservation(
                reservation[&#34;id&#34;], reservation[&#34;name&#34;], reservation[&#34;solution_type&#34;], form_info=reservation[&#34;form_info&#34;]
            )

    def list_wallets(self):
        &#34;&#34;&#34;
        List all stellar client wallets from bcdb. Based on explorer instance only either wallets with network type TEST or STD are returned
        rtype: list
        &#34;&#34;&#34;
        if &#34;devnet&#34; in self._explorer.url or &#34;testnet&#34; in self._explorer.url:
            network_type = StellarNetwork.TEST
        else:
            network_type = StellarNetwork.STD

        wallets_list = j.clients.stellar.list_all()
        wallets = dict()
        for wallet_name in wallets_list:
            wallet = j.clients.stellar.find(wallet_name)
            if wallet.network != network_type:
                continue
            wallets[wallet_name] = wallet
        return wallets

    def show_escrow_qr(self, bot, reservation_create_resp, expiration_provisioning):
        &#34;&#34;&#34;
        Show in chatflow the QR code with the details of the escrow information for payment
        &#34;&#34;&#34;
        escrow_info = j.sals.zos.get().reservation_escrow_information_with_qrcodes(reservation_create_resp)
        escrow_address = escrow_info[&#34;escrow_address&#34;]
        escrow_asset = escrow_info[&#34;escrow_asset&#34;]
        reservationid = escrow_info[&#34;reservationid&#34;]
        qrcode = escrow_info[&#34;qrcode&#34;]
        remaning_time = j.data.time.get(expiration_provisioning).humanize()
        payment_details = self.get_payment_details(escrow_info, escrow_asset.split(&#34;:&#34;)[0])

        message_text = f&#34;&#34;&#34;
        &lt;h3&gt;Make a Payment&lt;/h3&gt;
        Scan the QR code with your wallet (do not change the message) or enter the information below manually and proceed with the payment. Make sure to add the reservationid as memo_text.
        &lt;p&gt;If no payment is made {remaning_time} the reservation will be canceled&lt;/p&gt;

        &lt;h4&gt; Destination Wallet Address: &lt;/h4&gt;  {escrow_address} \n
        &lt;h4&gt; Currency: &lt;/h4&gt;  {escrow_asset} \n
        &lt;h4&gt; Reservation ID: &lt;/h4&gt;  {reservationid} \n
        &lt;h4&gt; Payment Details: &lt;/h4&gt; {payment_details} \n
        &#34;&#34;&#34;

        bot.qrcode_show(data=qrcode, msg=message_text, scale=4, update=True, html=True)

    def create_payment(
        self, rid, currency, escrow_address, escrow_asset, total_amount, payment_source, farmer_payments
    ):
        &#34;&#34;&#34;create payment object and save it locally

        Args:
            rid (int): customer tid
            currency (str): reservation currency &#34;TFT&#34; or &#34;FreeTFT&#34;
            escrow_address (str): escrow_address
            escrow_asset (str): escrow asset
            total_amount (str): paid amount
            payment_source (str): payment source
            farmer_payments (list): total list of farmer payments

        Returns:
            [jumpscale.clients.explorer.models.TfgridSolutionsPayment1]: payment object
        &#34;&#34;&#34;
        explorer_name = self._explorer.url.split(&#34;.&#34;)[1]
        payment_obj = self.payments.get(f&#34;{explorer_name}_{rid}&#34;)
        payment_obj.explorer = self._explorer.url
        payment_obj.rid = rid
        payment_obj.currency = currency
        payment_obj.escrow_address = escrow_address
        payment_obj.escrow_asset = escrow_asset
        payment_obj.total_amount = str(total_amount)
        payment_obj.transaction_fees = f&#34;0.1 {currency}&#34;
        payment_obj.payment_source = payment_source
        for farmer in farmer_payments:
            farmer_name = self._explorer.farms.get(farm_id=farmer[&#34;farmer_id&#34;]).name
            payment_obj.farmer_payments[farmer_name] = farmer[&#34;total_amount&#34;]
        return payment_obj

    def get_payment_details(self, escrow_info, currency):
        &#34;&#34;&#34;split payment details and get each one

        Args:
            escrow_info (str): payment info
            currency (str): currency used

        Returns:
            [str]: payment details
        &#34;&#34;&#34;

        farmer_payments = escrow_info[&#34;farmer_payments&#34;]
        total_amount = escrow_info[&#34;total_amount&#34;]

        payment_details = &#34;&#34;
        payment_details += &#39;&lt;table style=&#34;width: 50%; font-family: arial, sans-serif; border-collapse: collapse;&#34;&gt;&#39;
        for farmer in farmer_payments:
            farmer_name = self._explorer.farms.get(farm_id=farmer[&#34;farmer_id&#34;]).name
            payment_details += (
                f&#34;&lt;tr&gt;&lt;td&gt;Farmer {farmer_name}&lt;/td&gt;&lt;td&gt;{format(farmer[&#39;total_amount&#39;],&#39;.7f&#39;)} {currency}&lt;/td&gt;&lt;/tr&gt;&#34;
            )
        payment_details += f&#34;&lt;tr&gt;&lt;td&gt;Transaction Fees&lt;/td&gt;&lt;td&gt;{0.1} {currency}&lt;/td&gt;&lt;/tr&gt;&#34;
        payment_details += f&#34;&lt;tr&gt;&lt;td&gt;Total amount&lt;/td&gt;&lt;td&gt;{format(total_amount + 0.1,&#39;.7f&#39;)} {currency}&lt;/td&gt;&lt;/tr&gt;&#34;
        payment_details += &#34;&lt;/table&gt;&#34;

        return payment_details

    def show_payments(self, bot, reservation_create_resp, currency):
        &#34;&#34;&#34;Show valid payment options in chatflow available. All available wallets possible are shown or usage of External wallet (QR code) is shown
        where a QR code is viewed for the user to scan and continue with their payment

        Args:
            bot (GedisChatBot): instance of the used bot
            reservation_create_resp (jumpscale.clients.explorer.models.TfgridWorkloadsReservation1): result of reservation
            currency (str): currency used

        Returns:
            [jumpscale.clients.explorer.models.TfgridSolutionsPayment1]: payment object wallet in case a wallet is used
        &#34;&#34;&#34;
        payment = {&#34;wallet&#34;: None, &#34;free&#34;: False}
        if not (reservation_create_resp.escrow_information and reservation_create_resp.escrow_information.details):
            payment[&#34;free&#34;] = True
            return payment, None
        escrow_info = j.sals.zos.get().reservation_escrow_information_with_qrcodes(reservation_create_resp)

        escrow_address = escrow_info[&#34;escrow_address&#34;]
        escrow_asset = escrow_info[&#34;escrow_asset&#34;]
        total_amount = escrow_info[&#34;total_amount&#34;]
        rid = reservation_create_resp.reservation_id

        wallets = self.list_wallets()
        wallet_names = []
        for w in wallets.keys():
            wallet_names.append(w)
        wallet_names.append(&#34;External Wallet (QR Code)&#34;)

        payment_details = self.get_payment_details(escrow_info, currency)

        message = f&#34;&#34;&#34;
        Billing details:
        &lt;h4&gt; Destination Wallet address: &lt;/h4&gt;  {escrow_address} \n
        &lt;h4&gt; Currency: &lt;/h4&gt;  {escrow_asset} \n
        &lt;h4&gt; Payment Details: &lt;/h4&gt; {payment_details} \n
        &lt;h4&gt; Choose a wallet name to use for payment or proceed with the payment through an external wallet (QR Code) &lt;/h4&gt;
        &#34;&#34;&#34;
        retry = False
        while True:

            result = bot.single_choice(message, wallet_names, html=True, retry=retry)

            if result not in wallet_names:
                retry = True
                continue
            if result == &#34;External Wallet (QR Code)&#34;:
                reservation = self._explorer.reservations.get(rid)
                self.show_escrow_qr(bot, reservation_create_resp, reservation.data_reservation.expiration_provisioning)
                payment_obj = self.create_payment(
                    rid=rid,
                    currency=currency,
                    escrow_address=escrow_address,
                    escrow_asset=escrow_asset,
                    total_amount=total_amount,
                    payment_source=&#34;external_wallet&#34;,
                    farmer_payments=escrow_info[&#34;farmer_payments&#34;],
                )
                return payment, payment_obj
            else:
                payment[&#34;wallet&#34;] = wallets[result]
                balances = payment[&#34;wallet&#34;].get_balance().balances
                current_balance = None
                for balance in balances:
                    if balance.asset_code == currency:
                        current_balance = balance.balance
                        if float(current_balance) &gt;= total_amount:
                            payment_obj = self.create_payment(
                                rid=rid,
                                currency=currency,
                                escrow_address=escrow_address,
                                escrow_asset=escrow_asset,
                                total_amount=total_amount,
                                payment_source=result,
                                farmer_payments=escrow_info[&#34;farmer_payments&#34;],
                            )
                            return payment, payment_obj
                retry = True
                message = f&#34;&#34;&#34;
                &lt;h2 style=&#34;color: #142850;&#34;&gt;&lt;b style=&#34;color: #00909e;&#34;&gt;{total_amount} {currency}&lt;/b&gt; are required, but only &lt;b style=&#34;color: #00909e;&#34;&gt;{current_balance} {currency}&lt;/b&gt; are available in wallet &lt;b style=&#34;color: #00909e;&#34;&gt;{payment[&#34;wallet&#34;].name}&lt;/b&gt;&lt;/h2&gt;
                Billing details:
                &lt;h4&gt; Wallet address: &lt;/h4&gt;  {escrow_address} \n
                &lt;h4&gt; Currency: &lt;/h4&gt;  {escrow_asset} \n
                &lt;h4&gt; Payment details: &lt;/h4&gt; {payment_details} \n
                &lt;h4&gt; Choose a wallet name to use for payment or proceed with payment through External Wallet (QR Code) &lt;/h4&gt;
                &#34;&#34;&#34;

    def wait_payment(self, bot, rid, threebot_app=False, reservation_create_resp=None):
        &#34;&#34;&#34;wait slide untill payment is ready

        Args:
            bot (GedisChatBot): bot instance
            rid (int): customer tid
            threebot_app (bool, optional): is using threebot app payment. Defaults to False.
            reservation_create_resp (jumpscale.clients.explorer.models.TfgridWorkloadsReservation1, optional): reservation object response. Defaults to None.
        &#34;&#34;&#34;

        # wait to check payment is actually done next_action changed from:PAY
        def is_expired(reservation):
            return reservation.data_reservation.expiration_provisioning.timestamp() &lt; j.data.time.get().timestamp

        reservation = self._explorer.reservations.get(rid)
        while True:
            remaning_time = j.data.time.get(reservation.data_reservation.expiration_provisioning).humanize(
                granularity=[&#34;minute&#34;, &#34;second&#34;]
            )
            deploying_message = f&#34;&#34;&#34;\
            # Payment being processed...

            &lt;br /&gt;Deployment will be cancelled if payment is not successful {remaning_time}
            &#34;&#34;&#34;
            bot.md_show_update(dedent(deploying_message), md=True)
            if reservation.next_action != &#34;PAY&#34;:
                return
            if is_expired(reservation):
                res = f&#34;# Failed to wait for payment for reservation:```{reservation.id}```:\n&#34;
                for x in reservation.results:
                    if x.state == &#34;ERROR&#34;:
                        res += f&#34;\n### {x.category}: ```{x.message}```\n&#34;
                link = f&#34;{self._explorer.url}/reservations/{reservation.id}&#34;
                res += f&#34;&lt;h2&gt; &lt;a href={link}&gt;Full reservation info&lt;/a&gt;&lt;/h2&gt;&#34;
                j.sals.zos.get().reservation_cancel(rid)
                bot.stop(res, md=True, html=True)
            if threebot_app and reservation_create_resp:
                self.show_escrow_qr(bot, reservation_create_resp, reservation.data_reservation.expiration_provisioning)
            time.sleep(5)
            reservation = self._explorer.reservations.get(rid)

    def _reservation_failed(self, bot, reservation):
        failed = j.sals.zos.get().reservation_failed(reservation)
        if failed:
            res = f&#34;# Sorry your reservation ```{reservation.id}``` has failed :\n&#34;
            for x in reservation.results:
                if x.state == &#34;ERROR&#34;:
                    res += f&#34;\n### {x.category}: ```{x.message}```\n&#34;
            link = f&#34;{self._explorer.url}/reservations/{reservation.id}&#34;
            res += f&#34;&lt;h2&gt; &lt;a href={link}&gt;Full reservation info&lt;/a&gt;&lt;/h2&gt;&#34;
            j.sals.zos.get().reservation_cancel(reservation.id)
            bot.stop(res, md=True, html=True)

    def wait_reservation(self, bot, rid):
        &#34;&#34;&#34;
        Wait for reservation results to be complete, have errors, or expire.
        If there are errors then error message is previewed in the chatflow to the user and the chat is ended.

        Args:
            bot (GedisChatBot): bot instance
            rid (int): user tid
        &#34;&#34;&#34;

        def is_finished(reservation):
            count = 0
            count += len(reservation.data_reservation.volumes)
            count += len(reservation.data_reservation.zdbs)
            count += len(reservation.data_reservation.containers)
            count += len(reservation.data_reservation.kubernetes)
            count += len(reservation.data_reservation.proxies)
            count += len(reservation.data_reservation.reverse_proxies)
            count += len(reservation.data_reservation.subdomains)
            count += len(reservation.data_reservation.domain_delegates)
            count += len(reservation.data_reservation.gateway4to6)
            for network in reservation.data_reservation.networks:
                count += len(network.network_resources)
            return len(reservation.results) &gt;= count

        def is_expired(reservation):
            &#34;&#34;&#34;[summary]

            Args:
                reservation (jumpscale.clients.explorer.models.TfgridWorkloadsReservation1): reservation object

            Returns:
                [bool]: True if the reservation is expired
            &#34;&#34;&#34;
            return reservation.data_reservation.expiration_provisioning.timestamp() &lt; j.data.time.get().timestamp

        reservation = self._explorer.reservations.get(rid)
        while True:
            remaning_time = j.data.time.get(reservation.data_reservation.expiration_provisioning).humanize(
                granularity=[&#34;minute&#34;, &#34;second&#34;]
            )
            deploying_message = f&#34;&#34;&#34;
            # Deploying...

            &lt;br /&gt;Deployment will be cancelled if it is not successful in {remaning_time}
            &#34;&#34;&#34;
            bot.md_show_update(dedent(deploying_message), md=True)
            self._reservation_failed(bot, reservation)

            if is_finished(reservation):
                if reservation.next_action != NextAction.DEPLOY:
                    res = f&#34;# Sorry your reservation ```{reservation.id}``` failed to deploy\n&#34;
                    for x in reservation.results:
                        if x.state == &#34;ERROR&#34;:
                            res += f&#34;\n### {x.category}: ```{x.message}```\n&#34;
                    bot.stop(res, md=True, html=True)
                return reservation.results
            if is_expired(reservation):
                res = f&#34;# Sorry your reservation ```{reservation.id}``` failed to deploy in time:\n&#34;
                for x in reservation.results:
                    if x.state == &#34;ERROR&#34;:
                        res += f&#34;\n### {x.category}: ```{x.message}```\n&#34;
                link = f&#34;{self._explorer.url}/reservations/{reservation.id}&#34;
                res += f&#34;&lt;h2&gt; &lt;a href={link}&gt;Full reservation info&lt;/a&gt;&lt;/h2&gt;&#34;
                j.sals.zos.get().reservation_cancel(rid)
                bot.stop(res, md=True, html=True)
            time.sleep(1)
            reservation = self._explorer.reservations.get(rid)

    def register_reservation(
        self, reservation, expiration, customer_tid, expiration_provisioning=1000, currency=None, bot=None
    ):
        &#34;&#34;&#34;Register any reservation through the chatflow.
        This reservation could include anything such as a new network, container, kubernetes cluster, or zdb.
        It returns the reservation id of the registered reservation.

        Args:
            reservation (jumpscale.clients.explorer.models.TfgridWorkloadsReservation1): reservation object
            expiration (int): epoch time when the reservation should be canceled automaticly
            customer_tid (int): Id of the customer making the reservation
            expiration_provisioning (int): timeout on the deployment of the provisioning in seconds
            currency (str): &#34;TFT&#34; of &#34;FreeTFT&#34;
            bot (GedisChatBot): bot instance

        Return:
            [jumpscale.clients.explorer.models.TfgridWorkloadsReservation1]: reservation create object

        &#34;&#34;&#34;
        expiration_provisioning += j.data.time.get().timestamp
        try:
            reservation_create = j.sals.zos.get().reservation_register(
                reservation,
                expiration,
                expiration_provisioning=expiration_provisioning,
                customer_tid=customer_tid,
                currencies=[currency],
            )
        except requests.HTTPError as e:
            try:
                msg = e.response.json()[&#34;error&#34;]
            except (KeyError, json.JSONDecodeError):
                msg = e.response.text
            raise StopChatFlow(f&#34;The following error occured: {msg}&#34;)

        rid = reservation_create.reservation_id
        reservation.id = rid

        # TODO: FIXME TO SET DEPLOYER in config
        if j.core.config.get_config().get(&#34;DEPLOYER&#34;) and customer_tid:
            # create a new object from deployed_reservation with the reservation and the tid
            explorer_name = self._explorer.url.split(&#34;.&#34;)[1]
            deployed_reservation = self.deployed_reservations.get(f&#34;{explorer_name}_{rid}&#34;)
            deployed_reservation.reservation_id = rid
            deployed_reservation.customer_tid = customer_tid
            deployed_reservation.save()
        return reservation_create

    def register_and_pay_reservation(
        self, reservation, expiration=None, customer_tid=None, currency=None, bot=None, wallet=None
    ):
        &#34;&#34;&#34;register the reservation, pay and deploy

        Args:
            reservation (jumpscale.clients.explorer.models.TfgridWorkloadsReservation1): reservation object
            expiration (int): epoch time when the reservation should be canceled automaticly
            customer_tid (int): Id of the customer making the reservation
            currency (str): &#34;TFT&#34; of &#34;FreeTFT&#34;
            bot (GedisChatBot): bot instance
            wallet (TfgridDirectoryWallet_address1): wallet object. Defaults to None.

        Returns:
            [int]: reservation id
        &#34;&#34;&#34;

        payment_obj = None
        if customer_tid and expiration and currency:
            reservation_create = self.register_reservation(
                reservation, expiration, customer_tid=customer_tid, currency=currency, bot=bot
            )
        else:
            reservation_create = reservation
        if not wallet:
            payment, payment_obj = self.show_payments(bot, reservation_create, currency)
        else:
            payment = {&#34;wallet&#34;: None, &#34;free&#34;: False}
            if not (reservation_create.escrow_information and reservation_create.escrow_information.details):
                payment[&#34;free&#34;] = True
            else:
                payment[&#34;wallet&#34;] = wallet

        resv_id = reservation_create.reservation_id
        if payment[&#34;wallet&#34;]:
            j.sals.zos.get().billing.payout_farmers(payment[&#34;wallet&#34;], reservation_create)
            self.wait_payment(bot, resv_id, threebot_app=False)
        elif not payment[&#34;free&#34;]:
            self.wait_payment(bot, resv_id, threebot_app=True, reservation_create_resp=reservation_create)

        self.wait_reservation(bot, resv_id)
        if payment_obj:
            payment_obj.save()
        return resv_id

    def get_kube_network_ip(self, reservation_data):
        &#34;&#34;&#34;get kubernetes reservation network id

        Args:
            reservation_data (jumpscale.clients.explorer.models.TfgridWorkloadsReservation1.reservation_data): reservation data object

        Returns:
            [str, str]: network_id, ip
        &#34;&#34;&#34;
        network_id = reservation_data[&#34;kubernetes&#34;][0][&#34;network_id&#34;]
        ip = reservation_data[&#34;kubernetes&#34;][0][&#34;ipaddress&#34;]
        return network_id, ip

    def list_gateways(self, bot, currency=None):
        &#34;&#34;&#34;list available gateways that supports passed currency

        Args:
            bot (GedisChatBot): bot instance
            currency (str, optional): &#34;TFT&#34; or &#34;FreeTFT&#34;. Defaults to None.

        Returns:
            [dict]
        &#34;&#34;&#34;
        unknowns = [&#34;&#34;, None, &#34;Uknown&#34;, &#34;Unknown&#34;]
        gateways = {}
        farms = {}
        for g in j.sals.zos.get()._explorer.gateway.list():
            if not j.sals.zos.get().nodes_finder.filter_is_up(g):
                continue
            location = []
            for area in [&#34;continent&#34;, &#34;country&#34;, &#34;city&#34;]:
                areaname = getattr(g.location, area)
                if areaname not in unknowns:
                    location.append(areaname)
            currencies = list()

            farm_id = g.farm_id
            if farm_id not in farms:
                farms[farm_id] = j.sals.zos.get()._explorer.farms.get(farm_id)

            addresses = farms[farm_id].wallet_addresses
            for address in addresses:
                if address.asset not in currencies:
                    if address.asset == &#34;FreeTFT&#34; and not g.free_to_use:
                        continue
                    currencies.append(address.asset)

            reservation_currency = &#34;, &#34;.join(currencies)

            if currency and currency not in currencies:
                continue
            gtext = f&#34;{&#39; - &#39;.join(location)} ({reservation_currency}) ID: {g.node_id}&#34;
            gateways[gtext] = g
        return gateways

    def select_gateway(self, bot, currency=None):
        &#34;&#34;&#34;prompt user about available gateways that supports passed currency

        Args:
            bot (GedisChatBot): bot instance
            currency (str, optional): &#34;TFT&#34; or &#34;FreeTFT&#34;. Defaults to None.

        Returns:
            [TfgridDirectoryGateway1]
        &#34;&#34;&#34;
        gateways = self.list_gateways(bot, currency)
        if not gateways:
            bot.stop(&#34;No available gateways&#34;)
        options = sorted(list(gateways.keys()))
        gateway = bot.drop_down_choice(&#34;Please choose a gateway&#34;, options, required=True)
        return gateways[gateway]

    def list_delegate_domains(self, customer_tid, currency=None):
        &#34;&#34;&#34;list delegated domains with passed currency

        Args:
            customer_tid (int): user tid
            currency (str, optional): currency to search with. Defaults to None.

        Returns:
            [dict]: [domains names]
        &#34;&#34;&#34;
        reservations = j.sals.zos.get().reservation_list(tid=customer_tid, next_action=&#34;DEPLOY&#34;)
        domains = dict()
        names = set()
        for reservation in sorted(reservations, key=lambda r: r.id, reverse=True):
            reservation_currency = self.get_currency(reservation)
            if reservation.next_action != NextAction.DEPLOY:
                continue
            rdomains = reservation.data_reservation.domain_delegates
            if currency and currency != reservation_currency:
                continue
            for dom in rdomains:
                if dom.domain in names:
                    continue
                names.add(dom.domain)
                domains[dom.domain] = dom
        return domains

    def get_network(self, bot, customer_tid, name):
        &#34;&#34;&#34;get the network object

        Args:
            bot (GedisChatBot): bot instance
            customer_tid (int): user tid
            name (str): [network name]

        Returns:
            [jumpscale.clients.explorer.models.TfgridWorkloadsReservationNetwork1]: nework object
        &#34;&#34;&#34;
        reservations = j.sals.zos.get().reservation_list(tid=customer_tid, next_action=&#34;DEPLOY&#34;)
        networks = self.list_networks(customer_tid, reservations)
        for key in networks.keys():
            network, expiration, currency, resv_id = networks[key]
            if network.name == name:
                return Network(network, expiration, bot, reservations, currency, resv_id)

    def list_networks(self, tid, reservations=None):
        &#34;&#34;&#34;list all available networks from reservations

        Args:
            tid (int): user tid
            reservation (list of jumpscale.clients.explorer.models.TfgridWorkloadsReservation1): list of reservation objects

        Returns:
            [type]: [description]
        &#34;&#34;&#34;
        if not reservations:
            reservations = j.sals.zos.get().reservation_list(tid=tid, next_action=&#34;DEPLOY&#34;)
        networks = dict()
        names = set()
        for reservation in sorted(reservations, key=lambda r: r.id, reverse=True):
            if reservation.next_action != NextAction.DEPLOY:
                continue
            rnetworks = reservation.data_reservation.networks
            expiration = reservation.data_reservation.expiration_reservation
            currency = self.get_currency(reservation)
            for network in rnetworks:
                if network.name in names:
                    continue
                names.add(network.name)
                remaining = j.data.time.get(expiration).humanize()

                network_name = network.name + f&#34; ({currency}) - ends &#34; + remaining
                networks[network_name] = (network, expiration, currency, reservation.id)

        return networks

    def get_currency(self, reservation):
        &#34;&#34;&#34;get reservation currency

        Args:
            reservation (jumpscale.clients.explorer.models.TfgridWorkloadsReservation1): reservation object

        Returns:
            [str]
        &#34;&#34;&#34;
        currencies = reservation.data_reservation.currencies
        if currencies:
            return currencies[0]
        elif reservation.data_reservation.networks and reservation.data_reservation.networks[0].network_resources:
            node_id = reservation.data_reservation.networks[0].network_resources[0].node_id
            if self._explorer.nodes.get(node_id).free_to_use:
                return &#34;FreeTFT&#34;

        return &#34;TFT&#34;

    def cancel_solution_reservation(self, solution_type, solution_name):
        &#34;&#34;&#34;cancel solution reservation

        Args:
            solution_type (str): solution_type
            solution_name (str): solution name
        &#34;&#34;&#34;
        for name in self.solutions.list_all():
            solution = self.solutions.get(name)
            if solution.name == solution_name and solution.solution_type == solution_type:
                # Cancel all parent networks if solution type is network
                if solution.solution_type == SolutionType.Network:  ## TODO change to SolutionType.Network.value
                    curr_network_resv = self._explorer.reservations.get(solution.rid)
                    while curr_network_resv:
                        if curr_network_resv.metadata:
                            try:
                                network_metadata = self.decrypt_reservation_metadata(curr_network_resv.metadata)
                                network_metadata = json.loads(network_metadata)
                            except Exception:
                                break
                            if &#34;parent_network&#34; in network_metadata:
                                parent_resv = self._explorer.reservations.get(network_metadata[&#34;parent_network&#34;])
                                j.sals.zos.get().reservation_cancel(parent_resv.id)
                                curr_network_resv = parent_resv
                                continue
                        curr_network_resv = None

                j.sals.zos.get().reservation_cancel(solution.rid)
                self.solutions.delete(name)

    def get_solutions(self, solution_type):
        &#34;&#34;&#34;get deployed solutions from specified type

        Args:
            solution_type (str): solution type

        Returns:
            [list]: list of reservations objects
        &#34;&#34;&#34;
        reservations = []
        for name in self.solutions.list_all():
            solution = self.solutions.get(name)
            if solution.solution_type != solution_type:
                continue
            if solution.explorer and solution.explorer != self._explorer.url:
                continue
            reservation = self._explorer.reservations.get(solution.rid)
            reservations.append(
                {
                    &#34;name&#34;: solution.name,
                    &#34;reservation&#34;: reservation._get_data(),
                    &#34;type&#34;: solution_type.value,
                    &#34;form_info&#34;: json.dumps(solution.form_info),
                }
            )
        return reservations

    def add_reservation_metadata(self, reservation, metadata):
        &#34;&#34;&#34;add the encrypted metadata to reservation object

        Args:
            reservation (jumpscale.clients.explorer.models.TfgridWorkloadsReservation1): reservation object
            metadata (dict): reservation metadata

        Returns:
            reservation (jumpscale.clients.explorer.models.TfgridWorkloadsReservation1): reservation with metadata
        &#34;&#34;&#34;
        meta_json = json.dumps(metadata)

        pk = j.core.identity.me.nacl.signing_key.verify_key.to_curve25519_public_key()
        sk = j.core.identity.me.nacl.signing_key.to_curve25519_private_key()
        box = Box(sk, pk)
        encrypted_metadata = base64.b85encode(box.encrypt(meta_json.encode())).decode()
        reservation.metadata = encrypted_metadata
        return reservation

    def get_solution_metadata(self, solution_name, solution_type, form_info=None):
        &#34;&#34;&#34;get metadata from a solution

        Args:
            solution_name (str): solution name
            solution_type (str): solution type
            form_info (dict, optional): info from user slide. Defaults to None.

        Returns:
            dict: metadata
        &#34;&#34;&#34;
        form_info = form_info or {}
        reservation = {}
        reservation[&#34;name&#34;] = solution_name
        reservation[&#34;form_info&#34;] = form_info
        reservation[&#34;solution_type&#34;] = solution_type.value
        reservation[&#34;explorer&#34;] = self._explorer.url
        return reservation

    def create_network(
        self,
        network_name,
        reservation,
        ip_range,
        customer_tid,
        ip_version,
        access_node,
        expiration=None,
        currency=None,
        bot=None,
    ):
        &#34;&#34;&#34;create network to deploy reservation on

        Args:
            network_name (str): network name
            reservation (jumpscale.clients.explorer.models.TfgridWorkloadsReservation1): reservation object
            ip_range (IPRange): selected ip range eg: &#34;10.70.0.0/16&#34;
            customer_tid (int): user tid
            ip_version (str): &#34;IPv4&#34; or &#34;IPv6&#34;
            expiration (int, optional): epoch for expiration time. Defaults to None.
            currency (str, optional): wanted currency . Defaults to None.
            bot (GedisChatBot, optional): bot instance. Defaults to None.

        Raises:
            StopChatFlow: when no available node

        Returns:
            [dict]: network config
        &#34;&#34;&#34;

        network = j.sals.zos.get().network.create(reservation, ip_range, network_name)
        node_subnets = netaddr.IPNetwork(ip_range).subnet(24)
        network_config = dict()
        use_ipv4 = ip_version == &#34;IPv4&#34;

        j.sals.zos.get().network.add_node(network, access_node.node_id, str(next(node_subnets)))
        wg_quick = j.sals.zos.get().network.add_access(
            network, access_node.node_id, str(next(node_subnets)), ipv4=use_ipv4
        )

        network_config[&#34;wg&#34;] = wg_quick

        j.sals.fs.mkdir(f&#34;{j.core.dirs.CFGDIR}/wireguard/&#34;)
        j.sals.fs.write_file(f&#34;{j.core.dirs.CFGDIR}/wireguard/{network_name}.conf&#34;, f&#34;{wg_quick}&#34;)

        # register the reservation
        expiration = expiration or j.data.time.get().timestamp + (60 * 60 * 24)
        reservation_create = self.register_reservation(
            reservation, expiration, customer_tid, currency=currency, bot=bot
        )

        network_config[&#34;rid&#34;] = reservation_create.reservation_id
        network_config[&#34;reservation_create&#34;] = reservation_create

        return network_config

    def get_ip_range(self, bot):
        &#34;&#34;&#34;prompt user to select iprange

        Args:
            bot (GedisChatBot): bot instance

        Returns:
            [IPRange]: ip selected by user
        &#34;&#34;&#34;
        ip_range_choose = [&#34;Configure IP range myself&#34;, &#34;Choose IP range for me&#34;]
        iprange_user_choice = bot.single_choice(
            &#34;To have access to the 3Bot, the network must be configured&#34;,
            ip_range_choose,
            required=True,
            default=ip_range_choose[1],
        )
        if iprange_user_choice == &#34;Configure IP range myself&#34;:
            ip_range = bot.string_ask(&#34;Please add private IP Range of the network&#34;)
        else:
            first_digit = random.choice([172, 10])
            if first_digit == 10:
                second_digit = random.randint(0, 255)
            else:
                second_digit = random.randint(16, 31)
            ip_range = str(first_digit) + &#34;.&#34; + str(second_digit) + &#34;.0.0/16&#34;
        return ip_range

    def select_farms(self, bot, message=None, currency=None, retry=False, sru=None, cru=None, hru=None, mru=None):
        &#34;&#34;&#34;prompt user to select farm to deploy on

        Args:
            bot (GedisChatBot): bot instance
            message (str, optional): bot screen message. Defaults to None.
            currency (str, optional): wanted currency to deal with. Defaults to None.
            retry (bool, optional): retry if failed. Defaults to False.

        Returns:
            farm object
        &#34;&#34;&#34;
        message = message or &#34;Select 1 or more farms to distribute nodes on&#34;
        farms = self._explorer.farms.list()
        farm_names = []
        for f in farms:
            if j.sals.zos.get().nodes_finder.filter_farm_currency(f, currency) and self.check_farm_resources(
                farm_id=f.id, sru=sru, cru=cru, hru=hru, mru=mru, currency=currency
            ):
                farm_names.append(f.name)
        if not farm_names:
            bot.stop(&#34;No farms with available resources that match the specified.&#34;)
        farms_selected = bot.multi_list_choice(message, farm_names, retry=retry, auto_complete=True)
        return farms_selected

    def check_farm_resources(self, farm_id, sru=None, mru=None, hru=None, cru=None, currency=None):
        farm_nodes = self._explorer.nodes.list(farm_id=farm_id)
        nodes = []
        for node in farm_nodes:
            if not j.sals.zos.get().nodes_finder.filter_is_up(node):
                continue
            if currency == &#34;FreeTFT&#34; and not node.free_to_use:
                continue
            if sru:
                available_sru = node.total_resources.sru - node.reserved_resources.sru
                if sru &gt; available_sru:
                    continue
            if cru:
                available_cru = node.total_resources.cru - node.reserved_resources.cru
                if cru &gt; available_cru:
                    continue
            if hru:
                available_hru = node.total_resources.hru - node.reserved_resources.hru
                if hru &gt; available_hru:
                    continue
            if mru:
                available_mru = node.total_resources.mru - node.reserved_resources.mru
                if mru &gt; available_mru:
                    continue
            nodes.append(node)
        return nodes

    def select_network(self, bot, customer_tid):
        &#34;&#34;&#34;prompt user to select a specific network

        Args:
            bot (GedisChatBot): bot instance
            customer_tid (int): user tid

        Returns:
            Network object
        &#34;&#34;&#34;
        reservations = j.sals.zos.get().reservation_list(tid=customer_tid, next_action=&#34;DEPLOY&#34;)
        networks = self.list_networks(customer_tid, reservations)
        names = []
        for n in networks.keys():
            names.append(n)
        if not names:
            res = &#34;You don&#39;t have any networks, please use the network chatflow to create one&#34;
            res = j.tools.jinja2.render_template(template_text=res)
            bot.stop(res)
        while True:
            result = bot.single_choice(&#34;Choose a network&#34;, names, required=True)
            if result not in networks:
                continue
            network, expiration, currency, resv_id = networks[result]
            return Network(network, expiration, bot, reservations, currency, resv_id)

    def validate_node(self, nodeid, query=None, currency=None):
        &#34;&#34;&#34;validate the node if it&#39;s ok to use and have enough resources

        Args:
            nodeid (str): node id
            query (dict, optional): search paramas. Defaults to None.
            currency (str, optional): wanted currency. Defaults to None.

        Returns:
            Node object
        &#34;&#34;&#34;
        try:
            node = self._explorer.nodes.get(nodeid)
        except requests.exceptions.HTTPError:
            raise j.exceptions.NotFound(f&#34;Node {nodeid} doesn&#39;t exists please enter a valid nodeid&#34;)
        if not j.sals.zos.get().nodes_finder.filter_is_up(node):
            raise j.exceptions.NotFound(f&#34;Node {nodeid} doesn&#39;t seem to be up please choose another nodeid&#34;)

        if currency:
            if currency == &#34;FreeTFT&#34; and not node.free_to_use:
                raise j.exceptions.Value(
                    f&#34;The specified node ({nodeid}) should support the same type of currency as the network you are using ({currency})&#34;
                )
        if query:
            for unit, value in query.items():
                if unit == &#34;currency&#34;:
                    continue
                freevalue = getattr(node.total_resources, unit) - getattr(node.used_resources, unit)
                if freevalue &lt; value:
                    raise j.exceptions.Value(
                        f&#34;Node {nodeid} does not have enough available {unit} resources for this request {value} required {freevalue} available, please choose another one&#34;
                    )
        return node

    def get_nodes(
        self,
        number_of_nodes,
        cru=None,
        sru=None,
        mru=None,
        hru=None,
        currency=&#34;TFT&#34;,
        ip_version=None,
        pool_ids=None,
        filter_blocked=True,
    ):
        &#34;&#34;&#34;get available nodes to deploy solutions on

        Args:
            number_of_nodes (int): required nodes count
            farm_id (int, optional): id for farm to search with. Defaults to None.
            farm_names (list, optional): farms to search in. Defaults to None.
            cru (int, optional): cpu resource. Defaults to None.
            sru (int, optional): ssd resource. Defaults to None.
            mru (int, optional): memory resource. Defaults to None.
            hru (int, optional): hdd resources. Defaults to None.
            currency (str, optional): wanted currency. Defaults to &#34;TFT&#34;.

        Raises:
            StopChatFlow: if no nodes found

        Returns:
            list of available nodes
        &#34;&#34;&#34;

        def filter_disallowed_nodes(disallowed_node_ids, nodes):
            result = []
            for node in nodes:
                if node.node_id not in disallowed_node_ids:
                    result.append(node)
            return result

        disallowed_node_ids = []
        if filter_blocked:
            disallowed_node_ids = self.list_blocked_nodes().keys()
        if j.config.get(&#34;OVER_PROVISIONING&#34;):
            cru = 0
            mru = 0
        nodes_distribution = self._distribute_nodes(number_of_nodes, pool_ids=pool_ids)
        # to avoid using the same node with different networks
        nodes_selected = []
        selected_ids = []
        for pool_id in nodes_distribution:
            nodes_number = nodes_distribution[pool_id]
            if not pool_ids:
                pool_id = None
            nodes = j.sals.zos.get().nodes_finder.nodes_by_capacity(
                cru=cru, sru=sru, mru=mru, hru=hru, currency=currency, pool_id=pool_id
            )
            nodes = filter_disallowed_nodes(disallowed_node_ids, nodes)
            nodes = self.filter_nodes(nodes, currency == &#34;FreeTFT&#34;, ip_version=ip_version)
            for i in range(nodes_number):
                try:
                    node = random.choice(nodes)
                    while node.node_id in selected_ids:
                        node = random.choice(nodes)
                except IndexError:
                    raise StopChatFlow(
                        &#34;Failed to find resources for this reservation. If you are using a low resources environment like testnet, please make sure to allow over provisioning from the settings tab in dashboard. For more info visit &lt;a href=&#39;https://manual2.threefold.io/#/3bot_settings?id=developers-options&#39;&gt;our manual&lt;/a&gt;&#34;,
                        htmlAlert=True,
                    )
                nodes.remove(node)
                nodes_selected.append(node)
                selected_ids.append(node.node_id)
        return nodes_selected

    def filter_nodes(self, nodes, free_to_use, ip_version=None):
        &#34;&#34;&#34;filter nodes by free to use flag

        Args:
            nodes (list of nodes objects)
            free_to_use (bool)

        Returns:
            list of filtered nodes
        &#34;&#34;&#34;
        nodes = filter(j.sals.zos.get().nodes_finder.filter_is_up, nodes)
        nodes = list(nodes)
        if free_to_use:
            nodes = list(nodes)
            nodes = filter(j.sals.zos.get().nodes_finder.filter_is_free_to_use, nodes)
        elif not free_to_use:
            nodes = list(nodes)

        if ip_version:
            use_ipv4 = ip_version == &#34;IPv4&#34;

            if use_ipv4:
                nodefilter = j.sals.zos.get().nodes_finder.filter_public_ip4
            else:
                nodefilter = j.sals.zos.get().nodes_finder.filter_public_ip6

            nodes = filter(j.sals.zos.get().nodes_finder.filter_is_up, filter(nodefilter, nodes))
            if not nodes:
                raise StopChatFlow(&#34;Could not find available access node&#34;)
        return list(nodes)

    def _distribute_nodes(self, number_of_nodes, pool_ids):
        nodes_distribution = {}
        nodes_left = number_of_nodes
        result_ids = list(pool_ids) if pool_ids else []
        if not pool_ids:
            pools = self._explorer.pools.list()
            result_ids = []
            for p in pools:
                result_ids.append(p.pool_id)
        random.shuffle(result_ids)
        id_pointer = 0
        while nodes_left:
            pool_id = result_ids[id_pointer]
            if pool_id not in nodes_distribution:
                nodes_distribution[pool_id] = 0
            nodes_distribution[pool_id] += 1
            nodes_left -= 1
            id_pointer += 1
            if id_pointer == len(result_ids):
                id_pointer = 0
        return nodes_distribution

    def get_farm_names(self, number_of_nodes, bot, cru=None, sru=None, mru=None, hru=None, currency=&#34;TFT&#34;, message=&#34;&#34;):
        &#34;&#34;&#34;get list with available farm names and prompt user to choose one

        Args:
            number_of_nodes (int): required nodes count
            farm_id (int, optional): id for farm to search with. Defaults to None.
            farm_names (list, optional): farms to search in. Defaults to None.
            cru (int, optional): cpu resource. Defaults to None.
            sru (int, optional): ssd resource. Defaults to None.
            mru (int, optional): memory resource. Defaults to None.
            hru (int, optional): hdd resources. Defaults to None.
            currency (str, optional): wanted currency. Defaults to &#34;TFT&#34;.
            message (str): message to user. Defaults to &#34;&#34;

        &#34;&#34;&#34;
        farms_message = f&#34;Select 1 or more farms to distribute the {message} nodes on. If no selection is made, the farms will be chosen randomly&#34;
        empty_farms = set()
        all_farms = self._explorer.farms.list()
        retry = False
        while True:
            farms = self.select_farms(
                bot, farms_message, currency=currency, retry=retry, cru=cru, sru=sru, hru=hru, mru=mru
            )
            farms_with_no_resources = self.check_farms(
                1, farm_names=farms, cru=cru, sru=sru, mru=mru, hru=hru, currency=currency
            )
            if not farms_with_no_resources:
                return farms
            for farm_name in farms_with_no_resources:
                empty_farms.add(farm_name)
            if len(all_farms) == len(empty_farms):
                raise StopChatFlow(&#34;No Farms available containing nodes that match the required resources&#34;)
            if message:
                message = f&#34;for {message}&#34;
            retry = True
            resources_of_farm = &#34;&#34;
            if cru:
                resources_of_farm += f&#34; cru={cru}/&#34;
            if sru:
                resources_of_farm += f&#34; sru={sru}/&#34;
            if mru:
                resources_of_farm += f&#34; mru={mru}/&#34;
            if hru:
                resources_of_farm += f&#34; hru={hru}/&#34;
            if currency:
                resources_of_farm += f&#34; and the currency={currency}&#34;
            farms_message = (
                f&#34;&#34;&#34;The following farms don&#39;t meet the criteria of having {resources_of_farm} {message}: &#34;&#34;&#34;
                + &#34;, &#34;.join(farms_with_no_resources)
                + &#34;&#34;&#34;.
                Please reselect farms to check for resources or leave it empty
                &#34;&#34;&#34;
            )

    def check_farms(
        self, number_of_nodes, farm_id=None, farm_names=None, cru=None, sru=None, mru=None, hru=None, currency=&#34;TFT&#34;
    ):
        &#34;&#34;&#34;get list with available farm and make sure it has resources

        Args:
            number_of_nodes (int): required nodes count
            farm_id (int, optional): id for farm to search with. Defaults to None.
            farm_names (list, optional): farms to search in. Defaults to None.
            cru (int, optional): cpu resource. Defaults to None.
            sru (int, optional): ssd resource. Defaults to None.
            mru (int, optional): memory resource. Defaults to None.
            hru (int, optional): hdd resources. Defaults to None.
            currency (str, optional): wanted currency. Defaults to &#34;TFT&#34;.
            message (str): message to user. Defaults to &#34;&#34;

        Returns:
            list of available farm objects
        &#34;&#34;&#34;
        if not farm_names:
            return []
        farms_with_no_resources = []
        nodes_distribution = self._distribute_nodes(number_of_nodes, farm_names)
        for farm_name in nodes_distribution:
            nodes_number = nodes_distribution[farm_name]
            nodes = j.sals.zos.get().nodes_finder.nodes_by_capacity(
                farm_name=farm_name, cru=cru, sru=sru, mru=mru, hru=hru, currency=currency
            )
            nodes = self.filter_nodes(nodes, currency == &#34;FreeTFT&#34;)
            if nodes_number &gt; len(nodes):
                farms_with_no_resources.append(farm_name)
        return list(farms_with_no_resources)

    def validate_user(self, user_info):
        &#34;&#34;&#34;validate user information data to authentication

        Args:
            user_info (dict): user information
        &#34;&#34;&#34;
        if not j.core.config.get_config().get(&#34;threebot_connect&#34;, True):
            error_msg = &#34;&#34;&#34;
            This chatflow is not supported when 3Bot is in dev mode.
            To enable 3Bot connect : `j.core.config.set(&#39;threebot_connect&#39;, True)`
            &#34;&#34;&#34;
            raise j.exceptions.Runtime(error_msg)
        if not user_info[&#34;email&#34;]:
            raise j.exceptions.Value(&#34;Email shouldn&#39;t be empty&#34;)
        if not user_info[&#34;username&#34;]:
            raise j.exceptions.Value(&#34;Name of logged in user shouldn&#39;t be empty&#34;)
        return self._explorer.users.get(name=user_info[&#34;username&#34;], email=user_info[&#34;email&#34;])

    def block_node(self, node_id):
        count = j.core.db.hincrby(NODES_COUNT_KEY, node_id)
        expiration = count * NODES_DISALLOW_EXPIRATION
        node_key = f&#34;{NODES_DISALLOW_PREFIX}:{node_id}&#34;
        j.core.db.set(node_key, expiration, ex=expiration)

    def unblock_node(self, node_id, reset=True):
        node_key = f&#34;{NODES_DISALLOW_PREFIX}:{node_id}&#34;
        j.core.db.delete(node_key)
        if reset:
            j.core.db.hdel(NODES_COUNT_KEY, node_id)

    def list_blocked_nodes(self):
        &#34;&#34;&#34;
        each blocked node is stored in a key with a prefix ZOS:NODES:DISALLOWED:{node_id} and its value is the expiration period for it.
        number of failure count is defined in hash with key ZOS:NODES:FAILURE_COUNT. the hash keys are node_ids and values are count of how many times the node has been blocked

        returns
            dict: {node_id: {expiration: .., failure_count: ...}}
        &#34;&#34;&#34;
        blocked_node_keys = j.core.db.keys(f&#34;{NODES_DISALLOW_PREFIX}:*&#34;)
        failure_count_dict = j.core.db.hgetall(NODES_COUNT_KEY)
        blocked_node_values = j.core.db.mget(blocked_node_keys)
        result = {}
        for idx, key in enumerate(blocked_node_keys):
            key = key[len(NODES_DISALLOW_PREFIX) + 1 :]
            node_id = key.decode()
            expiration = int(blocked_node_values[idx])
            failure_count = int(failure_count_dict[key])
            result[node_id] = {&#34;expiration&#34;: expiration, &#34;failure_count&#34;: failure_count}
        return result

    def clear_blocked_nodes(self):
        blocked_node_keys = j.core.db.keys(f&#34;{NODES_DISALLOW_PREFIX}:*&#34;)
        if blocked_node_keys:
            j.core.db.delete(*blocked_node_keys)
        j.core.db.delete(NODES_COUNT_KEY)


reservation_chatflow = ReservationChatflow()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="jumpscale.sals.reservation_chatflow.reservation_chatflow.Network"><code class="flex name class">
<span>class <span class="ident">Network</span></span>
<span>(</span><span>network, expiration, bot, reservations, currency, resv_id)</span>
</code></dt>
<dd>
<section class="desc"><p>Network class is responsible for creation and management of networks
you can add, update, list, get, filter nodes</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>network</code></strong> :&ensp;<code>jumpscale.clients.explorer.models.TfgridWorkloadsReservationNetwork1</code></dt>
<dd>network object</dd>
<dt><strong><code>expiration</code></strong> :&ensp;<code>datetime</code></dt>
<dd>timestamp of the date for network expiration</dd>
<dt>bot (GedisChatBot):Instance from the bot that uses network</dt>
<dt><strong><code>reservations</code></strong> :&ensp;<code>list</code> of <code>TfgridWorkloadsReservationData1</code></dt>
<dd>list of reservations</dd>
<dt><strong><code>currency</code></strong> :&ensp;<code>str</code></dt>
<dd>currency used "TFT", "FreeTFT"</dd>
<dt><strong><code>resv_id</code></strong> :&ensp;<code>int</code></dt>
<dd>reservation ID</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">class Network:
    def __init__(self, network, expiration, bot, reservations, currency, resv_id):
        &#34;&#34;&#34;Network class is responsible for creation and management of networks
            you can add, update, list, get, filter nodes
        Args:
            network (jumpscale.clients.explorer.models.TfgridWorkloadsReservationNetwork1): network object
            expiration (datetime): timestamp of the date for network expiration
            bot (GedisChatBot):Instance from the bot that uses network
            reservations (list of TfgridWorkloadsReservationData1): list of reservations
            currency (str): currency used &#34;TFT&#34;, &#34;FreeTFT&#34;
            resv_id (int): reservation ID
        &#34;&#34;&#34;
        self._network = network
        self._expiration = expiration
        self.name = network.name
        self._used_ips = []
        self._is_dirty = False
        self._sal = j.sals.reservation_chatflow
        self._bot = bot
        self._fill_used_ips(reservations)
        self.currency = currency
        self.resv_id = resv_id
        self.solutions = StoredFactory(TfgridSolution1)

    def _fill_used_ips(self, reservations):
        for reservation in reservations:
            if reservation.next_action != NextAction.DEPLOY:
                continue
            for kubernetes in reservation.data_reservation.kubernetes:
                if kubernetes.network_id == self._network.name:
                    self._used_ips.append(kubernetes.ipaddress)
            for container in reservation.data_reservation.containers:
                for nc in container.network_connection:
                    if nc.network_id == self._network.name:
                        self._used_ips.append(nc.ipaddress)

    def add_node(self, node):
        &#34;&#34;&#34;add node to the network

        Args:
            node (jumpscale.clients.explorer.models.TfgridDirectoryNode2): node object
        &#34;&#34;&#34;
        network_resources = self._network.network_resources
        used_ip_ranges = set()
        for network_resource in network_resources:
            if network_resource.node_id == node.node_id:
                return
            used_ip_ranges.add(network_resource.iprange)
            for peer in network_resource.peers:
                used_ip_ranges.add(peer.iprange)
        else:
            network_range = netaddr.IPNetwork(self._network.iprange)
            subnet = None
            for _, subnet in enumerate(network_range.subnet(24)):
                if str(subnet) not in used_ip_ranges:
                    break
            else:
                self._bot.stop(&#34;Failed to find free network&#34;)
            j.sals.zos.get().network.add_node(self._network, node.node_id, str(subnet))
            self._is_dirty = True

    def get_node_range(self, node):
        &#34;&#34;&#34;get ip range from specified node

        Args:
            node (jumpscale.client.explorer.models.TfgridDirectoryNode2): node object

        Returns:
            (IPRange): ip range field
        &#34;&#34;&#34;
        for network_resource in self._network.network_resources:
            if network_resource.node_id == node.node_id:
                return network_resource.iprange
        self._bot.stop(f&#34;Node {node.node_id} is not part of network&#34;)

    def update(self, tid, currency=None, bot=None):
        &#34;&#34;&#34;create reservations and update status and show payments stuff
        Args:
            tid (int): customer tid (j.core.identity.me.tid)
            currency (str, optional): &#34;TFT&#34; or &#34;FreeTFT&#34;. Defaults to None.
            bot (GedisChatBot, optional): bot instance. Defaults to None.

        Returns:
            bool: True if successful
        &#34;&#34;&#34;
        if self._is_dirty:
            reservation = j.sals.zos.get().reservation_create()
            reservation.data_reservation.networks.append(self._network)
            form_info = {
                &#34;chatflow&#34;: &#34;network&#34;,
                &#34;Currency&#34;: self.currency,
                &#34;Solution expiration&#34;: self._expiration.timestamp(),
            }
            metadata = j.sals.reservation_chatflow.get_solution_metadata(
                self.name, SolutionType.Network, form_info=form_info
            )

            metadata[&#34;parent_network&#34;] = self.resv_id
            self._sal.add_reservation_metadata(reservation, metadata)

            reservation_create = self._sal.register_reservation(
                reservation, self._expiration.timestamp(), tid, currency=currency, bot=bot
            )
            rid = reservation_create.reservation_id
            payment, _ = j.sals.reservation_chatflow.show_payments(self._bot, reservation_create, currency)
            if payment[&#34;free&#34;]:
                pass
            elif payment[&#34;wallet&#34;]:
                j.sals.zos.get().billing.payout_farmers(payment[&#34;wallet&#34;], reservation_create)
                j.sals.reservation_chatflow.wait_payment(bot, rid, threebot_app=False)
            else:
                j.sals.reservation_chatflow.wait_payment(
                    bot, rid, threebot_app=True, reservation_create_resp=reservation_create
                )
            wait_reservation_results = self._sal.wait_reservation(self._bot, rid)
            # Update solution saved locally
            explorer_name = self._sal._explorer.url.split(&#34;.&#34;)[1]
            old_solution = self.solutions.get(f&#34;{explorer_name}_{self.resv_id}&#34;)
            solution = self.solutions.get(
                f&#34;{explorer_name}_{rid}&#34;,
                explorer=old_solution.explorer,
                form_info=old_solution.form_info,
                rid=rid,
                solution_type=old_solution.solution_type,
            )
            solution.name = self.name
            solution.save()
            self.solutions.delete(f&#34;{explorer_name}_{self.resv_id}&#34;)
            return wait_reservation_results
        return True

    def copy(self, customer_tid):
        &#34;&#34;&#34;create a copy of network object

        Args:
            customer_tid (int): customet tid (j.core.identity.me.tid)

        Returns:
            (Network): copy of the network
        &#34;&#34;&#34;
        network_copy = None
        explorer = j.core.identity.me.explorer
        reservation = explorer.reservations.get(self.resv_id)
        networks = self._sal.list_networks(customer_tid, [reservation])
        for key in networks.keys():
            network, expiration, currency, resv_id = networks[key]
            if network.name == self.name:
                network_copy = Network(network, expiration, self._bot, [reservation], currency, resv_id)
                break
        if network_copy:
            network_copy._used_ips = copy.copy(self._used_ips)
        return network_copy

    def ask_ip_from_node(self, node, message):
        &#34;&#34;&#34;ask for free ip from a specific node and mark it as used in chatbot

        Args:
            node (jumpscale.client.explorer.models.TfgridDirectoryNode2): reqired node to ask ip from
            message (str): message to the chatflow slide

        Returns:
            [str]: free ip
        &#34;&#34;&#34;
        ip_range = self.get_node_range(node)
        freeips = []
        hosts = netaddr.IPNetwork(ip_range).iter_hosts()
        next(hosts)  # skip ip used by node
        for host in hosts:
            ip = str(host)
            if ip not in self._used_ips:
                freeips.append(ip)
        ip_address = self._bot.drop_down_choice(message, freeips, required=True)
        self._used_ips.append(ip_address)
        return ip_address

    def get_free_ip(self, node):
        &#34;&#34;&#34;return free ip

        Args:
            node (jumpscale.client.explorer.models.TfgridDirectoryNode2): reqired node to get free ip from

        Returns:
            [str]: free ip to use
        &#34;&#34;&#34;
        ip_range = self.get_node_range(node)
        hosts = netaddr.IPNetwork(ip_range).iter_hosts()
        next(hosts)  # skip ip used by node
        for host in hosts:
            ip = str(host)
            if ip not in self._used_ips:
                return ip
        return None</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="jumpscale.sals.reservation_chatflow.reservation_chatflow.Network.add_node"><code class="name flex">
<span>def <span class="ident">add_node</span></span>(<span>self, node)</span>
</code></dt>
<dd>
<section class="desc"><p>add node to the network</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>node</code></strong> :&ensp;<code>jumpscale.clients.explorer.models.TfgridDirectoryNode2</code></dt>
<dd>node object</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def add_node(self, node):
    &#34;&#34;&#34;add node to the network

    Args:
        node (jumpscale.clients.explorer.models.TfgridDirectoryNode2): node object
    &#34;&#34;&#34;
    network_resources = self._network.network_resources
    used_ip_ranges = set()
    for network_resource in network_resources:
        if network_resource.node_id == node.node_id:
            return
        used_ip_ranges.add(network_resource.iprange)
        for peer in network_resource.peers:
            used_ip_ranges.add(peer.iprange)
    else:
        network_range = netaddr.IPNetwork(self._network.iprange)
        subnet = None
        for _, subnet in enumerate(network_range.subnet(24)):
            if str(subnet) not in used_ip_ranges:
                break
        else:
            self._bot.stop(&#34;Failed to find free network&#34;)
        j.sals.zos.get().network.add_node(self._network, node.node_id, str(subnet))
        self._is_dirty = True</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.reservation_chatflow.reservation_chatflow.Network.ask_ip_from_node"><code class="name flex">
<span>def <span class="ident">ask_ip_from_node</span></span>(<span>self, node, message)</span>
</code></dt>
<dd>
<section class="desc"><p>ask for free ip from a specific node and mark it as used in chatbot</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>node</code></strong> :&ensp;<code>jumpscale.client.explorer.models.TfgridDirectoryNode2</code></dt>
<dd>reqired node to ask ip from</dd>
<dt><strong><code>message</code></strong> :&ensp;<code>str</code></dt>
<dd>message to the chatflow slide</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>[str]: free ip</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def ask_ip_from_node(self, node, message):
    &#34;&#34;&#34;ask for free ip from a specific node and mark it as used in chatbot

    Args:
        node (jumpscale.client.explorer.models.TfgridDirectoryNode2): reqired node to ask ip from
        message (str): message to the chatflow slide

    Returns:
        [str]: free ip
    &#34;&#34;&#34;
    ip_range = self.get_node_range(node)
    freeips = []
    hosts = netaddr.IPNetwork(ip_range).iter_hosts()
    next(hosts)  # skip ip used by node
    for host in hosts:
        ip = str(host)
        if ip not in self._used_ips:
            freeips.append(ip)
    ip_address = self._bot.drop_down_choice(message, freeips, required=True)
    self._used_ips.append(ip_address)
    return ip_address</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.reservation_chatflow.reservation_chatflow.Network.copy"><code class="name flex">
<span>def <span class="ident">copy</span></span>(<span>self, customer_tid)</span>
</code></dt>
<dd>
<section class="desc"><p>create a copy of network object</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>customer_tid</code></strong> :&ensp;<code>int</code></dt>
<dd>customet tid (j.core.identity.me.tid)</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>(Network): copy of the network</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def copy(self, customer_tid):
    &#34;&#34;&#34;create a copy of network object

    Args:
        customer_tid (int): customet tid (j.core.identity.me.tid)

    Returns:
        (Network): copy of the network
    &#34;&#34;&#34;
    network_copy = None
    explorer = j.core.identity.me.explorer
    reservation = explorer.reservations.get(self.resv_id)
    networks = self._sal.list_networks(customer_tid, [reservation])
    for key in networks.keys():
        network, expiration, currency, resv_id = networks[key]
        if network.name == self.name:
            network_copy = Network(network, expiration, self._bot, [reservation], currency, resv_id)
            break
    if network_copy:
        network_copy._used_ips = copy.copy(self._used_ips)
    return network_copy</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.reservation_chatflow.reservation_chatflow.Network.get_free_ip"><code class="name flex">
<span>def <span class="ident">get_free_ip</span></span>(<span>self, node)</span>
</code></dt>
<dd>
<section class="desc"><p>return free ip</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>node</code></strong> :&ensp;<code>jumpscale.client.explorer.models.TfgridDirectoryNode2</code></dt>
<dd>reqired node to get free ip from</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>[str]: free ip to use</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def get_free_ip(self, node):
    &#34;&#34;&#34;return free ip

    Args:
        node (jumpscale.client.explorer.models.TfgridDirectoryNode2): reqired node to get free ip from

    Returns:
        [str]: free ip to use
    &#34;&#34;&#34;
    ip_range = self.get_node_range(node)
    hosts = netaddr.IPNetwork(ip_range).iter_hosts()
    next(hosts)  # skip ip used by node
    for host in hosts:
        ip = str(host)
        if ip not in self._used_ips:
            return ip
    return None</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.reservation_chatflow.reservation_chatflow.Network.get_node_range"><code class="name flex">
<span>def <span class="ident">get_node_range</span></span>(<span>self, node)</span>
</code></dt>
<dd>
<section class="desc"><p>get ip range from specified node</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>node</code></strong> :&ensp;<code>jumpscale.client.explorer.models.TfgridDirectoryNode2</code></dt>
<dd>node object</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>(IPRange): ip range field</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def get_node_range(self, node):
    &#34;&#34;&#34;get ip range from specified node

    Args:
        node (jumpscale.client.explorer.models.TfgridDirectoryNode2): node object

    Returns:
        (IPRange): ip range field
    &#34;&#34;&#34;
    for network_resource in self._network.network_resources:
        if network_resource.node_id == node.node_id:
            return network_resource.iprange
    self._bot.stop(f&#34;Node {node.node_id} is not part of network&#34;)</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.reservation_chatflow.reservation_chatflow.Network.update"><code class="name flex">
<span>def <span class="ident">update</span></span>(<span>self, tid, currency=None, bot=None)</span>
</code></dt>
<dd>
<section class="desc"><p>create reservations and update status and show payments stuff</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>tid</code></strong> :&ensp;<code>int</code></dt>
<dd>customer tid (j.core.identity.me.tid)</dd>
<dt><strong><code>currency</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>"TFT" or "FreeTFT". Defaults to None.</dd>
<dt><strong><code>bot</code></strong> :&ensp;<code>GedisChatBot</code>, optional</dt>
<dd>bot instance. Defaults to None.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>bool</code></strong></dt>
<dd>True if successful</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def update(self, tid, currency=None, bot=None):
    &#34;&#34;&#34;create reservations and update status and show payments stuff
    Args:
        tid (int): customer tid (j.core.identity.me.tid)
        currency (str, optional): &#34;TFT&#34; or &#34;FreeTFT&#34;. Defaults to None.
        bot (GedisChatBot, optional): bot instance. Defaults to None.

    Returns:
        bool: True if successful
    &#34;&#34;&#34;
    if self._is_dirty:
        reservation = j.sals.zos.get().reservation_create()
        reservation.data_reservation.networks.append(self._network)
        form_info = {
            &#34;chatflow&#34;: &#34;network&#34;,
            &#34;Currency&#34;: self.currency,
            &#34;Solution expiration&#34;: self._expiration.timestamp(),
        }
        metadata = j.sals.reservation_chatflow.get_solution_metadata(
            self.name, SolutionType.Network, form_info=form_info
        )

        metadata[&#34;parent_network&#34;] = self.resv_id
        self._sal.add_reservation_metadata(reservation, metadata)

        reservation_create = self._sal.register_reservation(
            reservation, self._expiration.timestamp(), tid, currency=currency, bot=bot
        )
        rid = reservation_create.reservation_id
        payment, _ = j.sals.reservation_chatflow.show_payments(self._bot, reservation_create, currency)
        if payment[&#34;free&#34;]:
            pass
        elif payment[&#34;wallet&#34;]:
            j.sals.zos.get().billing.payout_farmers(payment[&#34;wallet&#34;], reservation_create)
            j.sals.reservation_chatflow.wait_payment(bot, rid, threebot_app=False)
        else:
            j.sals.reservation_chatflow.wait_payment(
                bot, rid, threebot_app=True, reservation_create_resp=reservation_create
            )
        wait_reservation_results = self._sal.wait_reservation(self._bot, rid)
        # Update solution saved locally
        explorer_name = self._sal._explorer.url.split(&#34;.&#34;)[1]
        old_solution = self.solutions.get(f&#34;{explorer_name}_{self.resv_id}&#34;)
        solution = self.solutions.get(
            f&#34;{explorer_name}_{rid}&#34;,
            explorer=old_solution.explorer,
            form_info=old_solution.form_info,
            rid=rid,
            solution_type=old_solution.solution_type,
        )
        solution.name = self.name
        solution.save()
        self.solutions.delete(f&#34;{explorer_name}_{self.resv_id}&#34;)
        return wait_reservation_results
    return True</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="jumpscale.sals.reservation_chatflow.reservation_chatflow.ReservationChatflow"><code class="flex name class">
<span>class <span class="ident">ReservationChatflow</span></span>
<span>(</span><span>**kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>This class is responsible for managing, creating, cancelling reservations</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">class ReservationChatflow:
    def __init__(self, **kwargs):
        &#34;&#34;&#34;This class is responsible for managing, creating, cancelling reservations&#34;&#34;&#34;
        self.solutions = StoredFactory(TfgridSolution1)
        self.payments = StoredFactory(TfgridSolutionsPayment1)
        self.deployed_reservations = StoredFactory(DeployedReservation)

    @property
    def me(self):
        return j.core.identity.me

    @property
    def _explorer(self):
        return j.core.identity.me.explorer

    def decrypt_reservation_metadata(self, metadata_encrypted):
        &#34;&#34;&#34;decrypt the reservation metadata using identity nacl

        Args:
            metadata_encrypted (bytes): encrypted metadata

        Returns:
            [str]: decrypted solution metadata
        &#34;&#34;&#34;
        pk = j.core.identity.me.nacl.signing_key.verify_key.to_curve25519_public_key()
        sk = j.core.identity.me.nacl.signing_key.to_curve25519_private_key()
        box = Box(sk, pk)
        return box.decrypt(base64.b85decode(metadata_encrypted.encode())).decode()

    def check_solution_type(self, reservation):
        &#34;&#34;&#34;categorize the solutions by types

        Args:
            reservation (jumpscale.clients.explorer.models.TfgridWorkloadsReservation1): user reservation

        Returns:
            [jumpscale.clients.explorer.models.SolutionType]: type of the solution
        &#34;&#34;&#34;
        containers = reservation.data_reservation.containers
        volumes = reservation.data_reservation.volumes
        zdbs = reservation.data_reservation.zdbs
        kubernetes = reservation.data_reservation.kubernetes
        networks = reservation.data_reservation.networks
        if containers == [] and volumes == [] and zdbs == [] and kubernetes == [] and networks:
            return SolutionType.Network
        elif kubernetes != []:
            return SolutionType.Kubernetes
        elif len(containers) != 0:
            if &#34;ubuntu&#34; in containers[0].flist:
                return SolutionType.Ubuntu
            elif &#34;minio&#34; in containers[0].flist:
                return SolutionType.Minio
            elif &#34;gitea&#34; in containers[0].flist:
                return SolutionType.Gitea
            elif &#34;tcprouter&#34; in containers[0].flist:
                return SolutionType.Exposed
            return &#34;flist&#34;
        elif reservation.data_reservation.domain_delegates:
            return SolutionType.DelegatedDomain
        return SolutionType.Unknown

    def get_solution_ubuntu_info(self, metadata, reservation):
        &#34;&#34;&#34;get ubuntu solutions information from metadata on explorer and update local ones

        Args:
            metadata (dict): ubuntu reservation metadata
            reservation (jumpscale.clients.explorer.models.TfgridWorkloadsReservation1): ubuntu reservation

        Returns:
            [dict]: updated metadata
        &#34;&#34;&#34;
        envs = reservation.data_reservation.containers[0].environment
        env_variable = &#34;&#34;
        metadata[&#34;form_info&#34;][&#34;Public key&#34;] = envs[&#34;pub_key&#34;].strip(&#34; &#34;)
        envs.pop(&#34;pub_key&#34;)
        metadata[&#34;form_info&#34;][&#34;CPU&#34;] = reservation.data_reservation.containers[0].capacity.cpu
        metadata[&#34;form_info&#34;][&#34;Memory&#34;] = reservation.data_reservation.containers[0].capacity.memory
        metadata[&#34;form_info&#34;][&#34;Root filesystem Type&#34;] = str(
            reservation.data_reservation.containers[0].capacity.disk_type
        )
        metadata[&#34;form_info&#34;][&#34;Root filesystem Size&#34;] = (
            reservation.data_reservation.containers[0].capacity.disk_size or 256
        )
        for key, value in envs.items():
            env_variable += f&#34;{key}={value},&#34;
        metadata[&#34;form_info&#34;][&#34;Env variables&#34;] = str(env_variable)
        metadata[&#34;form_info&#34;][&#34;IP Address&#34;] = reservation.data_reservation.containers[0].network_connection[0].ipaddress
        return metadata

    def get_solution_exposed_info(self, reservation):
        &#34;&#34;&#34;get information about solution exposed from reservation

        Args:
            reservation (jumpscale.clients.explorer.models.TfgridWorkloadsReservation1)

        return dict of info
        &#34;&#34;&#34;

        def get_arg(cmd, arg):
            idx = cmd.index(arg)
            if idx:
                return cmd[idx + 1]
            return None

        info = {}
        for container in reservation.data_reservation.containers:
            if &#34;tcprouter&#34; in container.flist:
                entrypoint = container.entrypoint.split()
                local = get_arg(entrypoint, &#34;-local&#34;)
                if local:
                    info[&#34;Port&#34;] = local.split(&#34;:&#34;)[-1]
                localtls = get_arg(entrypoint, &#34;-local-tls&#34;)
                if localtls:
                    info[&#34;port-tls&#34;] = localtls.split(&#34;:&#34;)[-1]
                remote = get_arg(entrypoint, &#34;-remote&#34;)
                if remote:
                    info[&#34;Name Server&#34;] = remote.split(&#34;:&#34;)[0]
        for proxy in reservation.data_reservation.reverse_proxies:
            info[&#34;Domain&#34;] = proxy.domain
        return info

    def get_solution_flist_info(self, metadata, reservation):
        &#34;&#34;&#34;get flist solutions information from metadata on explorer and update local ones

        Args:
            metadata (dict): flist reservation metadata
            reservation (jumpscale.clients.explorer.models.TfgridWorkloadsReservation1): ubuntu reservation

        Returns:
            [dict]: updated metadata
        &#34;&#34;&#34;
        envs = reservation.data_reservation.containers[0].environment
        env_variable = &#34;&#34;
        for key, value in envs.items():
            env_variable += f&#34;{key}={value}, &#34;
        metadata[&#34;form_info&#34;][&#34;CPU&#34;] = reservation.data_reservation.containers[0].capacity.cpu
        metadata[&#34;form_info&#34;][&#34;Memory&#34;] = reservation.data_reservation.containers[0].capacity.memory
        metadata[&#34;form_info&#34;][&#34;Root filesystem Type&#34;] = str(
            reservation.data_reservation.containers[0].capacity.disk_type
        )
        metadata[&#34;form_info&#34;][&#34;Root filesystem Size&#34;] = (
            reservation.data_reservation.containers[0].capacity.disk_size or 256
        )
        metadata[&#34;form_info&#34;][&#34;Env variables&#34;] = str(env_variable)
        metadata[&#34;form_info&#34;][&#34;Flist link&#34;] = reservation.data_reservation.containers[0].flist
        metadata[&#34;form_info&#34;][&#34;Interactive&#34;] = reservation.data_reservation.containers[0].interactive
        if metadata[&#34;form_info&#34;][&#34;Interactive&#34;]:
            metadata[&#34;form_info&#34;][&#34;Port&#34;] = &#34;7681&#34;
        metadata[&#34;form_info&#34;][&#34;Entry point&#34;] = reservation.data_reservation.containers[0].entrypoint
        metadata[&#34;form_info&#34;][&#34;IP Address&#34;] = reservation.data_reservation.containers[0].network_connection[0].ipaddress
        return metadata

    def get_solution_domain_delegates_info(self, reservation):
        &#34;&#34;&#34;get domain delegated metadata info

        Args:
            reservation (jumpscale.clients.explorer.models.TfgridWorkloadsReservation1): reservation object

        Returns:
            [dict]: domain delegated metadata info
        &#34;&#34;&#34;

        delegated_domain = reservation.data_reservation.domain_delegates[0]
        return {&#34;Domain&#34;: delegated_domain.domain, &#34;Gateway&#34;: delegated_domain.node_id}

    def save_reservation(self, rid, name, solution_type, form_info=None):
        &#34;&#34;&#34;save user reservation in local config manager

        Args:
            rid (int): user identity (j.core.identity.me.tid)
            name (str): reservation name
            solution_type (SolutionType): type of the solution from types enum
            form_info (dict, optional): reservation user info. Defaults to None.
        &#34;&#34;&#34;
        form_info = form_info or {}
        explorer_name = self._explorer.url.split(&#34;.&#34;)[1]
        reservation = self.solutions.get(f&#34;{explorer_name}_{rid}&#34;)
        reservation.rid = rid
        reservation.name = name
        reservation.solution_type = solution_type
        reservation.form_info = form_info
        reservation.explorer = self._explorer.url
        reservation.save()

    def get_solutions_explorer(self, deployed=True):
        &#34;&#34;&#34;get the updated reservations from explorer

        Args:
            deployed (bool, optional): set False to get all reservations. Defaults to True.

        Returns:
            list: list of reservations
        &#34;&#34;&#34;
        customer_tid = self.me.tid
        reservations_data = []
        reservations = []
        if deployed:
            reservations = self._explorer.reservations.list(customer_tid, &#34;DEPLOY&#34;)
        else:
            reservations = self._explorer.reservations.list(customer_tid)
        networks = []
        dupnames = {}
        for reservation in sorted(reservations, key=lambda res: res.id, reverse=True):
            info = {}
            if reservation.metadata:
                try:
                    metadata = self.decrypt_reservation_metadata(reservation.metadata)
                    metadata = json.loads(metadata)
                except Exception:
                    continue
                if &#34;form_info&#34; not in metadata:
                    solution_type = self.check_solution_type(reservation).value
                else:
                    solution_type = metadata[&#34;form_info&#34;].pop(&#34;chatflow&#34;, SolutionType.Unknown.value)
                if solution_type == SolutionType.Unknown.value:
                    continue
                elif solution_type == SolutionType.Ubuntu.value:
                    metadata = self.get_solution_ubuntu_info(metadata, reservation)
                elif solution_type == SolutionType.Flist.value:
                    metadata = self.get_solution_flist_info(metadata, reservation)
                elif solution_type == SolutionType.Network.value:
                    if metadata[&#34;name&#34;] in networks:
                        continue
                    networks.append(metadata[&#34;name&#34;])
                elif solution_type == SolutionType.Gitea.value:
                    metadata[&#34;form_info&#34;][&#34;Public key&#34;] = reservation.data_reservation.containers[0].environment[
                        &#34;pub_key&#34;
                    ]
                elif solution_type == SolutionType.Exposed.value:
                    meta = metadata
                    metadata = {&#34;form_info&#34;: meta}
                    metadata[&#34;form_info&#34;].update(self.get_solution_exposed_info(reservation))
                    metadata[&#34;name&#34;] = metadata[&#34;form_info&#34;].get(&#34;Domain&#34;)

                info = metadata[&#34;form_info&#34;]
                name = metadata[&#34;name&#34;]
            else:
                solution_type = self.check_solution_type(reservation)
                if type(solution_type) is not str:
                    solution_type = solution_type.value
                info = {}
                name = f&#34;unknown_{reservation.id}&#34;
                if solution_type == SolutionType.Unknown.value:
                    continue
                elif solution_type == SolutionType.Network.value:
                    name = reservation.data_reservation.networks[0].name
                    if name in networks:
                        continue
                    networks.append(name)
                elif solution_type == SolutionType.DelegatedDomain.value:
                    info = self.get_solution_domain_delegates_info(reservation)
                    if not info.get(&#34;Solution name&#34;):
                        name = f&#34;unknown_{reservation.id}&#34;
                    else:
                        name = info[&#34;Solution name&#34;]
                elif solution_type == SolutionType.Exposed.value:
                    info = self.get_solution_exposed_info(reservation)
                    info[&#34;Solution name&#34;] = name
                    name = info.get(&#34;Domain&#34;)

            count = dupnames.setdefault(solution_type, {}).setdefault(name, 1)
            if count != 1:
                dupnames[solution_type][name] = count + 1
                name = f&#34;{name}_{count}&#34;
            # append reservation
            reservations_data.append(
                {
                    &#34;id&#34;: reservation.id,
                    &#34;name&#34;: name,
                    &#34;solution_type&#34;: solution_type,
                    &#34;form_info&#34;: info,
                    &#34;status&#34;: reservation.next_action.name,
                    &#34;reservation_date&#34;: reservation.epoch.ctime(),
                    &#34;reservation&#34;: reservation._get_data(),
                }
            )
        return reservations_data

    def update_local_reservations(self):
        &#34;&#34;&#34;update local reserfvations with new ones&#34;&#34;&#34;
        for obj in self.solutions.list_all():
            self.solutions.delete(obj)
        reservations = self.get_solutions_explorer()
        for reservation in reservations:
            self.save_reservation(
                reservation[&#34;id&#34;], reservation[&#34;name&#34;], reservation[&#34;solution_type&#34;], form_info=reservation[&#34;form_info&#34;]
            )

    def list_wallets(self):
        &#34;&#34;&#34;
        List all stellar client wallets from bcdb. Based on explorer instance only either wallets with network type TEST or STD are returned
        rtype: list
        &#34;&#34;&#34;
        if &#34;devnet&#34; in self._explorer.url or &#34;testnet&#34; in self._explorer.url:
            network_type = StellarNetwork.TEST
        else:
            network_type = StellarNetwork.STD

        wallets_list = j.clients.stellar.list_all()
        wallets = dict()
        for wallet_name in wallets_list:
            wallet = j.clients.stellar.find(wallet_name)
            if wallet.network != network_type:
                continue
            wallets[wallet_name] = wallet
        return wallets

    def show_escrow_qr(self, bot, reservation_create_resp, expiration_provisioning):
        &#34;&#34;&#34;
        Show in chatflow the QR code with the details of the escrow information for payment
        &#34;&#34;&#34;
        escrow_info = j.sals.zos.get().reservation_escrow_information_with_qrcodes(reservation_create_resp)
        escrow_address = escrow_info[&#34;escrow_address&#34;]
        escrow_asset = escrow_info[&#34;escrow_asset&#34;]
        reservationid = escrow_info[&#34;reservationid&#34;]
        qrcode = escrow_info[&#34;qrcode&#34;]
        remaning_time = j.data.time.get(expiration_provisioning).humanize()
        payment_details = self.get_payment_details(escrow_info, escrow_asset.split(&#34;:&#34;)[0])

        message_text = f&#34;&#34;&#34;
        &lt;h3&gt;Make a Payment&lt;/h3&gt;
        Scan the QR code with your wallet (do not change the message) or enter the information below manually and proceed with the payment. Make sure to add the reservationid as memo_text.
        &lt;p&gt;If no payment is made {remaning_time} the reservation will be canceled&lt;/p&gt;

        &lt;h4&gt; Destination Wallet Address: &lt;/h4&gt;  {escrow_address} \n
        &lt;h4&gt; Currency: &lt;/h4&gt;  {escrow_asset} \n
        &lt;h4&gt; Reservation ID: &lt;/h4&gt;  {reservationid} \n
        &lt;h4&gt; Payment Details: &lt;/h4&gt; {payment_details} \n
        &#34;&#34;&#34;

        bot.qrcode_show(data=qrcode, msg=message_text, scale=4, update=True, html=True)

    def create_payment(
        self, rid, currency, escrow_address, escrow_asset, total_amount, payment_source, farmer_payments
    ):
        &#34;&#34;&#34;create payment object and save it locally

        Args:
            rid (int): customer tid
            currency (str): reservation currency &#34;TFT&#34; or &#34;FreeTFT&#34;
            escrow_address (str): escrow_address
            escrow_asset (str): escrow asset
            total_amount (str): paid amount
            payment_source (str): payment source
            farmer_payments (list): total list of farmer payments

        Returns:
            [jumpscale.clients.explorer.models.TfgridSolutionsPayment1]: payment object
        &#34;&#34;&#34;
        explorer_name = self._explorer.url.split(&#34;.&#34;)[1]
        payment_obj = self.payments.get(f&#34;{explorer_name}_{rid}&#34;)
        payment_obj.explorer = self._explorer.url
        payment_obj.rid = rid
        payment_obj.currency = currency
        payment_obj.escrow_address = escrow_address
        payment_obj.escrow_asset = escrow_asset
        payment_obj.total_amount = str(total_amount)
        payment_obj.transaction_fees = f&#34;0.1 {currency}&#34;
        payment_obj.payment_source = payment_source
        for farmer in farmer_payments:
            farmer_name = self._explorer.farms.get(farm_id=farmer[&#34;farmer_id&#34;]).name
            payment_obj.farmer_payments[farmer_name] = farmer[&#34;total_amount&#34;]
        return payment_obj

    def get_payment_details(self, escrow_info, currency):
        &#34;&#34;&#34;split payment details and get each one

        Args:
            escrow_info (str): payment info
            currency (str): currency used

        Returns:
            [str]: payment details
        &#34;&#34;&#34;

        farmer_payments = escrow_info[&#34;farmer_payments&#34;]
        total_amount = escrow_info[&#34;total_amount&#34;]

        payment_details = &#34;&#34;
        payment_details += &#39;&lt;table style=&#34;width: 50%; font-family: arial, sans-serif; border-collapse: collapse;&#34;&gt;&#39;
        for farmer in farmer_payments:
            farmer_name = self._explorer.farms.get(farm_id=farmer[&#34;farmer_id&#34;]).name
            payment_details += (
                f&#34;&lt;tr&gt;&lt;td&gt;Farmer {farmer_name}&lt;/td&gt;&lt;td&gt;{format(farmer[&#39;total_amount&#39;],&#39;.7f&#39;)} {currency}&lt;/td&gt;&lt;/tr&gt;&#34;
            )
        payment_details += f&#34;&lt;tr&gt;&lt;td&gt;Transaction Fees&lt;/td&gt;&lt;td&gt;{0.1} {currency}&lt;/td&gt;&lt;/tr&gt;&#34;
        payment_details += f&#34;&lt;tr&gt;&lt;td&gt;Total amount&lt;/td&gt;&lt;td&gt;{format(total_amount + 0.1,&#39;.7f&#39;)} {currency}&lt;/td&gt;&lt;/tr&gt;&#34;
        payment_details += &#34;&lt;/table&gt;&#34;

        return payment_details

    def show_payments(self, bot, reservation_create_resp, currency):
        &#34;&#34;&#34;Show valid payment options in chatflow available. All available wallets possible are shown or usage of External wallet (QR code) is shown
        where a QR code is viewed for the user to scan and continue with their payment

        Args:
            bot (GedisChatBot): instance of the used bot
            reservation_create_resp (jumpscale.clients.explorer.models.TfgridWorkloadsReservation1): result of reservation
            currency (str): currency used

        Returns:
            [jumpscale.clients.explorer.models.TfgridSolutionsPayment1]: payment object wallet in case a wallet is used
        &#34;&#34;&#34;
        payment = {&#34;wallet&#34;: None, &#34;free&#34;: False}
        if not (reservation_create_resp.escrow_information and reservation_create_resp.escrow_information.details):
            payment[&#34;free&#34;] = True
            return payment, None
        escrow_info = j.sals.zos.get().reservation_escrow_information_with_qrcodes(reservation_create_resp)

        escrow_address = escrow_info[&#34;escrow_address&#34;]
        escrow_asset = escrow_info[&#34;escrow_asset&#34;]
        total_amount = escrow_info[&#34;total_amount&#34;]
        rid = reservation_create_resp.reservation_id

        wallets = self.list_wallets()
        wallet_names = []
        for w in wallets.keys():
            wallet_names.append(w)
        wallet_names.append(&#34;External Wallet (QR Code)&#34;)

        payment_details = self.get_payment_details(escrow_info, currency)

        message = f&#34;&#34;&#34;
        Billing details:
        &lt;h4&gt; Destination Wallet address: &lt;/h4&gt;  {escrow_address} \n
        &lt;h4&gt; Currency: &lt;/h4&gt;  {escrow_asset} \n
        &lt;h4&gt; Payment Details: &lt;/h4&gt; {payment_details} \n
        &lt;h4&gt; Choose a wallet name to use for payment or proceed with the payment through an external wallet (QR Code) &lt;/h4&gt;
        &#34;&#34;&#34;
        retry = False
        while True:

            result = bot.single_choice(message, wallet_names, html=True, retry=retry)

            if result not in wallet_names:
                retry = True
                continue
            if result == &#34;External Wallet (QR Code)&#34;:
                reservation = self._explorer.reservations.get(rid)
                self.show_escrow_qr(bot, reservation_create_resp, reservation.data_reservation.expiration_provisioning)
                payment_obj = self.create_payment(
                    rid=rid,
                    currency=currency,
                    escrow_address=escrow_address,
                    escrow_asset=escrow_asset,
                    total_amount=total_amount,
                    payment_source=&#34;external_wallet&#34;,
                    farmer_payments=escrow_info[&#34;farmer_payments&#34;],
                )
                return payment, payment_obj
            else:
                payment[&#34;wallet&#34;] = wallets[result]
                balances = payment[&#34;wallet&#34;].get_balance().balances
                current_balance = None
                for balance in balances:
                    if balance.asset_code == currency:
                        current_balance = balance.balance
                        if float(current_balance) &gt;= total_amount:
                            payment_obj = self.create_payment(
                                rid=rid,
                                currency=currency,
                                escrow_address=escrow_address,
                                escrow_asset=escrow_asset,
                                total_amount=total_amount,
                                payment_source=result,
                                farmer_payments=escrow_info[&#34;farmer_payments&#34;],
                            )
                            return payment, payment_obj
                retry = True
                message = f&#34;&#34;&#34;
                &lt;h2 style=&#34;color: #142850;&#34;&gt;&lt;b style=&#34;color: #00909e;&#34;&gt;{total_amount} {currency}&lt;/b&gt; are required, but only &lt;b style=&#34;color: #00909e;&#34;&gt;{current_balance} {currency}&lt;/b&gt; are available in wallet &lt;b style=&#34;color: #00909e;&#34;&gt;{payment[&#34;wallet&#34;].name}&lt;/b&gt;&lt;/h2&gt;
                Billing details:
                &lt;h4&gt; Wallet address: &lt;/h4&gt;  {escrow_address} \n
                &lt;h4&gt; Currency: &lt;/h4&gt;  {escrow_asset} \n
                &lt;h4&gt; Payment details: &lt;/h4&gt; {payment_details} \n
                &lt;h4&gt; Choose a wallet name to use for payment or proceed with payment through External Wallet (QR Code) &lt;/h4&gt;
                &#34;&#34;&#34;

    def wait_payment(self, bot, rid, threebot_app=False, reservation_create_resp=None):
        &#34;&#34;&#34;wait slide untill payment is ready

        Args:
            bot (GedisChatBot): bot instance
            rid (int): customer tid
            threebot_app (bool, optional): is using threebot app payment. Defaults to False.
            reservation_create_resp (jumpscale.clients.explorer.models.TfgridWorkloadsReservation1, optional): reservation object response. Defaults to None.
        &#34;&#34;&#34;

        # wait to check payment is actually done next_action changed from:PAY
        def is_expired(reservation):
            return reservation.data_reservation.expiration_provisioning.timestamp() &lt; j.data.time.get().timestamp

        reservation = self._explorer.reservations.get(rid)
        while True:
            remaning_time = j.data.time.get(reservation.data_reservation.expiration_provisioning).humanize(
                granularity=[&#34;minute&#34;, &#34;second&#34;]
            )
            deploying_message = f&#34;&#34;&#34;\
            # Payment being processed...

            &lt;br /&gt;Deployment will be cancelled if payment is not successful {remaning_time}
            &#34;&#34;&#34;
            bot.md_show_update(dedent(deploying_message), md=True)
            if reservation.next_action != &#34;PAY&#34;:
                return
            if is_expired(reservation):
                res = f&#34;# Failed to wait for payment for reservation:```{reservation.id}```:\n&#34;
                for x in reservation.results:
                    if x.state == &#34;ERROR&#34;:
                        res += f&#34;\n### {x.category}: ```{x.message}```\n&#34;
                link = f&#34;{self._explorer.url}/reservations/{reservation.id}&#34;
                res += f&#34;&lt;h2&gt; &lt;a href={link}&gt;Full reservation info&lt;/a&gt;&lt;/h2&gt;&#34;
                j.sals.zos.get().reservation_cancel(rid)
                bot.stop(res, md=True, html=True)
            if threebot_app and reservation_create_resp:
                self.show_escrow_qr(bot, reservation_create_resp, reservation.data_reservation.expiration_provisioning)
            time.sleep(5)
            reservation = self._explorer.reservations.get(rid)

    def _reservation_failed(self, bot, reservation):
        failed = j.sals.zos.get().reservation_failed(reservation)
        if failed:
            res = f&#34;# Sorry your reservation ```{reservation.id}``` has failed :\n&#34;
            for x in reservation.results:
                if x.state == &#34;ERROR&#34;:
                    res += f&#34;\n### {x.category}: ```{x.message}```\n&#34;
            link = f&#34;{self._explorer.url}/reservations/{reservation.id}&#34;
            res += f&#34;&lt;h2&gt; &lt;a href={link}&gt;Full reservation info&lt;/a&gt;&lt;/h2&gt;&#34;
            j.sals.zos.get().reservation_cancel(reservation.id)
            bot.stop(res, md=True, html=True)

    def wait_reservation(self, bot, rid):
        &#34;&#34;&#34;
        Wait for reservation results to be complete, have errors, or expire.
        If there are errors then error message is previewed in the chatflow to the user and the chat is ended.

        Args:
            bot (GedisChatBot): bot instance
            rid (int): user tid
        &#34;&#34;&#34;

        def is_finished(reservation):
            count = 0
            count += len(reservation.data_reservation.volumes)
            count += len(reservation.data_reservation.zdbs)
            count += len(reservation.data_reservation.containers)
            count += len(reservation.data_reservation.kubernetes)
            count += len(reservation.data_reservation.proxies)
            count += len(reservation.data_reservation.reverse_proxies)
            count += len(reservation.data_reservation.subdomains)
            count += len(reservation.data_reservation.domain_delegates)
            count += len(reservation.data_reservation.gateway4to6)
            for network in reservation.data_reservation.networks:
                count += len(network.network_resources)
            return len(reservation.results) &gt;= count

        def is_expired(reservation):
            &#34;&#34;&#34;[summary]

            Args:
                reservation (jumpscale.clients.explorer.models.TfgridWorkloadsReservation1): reservation object

            Returns:
                [bool]: True if the reservation is expired
            &#34;&#34;&#34;
            return reservation.data_reservation.expiration_provisioning.timestamp() &lt; j.data.time.get().timestamp

        reservation = self._explorer.reservations.get(rid)
        while True:
            remaning_time = j.data.time.get(reservation.data_reservation.expiration_provisioning).humanize(
                granularity=[&#34;minute&#34;, &#34;second&#34;]
            )
            deploying_message = f&#34;&#34;&#34;
            # Deploying...

            &lt;br /&gt;Deployment will be cancelled if it is not successful in {remaning_time}
            &#34;&#34;&#34;
            bot.md_show_update(dedent(deploying_message), md=True)
            self._reservation_failed(bot, reservation)

            if is_finished(reservation):
                if reservation.next_action != NextAction.DEPLOY:
                    res = f&#34;# Sorry your reservation ```{reservation.id}``` failed to deploy\n&#34;
                    for x in reservation.results:
                        if x.state == &#34;ERROR&#34;:
                            res += f&#34;\n### {x.category}: ```{x.message}```\n&#34;
                    bot.stop(res, md=True, html=True)
                return reservation.results
            if is_expired(reservation):
                res = f&#34;# Sorry your reservation ```{reservation.id}``` failed to deploy in time:\n&#34;
                for x in reservation.results:
                    if x.state == &#34;ERROR&#34;:
                        res += f&#34;\n### {x.category}: ```{x.message}```\n&#34;
                link = f&#34;{self._explorer.url}/reservations/{reservation.id}&#34;
                res += f&#34;&lt;h2&gt; &lt;a href={link}&gt;Full reservation info&lt;/a&gt;&lt;/h2&gt;&#34;
                j.sals.zos.get().reservation_cancel(rid)
                bot.stop(res, md=True, html=True)
            time.sleep(1)
            reservation = self._explorer.reservations.get(rid)

    def register_reservation(
        self, reservation, expiration, customer_tid, expiration_provisioning=1000, currency=None, bot=None
    ):
        &#34;&#34;&#34;Register any reservation through the chatflow.
        This reservation could include anything such as a new network, container, kubernetes cluster, or zdb.
        It returns the reservation id of the registered reservation.

        Args:
            reservation (jumpscale.clients.explorer.models.TfgridWorkloadsReservation1): reservation object
            expiration (int): epoch time when the reservation should be canceled automaticly
            customer_tid (int): Id of the customer making the reservation
            expiration_provisioning (int): timeout on the deployment of the provisioning in seconds
            currency (str): &#34;TFT&#34; of &#34;FreeTFT&#34;
            bot (GedisChatBot): bot instance

        Return:
            [jumpscale.clients.explorer.models.TfgridWorkloadsReservation1]: reservation create object

        &#34;&#34;&#34;
        expiration_provisioning += j.data.time.get().timestamp
        try:
            reservation_create = j.sals.zos.get().reservation_register(
                reservation,
                expiration,
                expiration_provisioning=expiration_provisioning,
                customer_tid=customer_tid,
                currencies=[currency],
            )
        except requests.HTTPError as e:
            try:
                msg = e.response.json()[&#34;error&#34;]
            except (KeyError, json.JSONDecodeError):
                msg = e.response.text
            raise StopChatFlow(f&#34;The following error occured: {msg}&#34;)

        rid = reservation_create.reservation_id
        reservation.id = rid

        # TODO: FIXME TO SET DEPLOYER in config
        if j.core.config.get_config().get(&#34;DEPLOYER&#34;) and customer_tid:
            # create a new object from deployed_reservation with the reservation and the tid
            explorer_name = self._explorer.url.split(&#34;.&#34;)[1]
            deployed_reservation = self.deployed_reservations.get(f&#34;{explorer_name}_{rid}&#34;)
            deployed_reservation.reservation_id = rid
            deployed_reservation.customer_tid = customer_tid
            deployed_reservation.save()
        return reservation_create

    def register_and_pay_reservation(
        self, reservation, expiration=None, customer_tid=None, currency=None, bot=None, wallet=None
    ):
        &#34;&#34;&#34;register the reservation, pay and deploy

        Args:
            reservation (jumpscale.clients.explorer.models.TfgridWorkloadsReservation1): reservation object
            expiration (int): epoch time when the reservation should be canceled automaticly
            customer_tid (int): Id of the customer making the reservation
            currency (str): &#34;TFT&#34; of &#34;FreeTFT&#34;
            bot (GedisChatBot): bot instance
            wallet (TfgridDirectoryWallet_address1): wallet object. Defaults to None.

        Returns:
            [int]: reservation id
        &#34;&#34;&#34;

        payment_obj = None
        if customer_tid and expiration and currency:
            reservation_create = self.register_reservation(
                reservation, expiration, customer_tid=customer_tid, currency=currency, bot=bot
            )
        else:
            reservation_create = reservation
        if not wallet:
            payment, payment_obj = self.show_payments(bot, reservation_create, currency)
        else:
            payment = {&#34;wallet&#34;: None, &#34;free&#34;: False}
            if not (reservation_create.escrow_information and reservation_create.escrow_information.details):
                payment[&#34;free&#34;] = True
            else:
                payment[&#34;wallet&#34;] = wallet

        resv_id = reservation_create.reservation_id
        if payment[&#34;wallet&#34;]:
            j.sals.zos.get().billing.payout_farmers(payment[&#34;wallet&#34;], reservation_create)
            self.wait_payment(bot, resv_id, threebot_app=False)
        elif not payment[&#34;free&#34;]:
            self.wait_payment(bot, resv_id, threebot_app=True, reservation_create_resp=reservation_create)

        self.wait_reservation(bot, resv_id)
        if payment_obj:
            payment_obj.save()
        return resv_id

    def get_kube_network_ip(self, reservation_data):
        &#34;&#34;&#34;get kubernetes reservation network id

        Args:
            reservation_data (jumpscale.clients.explorer.models.TfgridWorkloadsReservation1.reservation_data): reservation data object

        Returns:
            [str, str]: network_id, ip
        &#34;&#34;&#34;
        network_id = reservation_data[&#34;kubernetes&#34;][0][&#34;network_id&#34;]
        ip = reservation_data[&#34;kubernetes&#34;][0][&#34;ipaddress&#34;]
        return network_id, ip

    def list_gateways(self, bot, currency=None):
        &#34;&#34;&#34;list available gateways that supports passed currency

        Args:
            bot (GedisChatBot): bot instance
            currency (str, optional): &#34;TFT&#34; or &#34;FreeTFT&#34;. Defaults to None.

        Returns:
            [dict]
        &#34;&#34;&#34;
        unknowns = [&#34;&#34;, None, &#34;Uknown&#34;, &#34;Unknown&#34;]
        gateways = {}
        farms = {}
        for g in j.sals.zos.get()._explorer.gateway.list():
            if not j.sals.zos.get().nodes_finder.filter_is_up(g):
                continue
            location = []
            for area in [&#34;continent&#34;, &#34;country&#34;, &#34;city&#34;]:
                areaname = getattr(g.location, area)
                if areaname not in unknowns:
                    location.append(areaname)
            currencies = list()

            farm_id = g.farm_id
            if farm_id not in farms:
                farms[farm_id] = j.sals.zos.get()._explorer.farms.get(farm_id)

            addresses = farms[farm_id].wallet_addresses
            for address in addresses:
                if address.asset not in currencies:
                    if address.asset == &#34;FreeTFT&#34; and not g.free_to_use:
                        continue
                    currencies.append(address.asset)

            reservation_currency = &#34;, &#34;.join(currencies)

            if currency and currency not in currencies:
                continue
            gtext = f&#34;{&#39; - &#39;.join(location)} ({reservation_currency}) ID: {g.node_id}&#34;
            gateways[gtext] = g
        return gateways

    def select_gateway(self, bot, currency=None):
        &#34;&#34;&#34;prompt user about available gateways that supports passed currency

        Args:
            bot (GedisChatBot): bot instance
            currency (str, optional): &#34;TFT&#34; or &#34;FreeTFT&#34;. Defaults to None.

        Returns:
            [TfgridDirectoryGateway1]
        &#34;&#34;&#34;
        gateways = self.list_gateways(bot, currency)
        if not gateways:
            bot.stop(&#34;No available gateways&#34;)
        options = sorted(list(gateways.keys()))
        gateway = bot.drop_down_choice(&#34;Please choose a gateway&#34;, options, required=True)
        return gateways[gateway]

    def list_delegate_domains(self, customer_tid, currency=None):
        &#34;&#34;&#34;list delegated domains with passed currency

        Args:
            customer_tid (int): user tid
            currency (str, optional): currency to search with. Defaults to None.

        Returns:
            [dict]: [domains names]
        &#34;&#34;&#34;
        reservations = j.sals.zos.get().reservation_list(tid=customer_tid, next_action=&#34;DEPLOY&#34;)
        domains = dict()
        names = set()
        for reservation in sorted(reservations, key=lambda r: r.id, reverse=True):
            reservation_currency = self.get_currency(reservation)
            if reservation.next_action != NextAction.DEPLOY:
                continue
            rdomains = reservation.data_reservation.domain_delegates
            if currency and currency != reservation_currency:
                continue
            for dom in rdomains:
                if dom.domain in names:
                    continue
                names.add(dom.domain)
                domains[dom.domain] = dom
        return domains

    def get_network(self, bot, customer_tid, name):
        &#34;&#34;&#34;get the network object

        Args:
            bot (GedisChatBot): bot instance
            customer_tid (int): user tid
            name (str): [network name]

        Returns:
            [jumpscale.clients.explorer.models.TfgridWorkloadsReservationNetwork1]: nework object
        &#34;&#34;&#34;
        reservations = j.sals.zos.get().reservation_list(tid=customer_tid, next_action=&#34;DEPLOY&#34;)
        networks = self.list_networks(customer_tid, reservations)
        for key in networks.keys():
            network, expiration, currency, resv_id = networks[key]
            if network.name == name:
                return Network(network, expiration, bot, reservations, currency, resv_id)

    def list_networks(self, tid, reservations=None):
        &#34;&#34;&#34;list all available networks from reservations

        Args:
            tid (int): user tid
            reservation (list of jumpscale.clients.explorer.models.TfgridWorkloadsReservation1): list of reservation objects

        Returns:
            [type]: [description]
        &#34;&#34;&#34;
        if not reservations:
            reservations = j.sals.zos.get().reservation_list(tid=tid, next_action=&#34;DEPLOY&#34;)
        networks = dict()
        names = set()
        for reservation in sorted(reservations, key=lambda r: r.id, reverse=True):
            if reservation.next_action != NextAction.DEPLOY:
                continue
            rnetworks = reservation.data_reservation.networks
            expiration = reservation.data_reservation.expiration_reservation
            currency = self.get_currency(reservation)
            for network in rnetworks:
                if network.name in names:
                    continue
                names.add(network.name)
                remaining = j.data.time.get(expiration).humanize()

                network_name = network.name + f&#34; ({currency}) - ends &#34; + remaining
                networks[network_name] = (network, expiration, currency, reservation.id)

        return networks

    def get_currency(self, reservation):
        &#34;&#34;&#34;get reservation currency

        Args:
            reservation (jumpscale.clients.explorer.models.TfgridWorkloadsReservation1): reservation object

        Returns:
            [str]
        &#34;&#34;&#34;
        currencies = reservation.data_reservation.currencies
        if currencies:
            return currencies[0]
        elif reservation.data_reservation.networks and reservation.data_reservation.networks[0].network_resources:
            node_id = reservation.data_reservation.networks[0].network_resources[0].node_id
            if self._explorer.nodes.get(node_id).free_to_use:
                return &#34;FreeTFT&#34;

        return &#34;TFT&#34;

    def cancel_solution_reservation(self, solution_type, solution_name):
        &#34;&#34;&#34;cancel solution reservation

        Args:
            solution_type (str): solution_type
            solution_name (str): solution name
        &#34;&#34;&#34;
        for name in self.solutions.list_all():
            solution = self.solutions.get(name)
            if solution.name == solution_name and solution.solution_type == solution_type:
                # Cancel all parent networks if solution type is network
                if solution.solution_type == SolutionType.Network:  ## TODO change to SolutionType.Network.value
                    curr_network_resv = self._explorer.reservations.get(solution.rid)
                    while curr_network_resv:
                        if curr_network_resv.metadata:
                            try:
                                network_metadata = self.decrypt_reservation_metadata(curr_network_resv.metadata)
                                network_metadata = json.loads(network_metadata)
                            except Exception:
                                break
                            if &#34;parent_network&#34; in network_metadata:
                                parent_resv = self._explorer.reservations.get(network_metadata[&#34;parent_network&#34;])
                                j.sals.zos.get().reservation_cancel(parent_resv.id)
                                curr_network_resv = parent_resv
                                continue
                        curr_network_resv = None

                j.sals.zos.get().reservation_cancel(solution.rid)
                self.solutions.delete(name)

    def get_solutions(self, solution_type):
        &#34;&#34;&#34;get deployed solutions from specified type

        Args:
            solution_type (str): solution type

        Returns:
            [list]: list of reservations objects
        &#34;&#34;&#34;
        reservations = []
        for name in self.solutions.list_all():
            solution = self.solutions.get(name)
            if solution.solution_type != solution_type:
                continue
            if solution.explorer and solution.explorer != self._explorer.url:
                continue
            reservation = self._explorer.reservations.get(solution.rid)
            reservations.append(
                {
                    &#34;name&#34;: solution.name,
                    &#34;reservation&#34;: reservation._get_data(),
                    &#34;type&#34;: solution_type.value,
                    &#34;form_info&#34;: json.dumps(solution.form_info),
                }
            )
        return reservations

    def add_reservation_metadata(self, reservation, metadata):
        &#34;&#34;&#34;add the encrypted metadata to reservation object

        Args:
            reservation (jumpscale.clients.explorer.models.TfgridWorkloadsReservation1): reservation object
            metadata (dict): reservation metadata

        Returns:
            reservation (jumpscale.clients.explorer.models.TfgridWorkloadsReservation1): reservation with metadata
        &#34;&#34;&#34;
        meta_json = json.dumps(metadata)

        pk = j.core.identity.me.nacl.signing_key.verify_key.to_curve25519_public_key()
        sk = j.core.identity.me.nacl.signing_key.to_curve25519_private_key()
        box = Box(sk, pk)
        encrypted_metadata = base64.b85encode(box.encrypt(meta_json.encode())).decode()
        reservation.metadata = encrypted_metadata
        return reservation

    def get_solution_metadata(self, solution_name, solution_type, form_info=None):
        &#34;&#34;&#34;get metadata from a solution

        Args:
            solution_name (str): solution name
            solution_type (str): solution type
            form_info (dict, optional): info from user slide. Defaults to None.

        Returns:
            dict: metadata
        &#34;&#34;&#34;
        form_info = form_info or {}
        reservation = {}
        reservation[&#34;name&#34;] = solution_name
        reservation[&#34;form_info&#34;] = form_info
        reservation[&#34;solution_type&#34;] = solution_type.value
        reservation[&#34;explorer&#34;] = self._explorer.url
        return reservation

    def create_network(
        self,
        network_name,
        reservation,
        ip_range,
        customer_tid,
        ip_version,
        access_node,
        expiration=None,
        currency=None,
        bot=None,
    ):
        &#34;&#34;&#34;create network to deploy reservation on

        Args:
            network_name (str): network name
            reservation (jumpscale.clients.explorer.models.TfgridWorkloadsReservation1): reservation object
            ip_range (IPRange): selected ip range eg: &#34;10.70.0.0/16&#34;
            customer_tid (int): user tid
            ip_version (str): &#34;IPv4&#34; or &#34;IPv6&#34;
            expiration (int, optional): epoch for expiration time. Defaults to None.
            currency (str, optional): wanted currency . Defaults to None.
            bot (GedisChatBot, optional): bot instance. Defaults to None.

        Raises:
            StopChatFlow: when no available node

        Returns:
            [dict]: network config
        &#34;&#34;&#34;

        network = j.sals.zos.get().network.create(reservation, ip_range, network_name)
        node_subnets = netaddr.IPNetwork(ip_range).subnet(24)
        network_config = dict()
        use_ipv4 = ip_version == &#34;IPv4&#34;

        j.sals.zos.get().network.add_node(network, access_node.node_id, str(next(node_subnets)))
        wg_quick = j.sals.zos.get().network.add_access(
            network, access_node.node_id, str(next(node_subnets)), ipv4=use_ipv4
        )

        network_config[&#34;wg&#34;] = wg_quick

        j.sals.fs.mkdir(f&#34;{j.core.dirs.CFGDIR}/wireguard/&#34;)
        j.sals.fs.write_file(f&#34;{j.core.dirs.CFGDIR}/wireguard/{network_name}.conf&#34;, f&#34;{wg_quick}&#34;)

        # register the reservation
        expiration = expiration or j.data.time.get().timestamp + (60 * 60 * 24)
        reservation_create = self.register_reservation(
            reservation, expiration, customer_tid, currency=currency, bot=bot
        )

        network_config[&#34;rid&#34;] = reservation_create.reservation_id
        network_config[&#34;reservation_create&#34;] = reservation_create

        return network_config

    def get_ip_range(self, bot):
        &#34;&#34;&#34;prompt user to select iprange

        Args:
            bot (GedisChatBot): bot instance

        Returns:
            [IPRange]: ip selected by user
        &#34;&#34;&#34;
        ip_range_choose = [&#34;Configure IP range myself&#34;, &#34;Choose IP range for me&#34;]
        iprange_user_choice = bot.single_choice(
            &#34;To have access to the 3Bot, the network must be configured&#34;,
            ip_range_choose,
            required=True,
            default=ip_range_choose[1],
        )
        if iprange_user_choice == &#34;Configure IP range myself&#34;:
            ip_range = bot.string_ask(&#34;Please add private IP Range of the network&#34;)
        else:
            first_digit = random.choice([172, 10])
            if first_digit == 10:
                second_digit = random.randint(0, 255)
            else:
                second_digit = random.randint(16, 31)
            ip_range = str(first_digit) + &#34;.&#34; + str(second_digit) + &#34;.0.0/16&#34;
        return ip_range

    def select_farms(self, bot, message=None, currency=None, retry=False, sru=None, cru=None, hru=None, mru=None):
        &#34;&#34;&#34;prompt user to select farm to deploy on

        Args:
            bot (GedisChatBot): bot instance
            message (str, optional): bot screen message. Defaults to None.
            currency (str, optional): wanted currency to deal with. Defaults to None.
            retry (bool, optional): retry if failed. Defaults to False.

        Returns:
            farm object
        &#34;&#34;&#34;
        message = message or &#34;Select 1 or more farms to distribute nodes on&#34;
        farms = self._explorer.farms.list()
        farm_names = []
        for f in farms:
            if j.sals.zos.get().nodes_finder.filter_farm_currency(f, currency) and self.check_farm_resources(
                farm_id=f.id, sru=sru, cru=cru, hru=hru, mru=mru, currency=currency
            ):
                farm_names.append(f.name)
        if not farm_names:
            bot.stop(&#34;No farms with available resources that match the specified.&#34;)
        farms_selected = bot.multi_list_choice(message, farm_names, retry=retry, auto_complete=True)
        return farms_selected

    def check_farm_resources(self, farm_id, sru=None, mru=None, hru=None, cru=None, currency=None):
        farm_nodes = self._explorer.nodes.list(farm_id=farm_id)
        nodes = []
        for node in farm_nodes:
            if not j.sals.zos.get().nodes_finder.filter_is_up(node):
                continue
            if currency == &#34;FreeTFT&#34; and not node.free_to_use:
                continue
            if sru:
                available_sru = node.total_resources.sru - node.reserved_resources.sru
                if sru &gt; available_sru:
                    continue
            if cru:
                available_cru = node.total_resources.cru - node.reserved_resources.cru
                if cru &gt; available_cru:
                    continue
            if hru:
                available_hru = node.total_resources.hru - node.reserved_resources.hru
                if hru &gt; available_hru:
                    continue
            if mru:
                available_mru = node.total_resources.mru - node.reserved_resources.mru
                if mru &gt; available_mru:
                    continue
            nodes.append(node)
        return nodes

    def select_network(self, bot, customer_tid):
        &#34;&#34;&#34;prompt user to select a specific network

        Args:
            bot (GedisChatBot): bot instance
            customer_tid (int): user tid

        Returns:
            Network object
        &#34;&#34;&#34;
        reservations = j.sals.zos.get().reservation_list(tid=customer_tid, next_action=&#34;DEPLOY&#34;)
        networks = self.list_networks(customer_tid, reservations)
        names = []
        for n in networks.keys():
            names.append(n)
        if not names:
            res = &#34;You don&#39;t have any networks, please use the network chatflow to create one&#34;
            res = j.tools.jinja2.render_template(template_text=res)
            bot.stop(res)
        while True:
            result = bot.single_choice(&#34;Choose a network&#34;, names, required=True)
            if result not in networks:
                continue
            network, expiration, currency, resv_id = networks[result]
            return Network(network, expiration, bot, reservations, currency, resv_id)

    def validate_node(self, nodeid, query=None, currency=None):
        &#34;&#34;&#34;validate the node if it&#39;s ok to use and have enough resources

        Args:
            nodeid (str): node id
            query (dict, optional): search paramas. Defaults to None.
            currency (str, optional): wanted currency. Defaults to None.

        Returns:
            Node object
        &#34;&#34;&#34;
        try:
            node = self._explorer.nodes.get(nodeid)
        except requests.exceptions.HTTPError:
            raise j.exceptions.NotFound(f&#34;Node {nodeid} doesn&#39;t exists please enter a valid nodeid&#34;)
        if not j.sals.zos.get().nodes_finder.filter_is_up(node):
            raise j.exceptions.NotFound(f&#34;Node {nodeid} doesn&#39;t seem to be up please choose another nodeid&#34;)

        if currency:
            if currency == &#34;FreeTFT&#34; and not node.free_to_use:
                raise j.exceptions.Value(
                    f&#34;The specified node ({nodeid}) should support the same type of currency as the network you are using ({currency})&#34;
                )
        if query:
            for unit, value in query.items():
                if unit == &#34;currency&#34;:
                    continue
                freevalue = getattr(node.total_resources, unit) - getattr(node.used_resources, unit)
                if freevalue &lt; value:
                    raise j.exceptions.Value(
                        f&#34;Node {nodeid} does not have enough available {unit} resources for this request {value} required {freevalue} available, please choose another one&#34;
                    )
        return node

    def get_nodes(
        self,
        number_of_nodes,
        cru=None,
        sru=None,
        mru=None,
        hru=None,
        currency=&#34;TFT&#34;,
        ip_version=None,
        pool_ids=None,
        filter_blocked=True,
    ):
        &#34;&#34;&#34;get available nodes to deploy solutions on

        Args:
            number_of_nodes (int): required nodes count
            farm_id (int, optional): id for farm to search with. Defaults to None.
            farm_names (list, optional): farms to search in. Defaults to None.
            cru (int, optional): cpu resource. Defaults to None.
            sru (int, optional): ssd resource. Defaults to None.
            mru (int, optional): memory resource. Defaults to None.
            hru (int, optional): hdd resources. Defaults to None.
            currency (str, optional): wanted currency. Defaults to &#34;TFT&#34;.

        Raises:
            StopChatFlow: if no nodes found

        Returns:
            list of available nodes
        &#34;&#34;&#34;

        def filter_disallowed_nodes(disallowed_node_ids, nodes):
            result = []
            for node in nodes:
                if node.node_id not in disallowed_node_ids:
                    result.append(node)
            return result

        disallowed_node_ids = []
        if filter_blocked:
            disallowed_node_ids = self.list_blocked_nodes().keys()
        if j.config.get(&#34;OVER_PROVISIONING&#34;):
            cru = 0
            mru = 0
        nodes_distribution = self._distribute_nodes(number_of_nodes, pool_ids=pool_ids)
        # to avoid using the same node with different networks
        nodes_selected = []
        selected_ids = []
        for pool_id in nodes_distribution:
            nodes_number = nodes_distribution[pool_id]
            if not pool_ids:
                pool_id = None
            nodes = j.sals.zos.get().nodes_finder.nodes_by_capacity(
                cru=cru, sru=sru, mru=mru, hru=hru, currency=currency, pool_id=pool_id
            )
            nodes = filter_disallowed_nodes(disallowed_node_ids, nodes)
            nodes = self.filter_nodes(nodes, currency == &#34;FreeTFT&#34;, ip_version=ip_version)
            for i in range(nodes_number):
                try:
                    node = random.choice(nodes)
                    while node.node_id in selected_ids:
                        node = random.choice(nodes)
                except IndexError:
                    raise StopChatFlow(
                        &#34;Failed to find resources for this reservation. If you are using a low resources environment like testnet, please make sure to allow over provisioning from the settings tab in dashboard. For more info visit &lt;a href=&#39;https://manual2.threefold.io/#/3bot_settings?id=developers-options&#39;&gt;our manual&lt;/a&gt;&#34;,
                        htmlAlert=True,
                    )
                nodes.remove(node)
                nodes_selected.append(node)
                selected_ids.append(node.node_id)
        return nodes_selected

    def filter_nodes(self, nodes, free_to_use, ip_version=None):
        &#34;&#34;&#34;filter nodes by free to use flag

        Args:
            nodes (list of nodes objects)
            free_to_use (bool)

        Returns:
            list of filtered nodes
        &#34;&#34;&#34;
        nodes = filter(j.sals.zos.get().nodes_finder.filter_is_up, nodes)
        nodes = list(nodes)
        if free_to_use:
            nodes = list(nodes)
            nodes = filter(j.sals.zos.get().nodes_finder.filter_is_free_to_use, nodes)
        elif not free_to_use:
            nodes = list(nodes)

        if ip_version:
            use_ipv4 = ip_version == &#34;IPv4&#34;

            if use_ipv4:
                nodefilter = j.sals.zos.get().nodes_finder.filter_public_ip4
            else:
                nodefilter = j.sals.zos.get().nodes_finder.filter_public_ip6

            nodes = filter(j.sals.zos.get().nodes_finder.filter_is_up, filter(nodefilter, nodes))
            if not nodes:
                raise StopChatFlow(&#34;Could not find available access node&#34;)
        return list(nodes)

    def _distribute_nodes(self, number_of_nodes, pool_ids):
        nodes_distribution = {}
        nodes_left = number_of_nodes
        result_ids = list(pool_ids) if pool_ids else []
        if not pool_ids:
            pools = self._explorer.pools.list()
            result_ids = []
            for p in pools:
                result_ids.append(p.pool_id)
        random.shuffle(result_ids)
        id_pointer = 0
        while nodes_left:
            pool_id = result_ids[id_pointer]
            if pool_id not in nodes_distribution:
                nodes_distribution[pool_id] = 0
            nodes_distribution[pool_id] += 1
            nodes_left -= 1
            id_pointer += 1
            if id_pointer == len(result_ids):
                id_pointer = 0
        return nodes_distribution

    def get_farm_names(self, number_of_nodes, bot, cru=None, sru=None, mru=None, hru=None, currency=&#34;TFT&#34;, message=&#34;&#34;):
        &#34;&#34;&#34;get list with available farm names and prompt user to choose one

        Args:
            number_of_nodes (int): required nodes count
            farm_id (int, optional): id for farm to search with. Defaults to None.
            farm_names (list, optional): farms to search in. Defaults to None.
            cru (int, optional): cpu resource. Defaults to None.
            sru (int, optional): ssd resource. Defaults to None.
            mru (int, optional): memory resource. Defaults to None.
            hru (int, optional): hdd resources. Defaults to None.
            currency (str, optional): wanted currency. Defaults to &#34;TFT&#34;.
            message (str): message to user. Defaults to &#34;&#34;

        &#34;&#34;&#34;
        farms_message = f&#34;Select 1 or more farms to distribute the {message} nodes on. If no selection is made, the farms will be chosen randomly&#34;
        empty_farms = set()
        all_farms = self._explorer.farms.list()
        retry = False
        while True:
            farms = self.select_farms(
                bot, farms_message, currency=currency, retry=retry, cru=cru, sru=sru, hru=hru, mru=mru
            )
            farms_with_no_resources = self.check_farms(
                1, farm_names=farms, cru=cru, sru=sru, mru=mru, hru=hru, currency=currency
            )
            if not farms_with_no_resources:
                return farms
            for farm_name in farms_with_no_resources:
                empty_farms.add(farm_name)
            if len(all_farms) == len(empty_farms):
                raise StopChatFlow(&#34;No Farms available containing nodes that match the required resources&#34;)
            if message:
                message = f&#34;for {message}&#34;
            retry = True
            resources_of_farm = &#34;&#34;
            if cru:
                resources_of_farm += f&#34; cru={cru}/&#34;
            if sru:
                resources_of_farm += f&#34; sru={sru}/&#34;
            if mru:
                resources_of_farm += f&#34; mru={mru}/&#34;
            if hru:
                resources_of_farm += f&#34; hru={hru}/&#34;
            if currency:
                resources_of_farm += f&#34; and the currency={currency}&#34;
            farms_message = (
                f&#34;&#34;&#34;The following farms don&#39;t meet the criteria of having {resources_of_farm} {message}: &#34;&#34;&#34;
                + &#34;, &#34;.join(farms_with_no_resources)
                + &#34;&#34;&#34;.
                Please reselect farms to check for resources or leave it empty
                &#34;&#34;&#34;
            )

    def check_farms(
        self, number_of_nodes, farm_id=None, farm_names=None, cru=None, sru=None, mru=None, hru=None, currency=&#34;TFT&#34;
    ):
        &#34;&#34;&#34;get list with available farm and make sure it has resources

        Args:
            number_of_nodes (int): required nodes count
            farm_id (int, optional): id for farm to search with. Defaults to None.
            farm_names (list, optional): farms to search in. Defaults to None.
            cru (int, optional): cpu resource. Defaults to None.
            sru (int, optional): ssd resource. Defaults to None.
            mru (int, optional): memory resource. Defaults to None.
            hru (int, optional): hdd resources. Defaults to None.
            currency (str, optional): wanted currency. Defaults to &#34;TFT&#34;.
            message (str): message to user. Defaults to &#34;&#34;

        Returns:
            list of available farm objects
        &#34;&#34;&#34;
        if not farm_names:
            return []
        farms_with_no_resources = []
        nodes_distribution = self._distribute_nodes(number_of_nodes, farm_names)
        for farm_name in nodes_distribution:
            nodes_number = nodes_distribution[farm_name]
            nodes = j.sals.zos.get().nodes_finder.nodes_by_capacity(
                farm_name=farm_name, cru=cru, sru=sru, mru=mru, hru=hru, currency=currency
            )
            nodes = self.filter_nodes(nodes, currency == &#34;FreeTFT&#34;)
            if nodes_number &gt; len(nodes):
                farms_with_no_resources.append(farm_name)
        return list(farms_with_no_resources)

    def validate_user(self, user_info):
        &#34;&#34;&#34;validate user information data to authentication

        Args:
            user_info (dict): user information
        &#34;&#34;&#34;
        if not j.core.config.get_config().get(&#34;threebot_connect&#34;, True):
            error_msg = &#34;&#34;&#34;
            This chatflow is not supported when 3Bot is in dev mode.
            To enable 3Bot connect : `j.core.config.set(&#39;threebot_connect&#39;, True)`
            &#34;&#34;&#34;
            raise j.exceptions.Runtime(error_msg)
        if not user_info[&#34;email&#34;]:
            raise j.exceptions.Value(&#34;Email shouldn&#39;t be empty&#34;)
        if not user_info[&#34;username&#34;]:
            raise j.exceptions.Value(&#34;Name of logged in user shouldn&#39;t be empty&#34;)
        return self._explorer.users.get(name=user_info[&#34;username&#34;], email=user_info[&#34;email&#34;])

    def block_node(self, node_id):
        count = j.core.db.hincrby(NODES_COUNT_KEY, node_id)
        expiration = count * NODES_DISALLOW_EXPIRATION
        node_key = f&#34;{NODES_DISALLOW_PREFIX}:{node_id}&#34;
        j.core.db.set(node_key, expiration, ex=expiration)

    def unblock_node(self, node_id, reset=True):
        node_key = f&#34;{NODES_DISALLOW_PREFIX}:{node_id}&#34;
        j.core.db.delete(node_key)
        if reset:
            j.core.db.hdel(NODES_COUNT_KEY, node_id)

    def list_blocked_nodes(self):
        &#34;&#34;&#34;
        each blocked node is stored in a key with a prefix ZOS:NODES:DISALLOWED:{node_id} and its value is the expiration period for it.
        number of failure count is defined in hash with key ZOS:NODES:FAILURE_COUNT. the hash keys are node_ids and values are count of how many times the node has been blocked

        returns
            dict: {node_id: {expiration: .., failure_count: ...}}
        &#34;&#34;&#34;
        blocked_node_keys = j.core.db.keys(f&#34;{NODES_DISALLOW_PREFIX}:*&#34;)
        failure_count_dict = j.core.db.hgetall(NODES_COUNT_KEY)
        blocked_node_values = j.core.db.mget(blocked_node_keys)
        result = {}
        for idx, key in enumerate(blocked_node_keys):
            key = key[len(NODES_DISALLOW_PREFIX) + 1 :]
            node_id = key.decode()
            expiration = int(blocked_node_values[idx])
            failure_count = int(failure_count_dict[key])
            result[node_id] = {&#34;expiration&#34;: expiration, &#34;failure_count&#34;: failure_count}
        return result

    def clear_blocked_nodes(self):
        blocked_node_keys = j.core.db.keys(f&#34;{NODES_DISALLOW_PREFIX}:*&#34;)
        if blocked_node_keys:
            j.core.db.delete(*blocked_node_keys)
        j.core.db.delete(NODES_COUNT_KEY)</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="jumpscale.sals.reservation_chatflow.reservation_chatflow.ReservationChatflow.me"><code class="name">var <span class="ident">me</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@property
def me(self):
    return j.core.identity.me</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="jumpscale.sals.reservation_chatflow.reservation_chatflow.ReservationChatflow.add_reservation_metadata"><code class="name flex">
<span>def <span class="ident">add_reservation_metadata</span></span>(<span>self, reservation, metadata)</span>
</code></dt>
<dd>
<section class="desc"><p>add the encrypted metadata to reservation object</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>reservation</code></strong> :&ensp;<code>jumpscale.clients.explorer.models.TfgridWorkloadsReservation1</code></dt>
<dd>reservation object</dd>
<dt><strong><code>metadata</code></strong> :&ensp;<code>dict</code></dt>
<dd>reservation metadata</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>reservation</code></strong> :&ensp;<code>jumpscale.clients.explorer.models.TfgridWorkloadsReservation1</code></dt>
<dd>reservation with metadata</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def add_reservation_metadata(self, reservation, metadata):
    &#34;&#34;&#34;add the encrypted metadata to reservation object

    Args:
        reservation (jumpscale.clients.explorer.models.TfgridWorkloadsReservation1): reservation object
        metadata (dict): reservation metadata

    Returns:
        reservation (jumpscale.clients.explorer.models.TfgridWorkloadsReservation1): reservation with metadata
    &#34;&#34;&#34;
    meta_json = json.dumps(metadata)

    pk = j.core.identity.me.nacl.signing_key.verify_key.to_curve25519_public_key()
    sk = j.core.identity.me.nacl.signing_key.to_curve25519_private_key()
    box = Box(sk, pk)
    encrypted_metadata = base64.b85encode(box.encrypt(meta_json.encode())).decode()
    reservation.metadata = encrypted_metadata
    return reservation</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.reservation_chatflow.reservation_chatflow.ReservationChatflow.block_node"><code class="name flex">
<span>def <span class="ident">block_node</span></span>(<span>self, node_id)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def block_node(self, node_id):
    count = j.core.db.hincrby(NODES_COUNT_KEY, node_id)
    expiration = count * NODES_DISALLOW_EXPIRATION
    node_key = f&#34;{NODES_DISALLOW_PREFIX}:{node_id}&#34;
    j.core.db.set(node_key, expiration, ex=expiration)</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.reservation_chatflow.reservation_chatflow.ReservationChatflow.cancel_solution_reservation"><code class="name flex">
<span>def <span class="ident">cancel_solution_reservation</span></span>(<span>self, solution_type, solution_name)</span>
</code></dt>
<dd>
<section class="desc"><p>cancel solution reservation</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>solution_type</code></strong> :&ensp;<code>str</code></dt>
<dd>solution_type</dd>
<dt><strong><code>solution_name</code></strong> :&ensp;<code>str</code></dt>
<dd>solution name</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def cancel_solution_reservation(self, solution_type, solution_name):
    &#34;&#34;&#34;cancel solution reservation

    Args:
        solution_type (str): solution_type
        solution_name (str): solution name
    &#34;&#34;&#34;
    for name in self.solutions.list_all():
        solution = self.solutions.get(name)
        if solution.name == solution_name and solution.solution_type == solution_type:
            # Cancel all parent networks if solution type is network
            if solution.solution_type == SolutionType.Network:  ## TODO change to SolutionType.Network.value
                curr_network_resv = self._explorer.reservations.get(solution.rid)
                while curr_network_resv:
                    if curr_network_resv.metadata:
                        try:
                            network_metadata = self.decrypt_reservation_metadata(curr_network_resv.metadata)
                            network_metadata = json.loads(network_metadata)
                        except Exception:
                            break
                        if &#34;parent_network&#34; in network_metadata:
                            parent_resv = self._explorer.reservations.get(network_metadata[&#34;parent_network&#34;])
                            j.sals.zos.get().reservation_cancel(parent_resv.id)
                            curr_network_resv = parent_resv
                            continue
                    curr_network_resv = None

            j.sals.zos.get().reservation_cancel(solution.rid)
            self.solutions.delete(name)</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.reservation_chatflow.reservation_chatflow.ReservationChatflow.check_farm_resources"><code class="name flex">
<span>def <span class="ident">check_farm_resources</span></span>(<span>self, farm_id, sru=None, mru=None, hru=None, cru=None, currency=None)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def check_farm_resources(self, farm_id, sru=None, mru=None, hru=None, cru=None, currency=None):
    farm_nodes = self._explorer.nodes.list(farm_id=farm_id)
    nodes = []
    for node in farm_nodes:
        if not j.sals.zos.get().nodes_finder.filter_is_up(node):
            continue
        if currency == &#34;FreeTFT&#34; and not node.free_to_use:
            continue
        if sru:
            available_sru = node.total_resources.sru - node.reserved_resources.sru
            if sru &gt; available_sru:
                continue
        if cru:
            available_cru = node.total_resources.cru - node.reserved_resources.cru
            if cru &gt; available_cru:
                continue
        if hru:
            available_hru = node.total_resources.hru - node.reserved_resources.hru
            if hru &gt; available_hru:
                continue
        if mru:
            available_mru = node.total_resources.mru - node.reserved_resources.mru
            if mru &gt; available_mru:
                continue
        nodes.append(node)
    return nodes</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.reservation_chatflow.reservation_chatflow.ReservationChatflow.check_farms"><code class="name flex">
<span>def <span class="ident">check_farms</span></span>(<span>self, number_of_nodes, farm_id=None, farm_names=None, cru=None, sru=None, mru=None, hru=None, currency=&#39;TFT&#39;)</span>
</code></dt>
<dd>
<section class="desc"><p>get list with available farm and make sure it has resources</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>number_of_nodes</code></strong> :&ensp;<code>int</code></dt>
<dd>required nodes count</dd>
<dt><strong><code>farm_id</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>id for farm to search with. Defaults to None.</dd>
<dt><strong><code>farm_names</code></strong> :&ensp;<code>list</code>, optional</dt>
<dd>farms to search in. Defaults to None.</dd>
<dt><strong><code>cru</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>cpu resource. Defaults to None.</dd>
<dt><strong><code>sru</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>ssd resource. Defaults to None.</dd>
<dt><strong><code>mru</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>memory resource. Defaults to None.</dd>
<dt><strong><code>hru</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>hdd resources. Defaults to None.</dd>
<dt><strong><code>currency</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>wanted currency. Defaults to "TFT".</dd>
<dt><strong><code>message</code></strong> :&ensp;<code>str</code></dt>
<dd>message to user. Defaults to ""</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list</code> of <code>available</code> <code>farm</code> <code>objects</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def check_farms(
    self, number_of_nodes, farm_id=None, farm_names=None, cru=None, sru=None, mru=None, hru=None, currency=&#34;TFT&#34;
):
    &#34;&#34;&#34;get list with available farm and make sure it has resources

    Args:
        number_of_nodes (int): required nodes count
        farm_id (int, optional): id for farm to search with. Defaults to None.
        farm_names (list, optional): farms to search in. Defaults to None.
        cru (int, optional): cpu resource. Defaults to None.
        sru (int, optional): ssd resource. Defaults to None.
        mru (int, optional): memory resource. Defaults to None.
        hru (int, optional): hdd resources. Defaults to None.
        currency (str, optional): wanted currency. Defaults to &#34;TFT&#34;.
        message (str): message to user. Defaults to &#34;&#34;

    Returns:
        list of available farm objects
    &#34;&#34;&#34;
    if not farm_names:
        return []
    farms_with_no_resources = []
    nodes_distribution = self._distribute_nodes(number_of_nodes, farm_names)
    for farm_name in nodes_distribution:
        nodes_number = nodes_distribution[farm_name]
        nodes = j.sals.zos.get().nodes_finder.nodes_by_capacity(
            farm_name=farm_name, cru=cru, sru=sru, mru=mru, hru=hru, currency=currency
        )
        nodes = self.filter_nodes(nodes, currency == &#34;FreeTFT&#34;)
        if nodes_number &gt; len(nodes):
            farms_with_no_resources.append(farm_name)
    return list(farms_with_no_resources)</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.reservation_chatflow.reservation_chatflow.ReservationChatflow.check_solution_type"><code class="name flex">
<span>def <span class="ident">check_solution_type</span></span>(<span>self, reservation)</span>
</code></dt>
<dd>
<section class="desc"><p>categorize the solutions by types</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>reservation</code></strong> :&ensp;<code>jumpscale.clients.explorer.models.TfgridWorkloadsReservation1</code></dt>
<dd>user reservation</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>[jumpscale.clients.explorer.models.SolutionType]: type of the solution</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def check_solution_type(self, reservation):
    &#34;&#34;&#34;categorize the solutions by types

    Args:
        reservation (jumpscale.clients.explorer.models.TfgridWorkloadsReservation1): user reservation

    Returns:
        [jumpscale.clients.explorer.models.SolutionType]: type of the solution
    &#34;&#34;&#34;
    containers = reservation.data_reservation.containers
    volumes = reservation.data_reservation.volumes
    zdbs = reservation.data_reservation.zdbs
    kubernetes = reservation.data_reservation.kubernetes
    networks = reservation.data_reservation.networks
    if containers == [] and volumes == [] and zdbs == [] and kubernetes == [] and networks:
        return SolutionType.Network
    elif kubernetes != []:
        return SolutionType.Kubernetes
    elif len(containers) != 0:
        if &#34;ubuntu&#34; in containers[0].flist:
            return SolutionType.Ubuntu
        elif &#34;minio&#34; in containers[0].flist:
            return SolutionType.Minio
        elif &#34;gitea&#34; in containers[0].flist:
            return SolutionType.Gitea
        elif &#34;tcprouter&#34; in containers[0].flist:
            return SolutionType.Exposed
        return &#34;flist&#34;
    elif reservation.data_reservation.domain_delegates:
        return SolutionType.DelegatedDomain
    return SolutionType.Unknown</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.reservation_chatflow.reservation_chatflow.ReservationChatflow.clear_blocked_nodes"><code class="name flex">
<span>def <span class="ident">clear_blocked_nodes</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def clear_blocked_nodes(self):
    blocked_node_keys = j.core.db.keys(f&#34;{NODES_DISALLOW_PREFIX}:*&#34;)
    if blocked_node_keys:
        j.core.db.delete(*blocked_node_keys)
    j.core.db.delete(NODES_COUNT_KEY)</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.reservation_chatflow.reservation_chatflow.ReservationChatflow.create_network"><code class="name flex">
<span>def <span class="ident">create_network</span></span>(<span>self, network_name, reservation, ip_range, customer_tid, ip_version, access_node, expiration=None, currency=None, bot=None)</span>
</code></dt>
<dd>
<section class="desc"><p>create network to deploy reservation on</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>network_name</code></strong> :&ensp;<code>str</code></dt>
<dd>network name</dd>
<dt><strong><code>reservation</code></strong> :&ensp;<code>jumpscale.clients.explorer.models.TfgridWorkloadsReservation1</code></dt>
<dd>reservation object</dd>
<dt><strong><code>ip_range</code></strong> :&ensp;<code>IPRange</code></dt>
<dd>selected ip range eg: "10.70.0.0/16"</dd>
<dt><strong><code>customer_tid</code></strong> :&ensp;<code>int</code></dt>
<dd>user tid</dd>
<dt><strong><code>ip_version</code></strong> :&ensp;<code>str</code></dt>
<dd>"IPv4" or "IPv6"</dd>
<dt><strong><code>expiration</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>epoch for expiration time. Defaults to None.</dd>
<dt><strong><code>currency</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>wanted currency . Defaults to None.</dd>
<dt><strong><code>bot</code></strong> :&ensp;<code>GedisChatBot</code>, optional</dt>
<dd>bot instance. Defaults to None.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><strong><code>StopChatFlow</code></strong></dt>
<dd>when no available node</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>[dict]: network config</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def create_network(
    self,
    network_name,
    reservation,
    ip_range,
    customer_tid,
    ip_version,
    access_node,
    expiration=None,
    currency=None,
    bot=None,
):
    &#34;&#34;&#34;create network to deploy reservation on

    Args:
        network_name (str): network name
        reservation (jumpscale.clients.explorer.models.TfgridWorkloadsReservation1): reservation object
        ip_range (IPRange): selected ip range eg: &#34;10.70.0.0/16&#34;
        customer_tid (int): user tid
        ip_version (str): &#34;IPv4&#34; or &#34;IPv6&#34;
        expiration (int, optional): epoch for expiration time. Defaults to None.
        currency (str, optional): wanted currency . Defaults to None.
        bot (GedisChatBot, optional): bot instance. Defaults to None.

    Raises:
        StopChatFlow: when no available node

    Returns:
        [dict]: network config
    &#34;&#34;&#34;

    network = j.sals.zos.get().network.create(reservation, ip_range, network_name)
    node_subnets = netaddr.IPNetwork(ip_range).subnet(24)
    network_config = dict()
    use_ipv4 = ip_version == &#34;IPv4&#34;

    j.sals.zos.get().network.add_node(network, access_node.node_id, str(next(node_subnets)))
    wg_quick = j.sals.zos.get().network.add_access(
        network, access_node.node_id, str(next(node_subnets)), ipv4=use_ipv4
    )

    network_config[&#34;wg&#34;] = wg_quick

    j.sals.fs.mkdir(f&#34;{j.core.dirs.CFGDIR}/wireguard/&#34;)
    j.sals.fs.write_file(f&#34;{j.core.dirs.CFGDIR}/wireguard/{network_name}.conf&#34;, f&#34;{wg_quick}&#34;)

    # register the reservation
    expiration = expiration or j.data.time.get().timestamp + (60 * 60 * 24)
    reservation_create = self.register_reservation(
        reservation, expiration, customer_tid, currency=currency, bot=bot
    )

    network_config[&#34;rid&#34;] = reservation_create.reservation_id
    network_config[&#34;reservation_create&#34;] = reservation_create

    return network_config</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.reservation_chatflow.reservation_chatflow.ReservationChatflow.create_payment"><code class="name flex">
<span>def <span class="ident">create_payment</span></span>(<span>self, rid, currency, escrow_address, escrow_asset, total_amount, payment_source, farmer_payments)</span>
</code></dt>
<dd>
<section class="desc"><p>create payment object and save it locally</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>rid</code></strong> :&ensp;<code>int</code></dt>
<dd>customer tid</dd>
<dt><strong><code>currency</code></strong> :&ensp;<code>str</code></dt>
<dd>reservation currency "TFT" or "FreeTFT"</dd>
<dt><strong><code>escrow_address</code></strong> :&ensp;<code>str</code></dt>
<dd>escrow_address</dd>
<dt><strong><code>escrow_asset</code></strong> :&ensp;<code>str</code></dt>
<dd>escrow asset</dd>
<dt><strong><code>total_amount</code></strong> :&ensp;<code>str</code></dt>
<dd>paid amount</dd>
<dt><strong><code>payment_source</code></strong> :&ensp;<code>str</code></dt>
<dd>payment source</dd>
<dt><strong><code>farmer_payments</code></strong> :&ensp;<code>list</code></dt>
<dd>total list of farmer payments</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>[jumpscale.clients.explorer.models.TfgridSolutionsPayment1]: payment object</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def create_payment(
    self, rid, currency, escrow_address, escrow_asset, total_amount, payment_source, farmer_payments
):
    &#34;&#34;&#34;create payment object and save it locally

    Args:
        rid (int): customer tid
        currency (str): reservation currency &#34;TFT&#34; or &#34;FreeTFT&#34;
        escrow_address (str): escrow_address
        escrow_asset (str): escrow asset
        total_amount (str): paid amount
        payment_source (str): payment source
        farmer_payments (list): total list of farmer payments

    Returns:
        [jumpscale.clients.explorer.models.TfgridSolutionsPayment1]: payment object
    &#34;&#34;&#34;
    explorer_name = self._explorer.url.split(&#34;.&#34;)[1]
    payment_obj = self.payments.get(f&#34;{explorer_name}_{rid}&#34;)
    payment_obj.explorer = self._explorer.url
    payment_obj.rid = rid
    payment_obj.currency = currency
    payment_obj.escrow_address = escrow_address
    payment_obj.escrow_asset = escrow_asset
    payment_obj.total_amount = str(total_amount)
    payment_obj.transaction_fees = f&#34;0.1 {currency}&#34;
    payment_obj.payment_source = payment_source
    for farmer in farmer_payments:
        farmer_name = self._explorer.farms.get(farm_id=farmer[&#34;farmer_id&#34;]).name
        payment_obj.farmer_payments[farmer_name] = farmer[&#34;total_amount&#34;]
    return payment_obj</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.reservation_chatflow.reservation_chatflow.ReservationChatflow.decrypt_reservation_metadata"><code class="name flex">
<span>def <span class="ident">decrypt_reservation_metadata</span></span>(<span>self, metadata_encrypted)</span>
</code></dt>
<dd>
<section class="desc"><p>decrypt the reservation metadata using identity nacl</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>metadata_encrypted</code></strong> :&ensp;<code>bytes</code></dt>
<dd>encrypted metadata</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>[str]: decrypted solution metadata</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def decrypt_reservation_metadata(self, metadata_encrypted):
    &#34;&#34;&#34;decrypt the reservation metadata using identity nacl

    Args:
        metadata_encrypted (bytes): encrypted metadata

    Returns:
        [str]: decrypted solution metadata
    &#34;&#34;&#34;
    pk = j.core.identity.me.nacl.signing_key.verify_key.to_curve25519_public_key()
    sk = j.core.identity.me.nacl.signing_key.to_curve25519_private_key()
    box = Box(sk, pk)
    return box.decrypt(base64.b85decode(metadata_encrypted.encode())).decode()</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.reservation_chatflow.reservation_chatflow.ReservationChatflow.filter_nodes"><code class="name flex">
<span>def <span class="ident">filter_nodes</span></span>(<span>self, nodes, free_to_use, ip_version=None)</span>
</code></dt>
<dd>
<section class="desc"><p>filter nodes by free to use flag</p>
<h2 id="args">Args</h2>
<p>nodes (list of nodes objects)
free_to_use (bool)</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list</code> of <code>filtered</code> <code>nodes</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def filter_nodes(self, nodes, free_to_use, ip_version=None):
    &#34;&#34;&#34;filter nodes by free to use flag

    Args:
        nodes (list of nodes objects)
        free_to_use (bool)

    Returns:
        list of filtered nodes
    &#34;&#34;&#34;
    nodes = filter(j.sals.zos.get().nodes_finder.filter_is_up, nodes)
    nodes = list(nodes)
    if free_to_use:
        nodes = list(nodes)
        nodes = filter(j.sals.zos.get().nodes_finder.filter_is_free_to_use, nodes)
    elif not free_to_use:
        nodes = list(nodes)

    if ip_version:
        use_ipv4 = ip_version == &#34;IPv4&#34;

        if use_ipv4:
            nodefilter = j.sals.zos.get().nodes_finder.filter_public_ip4
        else:
            nodefilter = j.sals.zos.get().nodes_finder.filter_public_ip6

        nodes = filter(j.sals.zos.get().nodes_finder.filter_is_up, filter(nodefilter, nodes))
        if not nodes:
            raise StopChatFlow(&#34;Could not find available access node&#34;)
    return list(nodes)</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.reservation_chatflow.reservation_chatflow.ReservationChatflow.get_currency"><code class="name flex">
<span>def <span class="ident">get_currency</span></span>(<span>self, reservation)</span>
</code></dt>
<dd>
<section class="desc"><p>get reservation currency</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>reservation</code></strong> :&ensp;<code>jumpscale.clients.explorer.models.TfgridWorkloadsReservation1</code></dt>
<dd>reservation object</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>[str]</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def get_currency(self, reservation):
    &#34;&#34;&#34;get reservation currency

    Args:
        reservation (jumpscale.clients.explorer.models.TfgridWorkloadsReservation1): reservation object

    Returns:
        [str]
    &#34;&#34;&#34;
    currencies = reservation.data_reservation.currencies
    if currencies:
        return currencies[0]
    elif reservation.data_reservation.networks and reservation.data_reservation.networks[0].network_resources:
        node_id = reservation.data_reservation.networks[0].network_resources[0].node_id
        if self._explorer.nodes.get(node_id).free_to_use:
            return &#34;FreeTFT&#34;

    return &#34;TFT&#34;</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.reservation_chatflow.reservation_chatflow.ReservationChatflow.get_farm_names"><code class="name flex">
<span>def <span class="ident">get_farm_names</span></span>(<span>self, number_of_nodes, bot, cru=None, sru=None, mru=None, hru=None, currency=&#39;TFT&#39;, message=&#39;&#39;)</span>
</code></dt>
<dd>
<section class="desc"><p>get list with available farm names and prompt user to choose one</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>number_of_nodes</code></strong> :&ensp;<code>int</code></dt>
<dd>required nodes count</dd>
<dt><strong><code>farm_id</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>id for farm to search with. Defaults to None.</dd>
<dt><strong><code>farm_names</code></strong> :&ensp;<code>list</code>, optional</dt>
<dd>farms to search in. Defaults to None.</dd>
<dt><strong><code>cru</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>cpu resource. Defaults to None.</dd>
<dt><strong><code>sru</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>ssd resource. Defaults to None.</dd>
<dt><strong><code>mru</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>memory resource. Defaults to None.</dd>
<dt><strong><code>hru</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>hdd resources. Defaults to None.</dd>
<dt><strong><code>currency</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>wanted currency. Defaults to "TFT".</dd>
<dt><strong><code>message</code></strong> :&ensp;<code>str</code></dt>
<dd>message to user. Defaults to ""</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def get_farm_names(self, number_of_nodes, bot, cru=None, sru=None, mru=None, hru=None, currency=&#34;TFT&#34;, message=&#34;&#34;):
    &#34;&#34;&#34;get list with available farm names and prompt user to choose one

    Args:
        number_of_nodes (int): required nodes count
        farm_id (int, optional): id for farm to search with. Defaults to None.
        farm_names (list, optional): farms to search in. Defaults to None.
        cru (int, optional): cpu resource. Defaults to None.
        sru (int, optional): ssd resource. Defaults to None.
        mru (int, optional): memory resource. Defaults to None.
        hru (int, optional): hdd resources. Defaults to None.
        currency (str, optional): wanted currency. Defaults to &#34;TFT&#34;.
        message (str): message to user. Defaults to &#34;&#34;

    &#34;&#34;&#34;
    farms_message = f&#34;Select 1 or more farms to distribute the {message} nodes on. If no selection is made, the farms will be chosen randomly&#34;
    empty_farms = set()
    all_farms = self._explorer.farms.list()
    retry = False
    while True:
        farms = self.select_farms(
            bot, farms_message, currency=currency, retry=retry, cru=cru, sru=sru, hru=hru, mru=mru
        )
        farms_with_no_resources = self.check_farms(
            1, farm_names=farms, cru=cru, sru=sru, mru=mru, hru=hru, currency=currency
        )
        if not farms_with_no_resources:
            return farms
        for farm_name in farms_with_no_resources:
            empty_farms.add(farm_name)
        if len(all_farms) == len(empty_farms):
            raise StopChatFlow(&#34;No Farms available containing nodes that match the required resources&#34;)
        if message:
            message = f&#34;for {message}&#34;
        retry = True
        resources_of_farm = &#34;&#34;
        if cru:
            resources_of_farm += f&#34; cru={cru}/&#34;
        if sru:
            resources_of_farm += f&#34; sru={sru}/&#34;
        if mru:
            resources_of_farm += f&#34; mru={mru}/&#34;
        if hru:
            resources_of_farm += f&#34; hru={hru}/&#34;
        if currency:
            resources_of_farm += f&#34; and the currency={currency}&#34;
        farms_message = (
            f&#34;&#34;&#34;The following farms don&#39;t meet the criteria of having {resources_of_farm} {message}: &#34;&#34;&#34;
            + &#34;, &#34;.join(farms_with_no_resources)
            + &#34;&#34;&#34;.
            Please reselect farms to check for resources or leave it empty
            &#34;&#34;&#34;
        )</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.reservation_chatflow.reservation_chatflow.ReservationChatflow.get_ip_range"><code class="name flex">
<span>def <span class="ident">get_ip_range</span></span>(<span>self, bot)</span>
</code></dt>
<dd>
<section class="desc"><p>prompt user to select iprange</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>bot</code></strong> :&ensp;<code>GedisChatBot</code></dt>
<dd>bot instance</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>[IPRange]: ip selected by user</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def get_ip_range(self, bot):
    &#34;&#34;&#34;prompt user to select iprange

    Args:
        bot (GedisChatBot): bot instance

    Returns:
        [IPRange]: ip selected by user
    &#34;&#34;&#34;
    ip_range_choose = [&#34;Configure IP range myself&#34;, &#34;Choose IP range for me&#34;]
    iprange_user_choice = bot.single_choice(
        &#34;To have access to the 3Bot, the network must be configured&#34;,
        ip_range_choose,
        required=True,
        default=ip_range_choose[1],
    )
    if iprange_user_choice == &#34;Configure IP range myself&#34;:
        ip_range = bot.string_ask(&#34;Please add private IP Range of the network&#34;)
    else:
        first_digit = random.choice([172, 10])
        if first_digit == 10:
            second_digit = random.randint(0, 255)
        else:
            second_digit = random.randint(16, 31)
        ip_range = str(first_digit) + &#34;.&#34; + str(second_digit) + &#34;.0.0/16&#34;
    return ip_range</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.reservation_chatflow.reservation_chatflow.ReservationChatflow.get_kube_network_ip"><code class="name flex">
<span>def <span class="ident">get_kube_network_ip</span></span>(<span>self, reservation_data)</span>
</code></dt>
<dd>
<section class="desc"><p>get kubernetes reservation network id</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>reservation_data</code></strong> :&ensp;<code>jumpscale.clients.explorer.models.TfgridWorkloadsReservation1.reservation_data</code></dt>
<dd>reservation data object</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>[str, str]: network_id, ip</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def get_kube_network_ip(self, reservation_data):
    &#34;&#34;&#34;get kubernetes reservation network id

    Args:
        reservation_data (jumpscale.clients.explorer.models.TfgridWorkloadsReservation1.reservation_data): reservation data object

    Returns:
        [str, str]: network_id, ip
    &#34;&#34;&#34;
    network_id = reservation_data[&#34;kubernetes&#34;][0][&#34;network_id&#34;]
    ip = reservation_data[&#34;kubernetes&#34;][0][&#34;ipaddress&#34;]
    return network_id, ip</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.reservation_chatflow.reservation_chatflow.ReservationChatflow.get_network"><code class="name flex">
<span>def <span class="ident">get_network</span></span>(<span>self, bot, customer_tid, name)</span>
</code></dt>
<dd>
<section class="desc"><p>get the network object</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>bot</code></strong> :&ensp;<code>GedisChatBot</code></dt>
<dd>bot instance</dd>
<dt><strong><code>customer_tid</code></strong> :&ensp;<code>int</code></dt>
<dd>user tid</dd>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>[network name]</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>[jumpscale.clients.explorer.models.TfgridWorkloadsReservationNetwork1]: nework object</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def get_network(self, bot, customer_tid, name):
    &#34;&#34;&#34;get the network object

    Args:
        bot (GedisChatBot): bot instance
        customer_tid (int): user tid
        name (str): [network name]

    Returns:
        [jumpscale.clients.explorer.models.TfgridWorkloadsReservationNetwork1]: nework object
    &#34;&#34;&#34;
    reservations = j.sals.zos.get().reservation_list(tid=customer_tid, next_action=&#34;DEPLOY&#34;)
    networks = self.list_networks(customer_tid, reservations)
    for key in networks.keys():
        network, expiration, currency, resv_id = networks[key]
        if network.name == name:
            return Network(network, expiration, bot, reservations, currency, resv_id)</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.reservation_chatflow.reservation_chatflow.ReservationChatflow.get_nodes"><code class="name flex">
<span>def <span class="ident">get_nodes</span></span>(<span>self, number_of_nodes, cru=None, sru=None, mru=None, hru=None, currency=&#39;TFT&#39;, ip_version=None, pool_ids=None, filter_blocked=True)</span>
</code></dt>
<dd>
<section class="desc"><p>get available nodes to deploy solutions on</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>number_of_nodes</code></strong> :&ensp;<code>int</code></dt>
<dd>required nodes count</dd>
<dt><strong><code>farm_id</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>id for farm to search with. Defaults to None.</dd>
<dt><strong><code>farm_names</code></strong> :&ensp;<code>list</code>, optional</dt>
<dd>farms to search in. Defaults to None.</dd>
<dt><strong><code>cru</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>cpu resource. Defaults to None.</dd>
<dt><strong><code>sru</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>ssd resource. Defaults to None.</dd>
<dt><strong><code>mru</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>memory resource. Defaults to None.</dd>
<dt><strong><code>hru</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>hdd resources. Defaults to None.</dd>
<dt><strong><code>currency</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>wanted currency. Defaults to "TFT".</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><strong><code>StopChatFlow</code></strong></dt>
<dd>if no nodes found</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list</code> of <code>available</code> <code>nodes</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def get_nodes(
    self,
    number_of_nodes,
    cru=None,
    sru=None,
    mru=None,
    hru=None,
    currency=&#34;TFT&#34;,
    ip_version=None,
    pool_ids=None,
    filter_blocked=True,
):
    &#34;&#34;&#34;get available nodes to deploy solutions on

    Args:
        number_of_nodes (int): required nodes count
        farm_id (int, optional): id for farm to search with. Defaults to None.
        farm_names (list, optional): farms to search in. Defaults to None.
        cru (int, optional): cpu resource. Defaults to None.
        sru (int, optional): ssd resource. Defaults to None.
        mru (int, optional): memory resource. Defaults to None.
        hru (int, optional): hdd resources. Defaults to None.
        currency (str, optional): wanted currency. Defaults to &#34;TFT&#34;.

    Raises:
        StopChatFlow: if no nodes found

    Returns:
        list of available nodes
    &#34;&#34;&#34;

    def filter_disallowed_nodes(disallowed_node_ids, nodes):
        result = []
        for node in nodes:
            if node.node_id not in disallowed_node_ids:
                result.append(node)
        return result

    disallowed_node_ids = []
    if filter_blocked:
        disallowed_node_ids = self.list_blocked_nodes().keys()
    if j.config.get(&#34;OVER_PROVISIONING&#34;):
        cru = 0
        mru = 0
    nodes_distribution = self._distribute_nodes(number_of_nodes, pool_ids=pool_ids)
    # to avoid using the same node with different networks
    nodes_selected = []
    selected_ids = []
    for pool_id in nodes_distribution:
        nodes_number = nodes_distribution[pool_id]
        if not pool_ids:
            pool_id = None
        nodes = j.sals.zos.get().nodes_finder.nodes_by_capacity(
            cru=cru, sru=sru, mru=mru, hru=hru, currency=currency, pool_id=pool_id
        )
        nodes = filter_disallowed_nodes(disallowed_node_ids, nodes)
        nodes = self.filter_nodes(nodes, currency == &#34;FreeTFT&#34;, ip_version=ip_version)
        for i in range(nodes_number):
            try:
                node = random.choice(nodes)
                while node.node_id in selected_ids:
                    node = random.choice(nodes)
            except IndexError:
                raise StopChatFlow(
                    &#34;Failed to find resources for this reservation. If you are using a low resources environment like testnet, please make sure to allow over provisioning from the settings tab in dashboard. For more info visit &lt;a href=&#39;https://manual2.threefold.io/#/3bot_settings?id=developers-options&#39;&gt;our manual&lt;/a&gt;&#34;,
                    htmlAlert=True,
                )
            nodes.remove(node)
            nodes_selected.append(node)
            selected_ids.append(node.node_id)
    return nodes_selected</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.reservation_chatflow.reservation_chatflow.ReservationChatflow.get_payment_details"><code class="name flex">
<span>def <span class="ident">get_payment_details</span></span>(<span>self, escrow_info, currency)</span>
</code></dt>
<dd>
<section class="desc"><p>split payment details and get each one</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>escrow_info</code></strong> :&ensp;<code>str</code></dt>
<dd>payment info</dd>
<dt><strong><code>currency</code></strong> :&ensp;<code>str</code></dt>
<dd>currency used</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>[str]: payment details</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def get_payment_details(self, escrow_info, currency):
    &#34;&#34;&#34;split payment details and get each one

    Args:
        escrow_info (str): payment info
        currency (str): currency used

    Returns:
        [str]: payment details
    &#34;&#34;&#34;

    farmer_payments = escrow_info[&#34;farmer_payments&#34;]
    total_amount = escrow_info[&#34;total_amount&#34;]

    payment_details = &#34;&#34;
    payment_details += &#39;&lt;table style=&#34;width: 50%; font-family: arial, sans-serif; border-collapse: collapse;&#34;&gt;&#39;
    for farmer in farmer_payments:
        farmer_name = self._explorer.farms.get(farm_id=farmer[&#34;farmer_id&#34;]).name
        payment_details += (
            f&#34;&lt;tr&gt;&lt;td&gt;Farmer {farmer_name}&lt;/td&gt;&lt;td&gt;{format(farmer[&#39;total_amount&#39;],&#39;.7f&#39;)} {currency}&lt;/td&gt;&lt;/tr&gt;&#34;
        )
    payment_details += f&#34;&lt;tr&gt;&lt;td&gt;Transaction Fees&lt;/td&gt;&lt;td&gt;{0.1} {currency}&lt;/td&gt;&lt;/tr&gt;&#34;
    payment_details += f&#34;&lt;tr&gt;&lt;td&gt;Total amount&lt;/td&gt;&lt;td&gt;{format(total_amount + 0.1,&#39;.7f&#39;)} {currency}&lt;/td&gt;&lt;/tr&gt;&#34;
    payment_details += &#34;&lt;/table&gt;&#34;

    return payment_details</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.reservation_chatflow.reservation_chatflow.ReservationChatflow.get_solution_domain_delegates_info"><code class="name flex">
<span>def <span class="ident">get_solution_domain_delegates_info</span></span>(<span>self, reservation)</span>
</code></dt>
<dd>
<section class="desc"><p>get domain delegated metadata info</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>reservation</code></strong> :&ensp;<code>jumpscale.clients.explorer.models.TfgridWorkloadsReservation1</code></dt>
<dd>reservation object</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>[dict]: domain delegated metadata info</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def get_solution_domain_delegates_info(self, reservation):
    &#34;&#34;&#34;get domain delegated metadata info

    Args:
        reservation (jumpscale.clients.explorer.models.TfgridWorkloadsReservation1): reservation object

    Returns:
        [dict]: domain delegated metadata info
    &#34;&#34;&#34;

    delegated_domain = reservation.data_reservation.domain_delegates[0]
    return {&#34;Domain&#34;: delegated_domain.domain, &#34;Gateway&#34;: delegated_domain.node_id}</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.reservation_chatflow.reservation_chatflow.ReservationChatflow.get_solution_exposed_info"><code class="name flex">
<span>def <span class="ident">get_solution_exposed_info</span></span>(<span>self, reservation)</span>
</code></dt>
<dd>
<section class="desc"><p>get information about solution exposed from reservation</p>
<h2 id="args">Args</h2>
<p>reservation (jumpscale.clients.explorer.models.TfgridWorkloadsReservation1)
return dict of info</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def get_solution_exposed_info(self, reservation):
    &#34;&#34;&#34;get information about solution exposed from reservation

    Args:
        reservation (jumpscale.clients.explorer.models.TfgridWorkloadsReservation1)

    return dict of info
    &#34;&#34;&#34;

    def get_arg(cmd, arg):
        idx = cmd.index(arg)
        if idx:
            return cmd[idx + 1]
        return None

    info = {}
    for container in reservation.data_reservation.containers:
        if &#34;tcprouter&#34; in container.flist:
            entrypoint = container.entrypoint.split()
            local = get_arg(entrypoint, &#34;-local&#34;)
            if local:
                info[&#34;Port&#34;] = local.split(&#34;:&#34;)[-1]
            localtls = get_arg(entrypoint, &#34;-local-tls&#34;)
            if localtls:
                info[&#34;port-tls&#34;] = localtls.split(&#34;:&#34;)[-1]
            remote = get_arg(entrypoint, &#34;-remote&#34;)
            if remote:
                info[&#34;Name Server&#34;] = remote.split(&#34;:&#34;)[0]
    for proxy in reservation.data_reservation.reverse_proxies:
        info[&#34;Domain&#34;] = proxy.domain
    return info</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.reservation_chatflow.reservation_chatflow.ReservationChatflow.get_solution_flist_info"><code class="name flex">
<span>def <span class="ident">get_solution_flist_info</span></span>(<span>self, metadata, reservation)</span>
</code></dt>
<dd>
<section class="desc"><p>get flist solutions information from metadata on explorer and update local ones</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>metadata</code></strong> :&ensp;<code>dict</code></dt>
<dd>flist reservation metadata</dd>
<dt><strong><code>reservation</code></strong> :&ensp;<code>jumpscale.clients.explorer.models.TfgridWorkloadsReservation1</code></dt>
<dd>ubuntu reservation</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>[dict]: updated metadata</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def get_solution_flist_info(self, metadata, reservation):
    &#34;&#34;&#34;get flist solutions information from metadata on explorer and update local ones

    Args:
        metadata (dict): flist reservation metadata
        reservation (jumpscale.clients.explorer.models.TfgridWorkloadsReservation1): ubuntu reservation

    Returns:
        [dict]: updated metadata
    &#34;&#34;&#34;
    envs = reservation.data_reservation.containers[0].environment
    env_variable = &#34;&#34;
    for key, value in envs.items():
        env_variable += f&#34;{key}={value}, &#34;
    metadata[&#34;form_info&#34;][&#34;CPU&#34;] = reservation.data_reservation.containers[0].capacity.cpu
    metadata[&#34;form_info&#34;][&#34;Memory&#34;] = reservation.data_reservation.containers[0].capacity.memory
    metadata[&#34;form_info&#34;][&#34;Root filesystem Type&#34;] = str(
        reservation.data_reservation.containers[0].capacity.disk_type
    )
    metadata[&#34;form_info&#34;][&#34;Root filesystem Size&#34;] = (
        reservation.data_reservation.containers[0].capacity.disk_size or 256
    )
    metadata[&#34;form_info&#34;][&#34;Env variables&#34;] = str(env_variable)
    metadata[&#34;form_info&#34;][&#34;Flist link&#34;] = reservation.data_reservation.containers[0].flist
    metadata[&#34;form_info&#34;][&#34;Interactive&#34;] = reservation.data_reservation.containers[0].interactive
    if metadata[&#34;form_info&#34;][&#34;Interactive&#34;]:
        metadata[&#34;form_info&#34;][&#34;Port&#34;] = &#34;7681&#34;
    metadata[&#34;form_info&#34;][&#34;Entry point&#34;] = reservation.data_reservation.containers[0].entrypoint
    metadata[&#34;form_info&#34;][&#34;IP Address&#34;] = reservation.data_reservation.containers[0].network_connection[0].ipaddress
    return metadata</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.reservation_chatflow.reservation_chatflow.ReservationChatflow.get_solution_metadata"><code class="name flex">
<span>def <span class="ident">get_solution_metadata</span></span>(<span>self, solution_name, solution_type, form_info=None)</span>
</code></dt>
<dd>
<section class="desc"><p>get metadata from a solution</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>solution_name</code></strong> :&ensp;<code>str</code></dt>
<dd>solution name</dd>
<dt><strong><code>solution_type</code></strong> :&ensp;<code>str</code></dt>
<dd>solution type</dd>
<dt><strong><code>form_info</code></strong> :&ensp;<code>dict</code>, optional</dt>
<dd>info from user slide. Defaults to None.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>dict</code></strong></dt>
<dd>metadata</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def get_solution_metadata(self, solution_name, solution_type, form_info=None):
    &#34;&#34;&#34;get metadata from a solution

    Args:
        solution_name (str): solution name
        solution_type (str): solution type
        form_info (dict, optional): info from user slide. Defaults to None.

    Returns:
        dict: metadata
    &#34;&#34;&#34;
    form_info = form_info or {}
    reservation = {}
    reservation[&#34;name&#34;] = solution_name
    reservation[&#34;form_info&#34;] = form_info
    reservation[&#34;solution_type&#34;] = solution_type.value
    reservation[&#34;explorer&#34;] = self._explorer.url
    return reservation</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.reservation_chatflow.reservation_chatflow.ReservationChatflow.get_solution_ubuntu_info"><code class="name flex">
<span>def <span class="ident">get_solution_ubuntu_info</span></span>(<span>self, metadata, reservation)</span>
</code></dt>
<dd>
<section class="desc"><p>get ubuntu solutions information from metadata on explorer and update local ones</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>metadata</code></strong> :&ensp;<code>dict</code></dt>
<dd>ubuntu reservation metadata</dd>
<dt><strong><code>reservation</code></strong> :&ensp;<code>jumpscale.clients.explorer.models.TfgridWorkloadsReservation1</code></dt>
<dd>ubuntu reservation</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>[dict]: updated metadata</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def get_solution_ubuntu_info(self, metadata, reservation):
    &#34;&#34;&#34;get ubuntu solutions information from metadata on explorer and update local ones

    Args:
        metadata (dict): ubuntu reservation metadata
        reservation (jumpscale.clients.explorer.models.TfgridWorkloadsReservation1): ubuntu reservation

    Returns:
        [dict]: updated metadata
    &#34;&#34;&#34;
    envs = reservation.data_reservation.containers[0].environment
    env_variable = &#34;&#34;
    metadata[&#34;form_info&#34;][&#34;Public key&#34;] = envs[&#34;pub_key&#34;].strip(&#34; &#34;)
    envs.pop(&#34;pub_key&#34;)
    metadata[&#34;form_info&#34;][&#34;CPU&#34;] = reservation.data_reservation.containers[0].capacity.cpu
    metadata[&#34;form_info&#34;][&#34;Memory&#34;] = reservation.data_reservation.containers[0].capacity.memory
    metadata[&#34;form_info&#34;][&#34;Root filesystem Type&#34;] = str(
        reservation.data_reservation.containers[0].capacity.disk_type
    )
    metadata[&#34;form_info&#34;][&#34;Root filesystem Size&#34;] = (
        reservation.data_reservation.containers[0].capacity.disk_size or 256
    )
    for key, value in envs.items():
        env_variable += f&#34;{key}={value},&#34;
    metadata[&#34;form_info&#34;][&#34;Env variables&#34;] = str(env_variable)
    metadata[&#34;form_info&#34;][&#34;IP Address&#34;] = reservation.data_reservation.containers[0].network_connection[0].ipaddress
    return metadata</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.reservation_chatflow.reservation_chatflow.ReservationChatflow.get_solutions"><code class="name flex">
<span>def <span class="ident">get_solutions</span></span>(<span>self, solution_type)</span>
</code></dt>
<dd>
<section class="desc"><p>get deployed solutions from specified type</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>solution_type</code></strong> :&ensp;<code>str</code></dt>
<dd>solution type</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>[list]: list of reservations objects</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def get_solutions(self, solution_type):
    &#34;&#34;&#34;get deployed solutions from specified type

    Args:
        solution_type (str): solution type

    Returns:
        [list]: list of reservations objects
    &#34;&#34;&#34;
    reservations = []
    for name in self.solutions.list_all():
        solution = self.solutions.get(name)
        if solution.solution_type != solution_type:
            continue
        if solution.explorer and solution.explorer != self._explorer.url:
            continue
        reservation = self._explorer.reservations.get(solution.rid)
        reservations.append(
            {
                &#34;name&#34;: solution.name,
                &#34;reservation&#34;: reservation._get_data(),
                &#34;type&#34;: solution_type.value,
                &#34;form_info&#34;: json.dumps(solution.form_info),
            }
        )
    return reservations</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.reservation_chatflow.reservation_chatflow.ReservationChatflow.get_solutions_explorer"><code class="name flex">
<span>def <span class="ident">get_solutions_explorer</span></span>(<span>self, deployed=True)</span>
</code></dt>
<dd>
<section class="desc"><p>get the updated reservations from explorer</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>deployed</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>set False to get all reservations. Defaults to True.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>list</code></strong></dt>
<dd>list of reservations</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def get_solutions_explorer(self, deployed=True):
    &#34;&#34;&#34;get the updated reservations from explorer

    Args:
        deployed (bool, optional): set False to get all reservations. Defaults to True.

    Returns:
        list: list of reservations
    &#34;&#34;&#34;
    customer_tid = self.me.tid
    reservations_data = []
    reservations = []
    if deployed:
        reservations = self._explorer.reservations.list(customer_tid, &#34;DEPLOY&#34;)
    else:
        reservations = self._explorer.reservations.list(customer_tid)
    networks = []
    dupnames = {}
    for reservation in sorted(reservations, key=lambda res: res.id, reverse=True):
        info = {}
        if reservation.metadata:
            try:
                metadata = self.decrypt_reservation_metadata(reservation.metadata)
                metadata = json.loads(metadata)
            except Exception:
                continue
            if &#34;form_info&#34; not in metadata:
                solution_type = self.check_solution_type(reservation).value
            else:
                solution_type = metadata[&#34;form_info&#34;].pop(&#34;chatflow&#34;, SolutionType.Unknown.value)
            if solution_type == SolutionType.Unknown.value:
                continue
            elif solution_type == SolutionType.Ubuntu.value:
                metadata = self.get_solution_ubuntu_info(metadata, reservation)
            elif solution_type == SolutionType.Flist.value:
                metadata = self.get_solution_flist_info(metadata, reservation)
            elif solution_type == SolutionType.Network.value:
                if metadata[&#34;name&#34;] in networks:
                    continue
                networks.append(metadata[&#34;name&#34;])
            elif solution_type == SolutionType.Gitea.value:
                metadata[&#34;form_info&#34;][&#34;Public key&#34;] = reservation.data_reservation.containers[0].environment[
                    &#34;pub_key&#34;
                ]
            elif solution_type == SolutionType.Exposed.value:
                meta = metadata
                metadata = {&#34;form_info&#34;: meta}
                metadata[&#34;form_info&#34;].update(self.get_solution_exposed_info(reservation))
                metadata[&#34;name&#34;] = metadata[&#34;form_info&#34;].get(&#34;Domain&#34;)

            info = metadata[&#34;form_info&#34;]
            name = metadata[&#34;name&#34;]
        else:
            solution_type = self.check_solution_type(reservation)
            if type(solution_type) is not str:
                solution_type = solution_type.value
            info = {}
            name = f&#34;unknown_{reservation.id}&#34;
            if solution_type == SolutionType.Unknown.value:
                continue
            elif solution_type == SolutionType.Network.value:
                name = reservation.data_reservation.networks[0].name
                if name in networks:
                    continue
                networks.append(name)
            elif solution_type == SolutionType.DelegatedDomain.value:
                info = self.get_solution_domain_delegates_info(reservation)
                if not info.get(&#34;Solution name&#34;):
                    name = f&#34;unknown_{reservation.id}&#34;
                else:
                    name = info[&#34;Solution name&#34;]
            elif solution_type == SolutionType.Exposed.value:
                info = self.get_solution_exposed_info(reservation)
                info[&#34;Solution name&#34;] = name
                name = info.get(&#34;Domain&#34;)

        count = dupnames.setdefault(solution_type, {}).setdefault(name, 1)
        if count != 1:
            dupnames[solution_type][name] = count + 1
            name = f&#34;{name}_{count}&#34;
        # append reservation
        reservations_data.append(
            {
                &#34;id&#34;: reservation.id,
                &#34;name&#34;: name,
                &#34;solution_type&#34;: solution_type,
                &#34;form_info&#34;: info,
                &#34;status&#34;: reservation.next_action.name,
                &#34;reservation_date&#34;: reservation.epoch.ctime(),
                &#34;reservation&#34;: reservation._get_data(),
            }
        )
    return reservations_data</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.reservation_chatflow.reservation_chatflow.ReservationChatflow.list_blocked_nodes"><code class="name flex">
<span>def <span class="ident">list_blocked_nodes</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>each blocked node is stored in a key with a prefix ZOS:NODES:DISALLOWED:{node_id} and its value is the expiration period for it.
number of failure count is defined in hash with key ZOS:NODES:FAILURE_COUNT. the hash keys are node_ids and values are count of how many times the node has been blocked</p>
<p>returns
dict: {node_id: {expiration: .., failure_count: &hellip;}}</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def list_blocked_nodes(self):
    &#34;&#34;&#34;
    each blocked node is stored in a key with a prefix ZOS:NODES:DISALLOWED:{node_id} and its value is the expiration period for it.
    number of failure count is defined in hash with key ZOS:NODES:FAILURE_COUNT. the hash keys are node_ids and values are count of how many times the node has been blocked

    returns
        dict: {node_id: {expiration: .., failure_count: ...}}
    &#34;&#34;&#34;
    blocked_node_keys = j.core.db.keys(f&#34;{NODES_DISALLOW_PREFIX}:*&#34;)
    failure_count_dict = j.core.db.hgetall(NODES_COUNT_KEY)
    blocked_node_values = j.core.db.mget(blocked_node_keys)
    result = {}
    for idx, key in enumerate(blocked_node_keys):
        key = key[len(NODES_DISALLOW_PREFIX) + 1 :]
        node_id = key.decode()
        expiration = int(blocked_node_values[idx])
        failure_count = int(failure_count_dict[key])
        result[node_id] = {&#34;expiration&#34;: expiration, &#34;failure_count&#34;: failure_count}
    return result</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.reservation_chatflow.reservation_chatflow.ReservationChatflow.list_delegate_domains"><code class="name flex">
<span>def <span class="ident">list_delegate_domains</span></span>(<span>self, customer_tid, currency=None)</span>
</code></dt>
<dd>
<section class="desc"><p>list delegated domains with passed currency</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>customer_tid</code></strong> :&ensp;<code>int</code></dt>
<dd>user tid</dd>
<dt><strong><code>currency</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>currency to search with. Defaults to None.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>[dict]: [domains names]</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def list_delegate_domains(self, customer_tid, currency=None):
    &#34;&#34;&#34;list delegated domains with passed currency

    Args:
        customer_tid (int): user tid
        currency (str, optional): currency to search with. Defaults to None.

    Returns:
        [dict]: [domains names]
    &#34;&#34;&#34;
    reservations = j.sals.zos.get().reservation_list(tid=customer_tid, next_action=&#34;DEPLOY&#34;)
    domains = dict()
    names = set()
    for reservation in sorted(reservations, key=lambda r: r.id, reverse=True):
        reservation_currency = self.get_currency(reservation)
        if reservation.next_action != NextAction.DEPLOY:
            continue
        rdomains = reservation.data_reservation.domain_delegates
        if currency and currency != reservation_currency:
            continue
        for dom in rdomains:
            if dom.domain in names:
                continue
            names.add(dom.domain)
            domains[dom.domain] = dom
    return domains</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.reservation_chatflow.reservation_chatflow.ReservationChatflow.list_gateways"><code class="name flex">
<span>def <span class="ident">list_gateways</span></span>(<span>self, bot, currency=None)</span>
</code></dt>
<dd>
<section class="desc"><p>list available gateways that supports passed currency</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>bot</code></strong> :&ensp;<code>GedisChatBot</code></dt>
<dd>bot instance</dd>
<dt><strong><code>currency</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>"TFT" or "FreeTFT". Defaults to None.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>[dict]</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def list_gateways(self, bot, currency=None):
    &#34;&#34;&#34;list available gateways that supports passed currency

    Args:
        bot (GedisChatBot): bot instance
        currency (str, optional): &#34;TFT&#34; or &#34;FreeTFT&#34;. Defaults to None.

    Returns:
        [dict]
    &#34;&#34;&#34;
    unknowns = [&#34;&#34;, None, &#34;Uknown&#34;, &#34;Unknown&#34;]
    gateways = {}
    farms = {}
    for g in j.sals.zos.get()._explorer.gateway.list():
        if not j.sals.zos.get().nodes_finder.filter_is_up(g):
            continue
        location = []
        for area in [&#34;continent&#34;, &#34;country&#34;, &#34;city&#34;]:
            areaname = getattr(g.location, area)
            if areaname not in unknowns:
                location.append(areaname)
        currencies = list()

        farm_id = g.farm_id
        if farm_id not in farms:
            farms[farm_id] = j.sals.zos.get()._explorer.farms.get(farm_id)

        addresses = farms[farm_id].wallet_addresses
        for address in addresses:
            if address.asset not in currencies:
                if address.asset == &#34;FreeTFT&#34; and not g.free_to_use:
                    continue
                currencies.append(address.asset)

        reservation_currency = &#34;, &#34;.join(currencies)

        if currency and currency not in currencies:
            continue
        gtext = f&#34;{&#39; - &#39;.join(location)} ({reservation_currency}) ID: {g.node_id}&#34;
        gateways[gtext] = g
    return gateways</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.reservation_chatflow.reservation_chatflow.ReservationChatflow.list_networks"><code class="name flex">
<span>def <span class="ident">list_networks</span></span>(<span>self, tid, reservations=None)</span>
</code></dt>
<dd>
<section class="desc"><p>list all available networks from reservations</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>tid</code></strong> :&ensp;<code>int</code></dt>
<dd>user tid</dd>
<dt><strong><code>reservation</code></strong> :&ensp;<code>list</code> of <code>jumpscale.clients.explorer.models.TfgridWorkloadsReservation1</code></dt>
<dd>list of reservation objects</dd>
</dl>
<h2 id="returns">Returns</h2></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def list_networks(self, tid, reservations=None):
    &#34;&#34;&#34;list all available networks from reservations

    Args:
        tid (int): user tid
        reservation (list of jumpscale.clients.explorer.models.TfgridWorkloadsReservation1): list of reservation objects

    Returns:
        [type]: [description]
    &#34;&#34;&#34;
    if not reservations:
        reservations = j.sals.zos.get().reservation_list(tid=tid, next_action=&#34;DEPLOY&#34;)
    networks = dict()
    names = set()
    for reservation in sorted(reservations, key=lambda r: r.id, reverse=True):
        if reservation.next_action != NextAction.DEPLOY:
            continue
        rnetworks = reservation.data_reservation.networks
        expiration = reservation.data_reservation.expiration_reservation
        currency = self.get_currency(reservation)
        for network in rnetworks:
            if network.name in names:
                continue
            names.add(network.name)
            remaining = j.data.time.get(expiration).humanize()

            network_name = network.name + f&#34; ({currency}) - ends &#34; + remaining
            networks[network_name] = (network, expiration, currency, reservation.id)

    return networks</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.reservation_chatflow.reservation_chatflow.ReservationChatflow.list_wallets"><code class="name flex">
<span>def <span class="ident">list_wallets</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>List all stellar client wallets from bcdb. Based on explorer instance only either wallets with network type TEST or STD are returned
rtype: list</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def list_wallets(self):
    &#34;&#34;&#34;
    List all stellar client wallets from bcdb. Based on explorer instance only either wallets with network type TEST or STD are returned
    rtype: list
    &#34;&#34;&#34;
    if &#34;devnet&#34; in self._explorer.url or &#34;testnet&#34; in self._explorer.url:
        network_type = StellarNetwork.TEST
    else:
        network_type = StellarNetwork.STD

    wallets_list = j.clients.stellar.list_all()
    wallets = dict()
    for wallet_name in wallets_list:
        wallet = j.clients.stellar.find(wallet_name)
        if wallet.network != network_type:
            continue
        wallets[wallet_name] = wallet
    return wallets</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.reservation_chatflow.reservation_chatflow.ReservationChatflow.register_and_pay_reservation"><code class="name flex">
<span>def <span class="ident">register_and_pay_reservation</span></span>(<span>self, reservation, expiration=None, customer_tid=None, currency=None, bot=None, wallet=None)</span>
</code></dt>
<dd>
<section class="desc"><p>register the reservation, pay and deploy</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>reservation</code></strong> :&ensp;<code>jumpscale.clients.explorer.models.TfgridWorkloadsReservation1</code></dt>
<dd>reservation object</dd>
<dt><strong><code>expiration</code></strong> :&ensp;<code>int</code></dt>
<dd>epoch time when the reservation should be canceled automaticly</dd>
<dt><strong><code>customer_tid</code></strong> :&ensp;<code>int</code></dt>
<dd>Id of the customer making the reservation</dd>
<dt><strong><code>currency</code></strong> :&ensp;<code>str</code></dt>
<dd>"TFT" of "FreeTFT"</dd>
<dt><strong><code>bot</code></strong> :&ensp;<code>GedisChatBot</code></dt>
<dd>bot instance</dd>
<dt><strong><code>wallet</code></strong> :&ensp;<code>TfgridDirectoryWallet_address1</code></dt>
<dd>wallet object. Defaults to None.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>[int]: reservation id</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def register_and_pay_reservation(
    self, reservation, expiration=None, customer_tid=None, currency=None, bot=None, wallet=None
):
    &#34;&#34;&#34;register the reservation, pay and deploy

    Args:
        reservation (jumpscale.clients.explorer.models.TfgridWorkloadsReservation1): reservation object
        expiration (int): epoch time when the reservation should be canceled automaticly
        customer_tid (int): Id of the customer making the reservation
        currency (str): &#34;TFT&#34; of &#34;FreeTFT&#34;
        bot (GedisChatBot): bot instance
        wallet (TfgridDirectoryWallet_address1): wallet object. Defaults to None.

    Returns:
        [int]: reservation id
    &#34;&#34;&#34;

    payment_obj = None
    if customer_tid and expiration and currency:
        reservation_create = self.register_reservation(
            reservation, expiration, customer_tid=customer_tid, currency=currency, bot=bot
        )
    else:
        reservation_create = reservation
    if not wallet:
        payment, payment_obj = self.show_payments(bot, reservation_create, currency)
    else:
        payment = {&#34;wallet&#34;: None, &#34;free&#34;: False}
        if not (reservation_create.escrow_information and reservation_create.escrow_information.details):
            payment[&#34;free&#34;] = True
        else:
            payment[&#34;wallet&#34;] = wallet

    resv_id = reservation_create.reservation_id
    if payment[&#34;wallet&#34;]:
        j.sals.zos.get().billing.payout_farmers(payment[&#34;wallet&#34;], reservation_create)
        self.wait_payment(bot, resv_id, threebot_app=False)
    elif not payment[&#34;free&#34;]:
        self.wait_payment(bot, resv_id, threebot_app=True, reservation_create_resp=reservation_create)

    self.wait_reservation(bot, resv_id)
    if payment_obj:
        payment_obj.save()
    return resv_id</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.reservation_chatflow.reservation_chatflow.ReservationChatflow.register_reservation"><code class="name flex">
<span>def <span class="ident">register_reservation</span></span>(<span>self, reservation, expiration, customer_tid, expiration_provisioning=1000, currency=None, bot=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Register any reservation through the chatflow.
This reservation could include anything such as a new network, container, kubernetes cluster, or zdb.
It returns the reservation id of the registered reservation.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>reservation</code></strong> :&ensp;<code>jumpscale.clients.explorer.models.TfgridWorkloadsReservation1</code></dt>
<dd>reservation object</dd>
<dt><strong><code>expiration</code></strong> :&ensp;<code>int</code></dt>
<dd>epoch time when the reservation should be canceled automaticly</dd>
<dt><strong><code>customer_tid</code></strong> :&ensp;<code>int</code></dt>
<dd>Id of the customer making the reservation</dd>
<dt><strong><code>expiration_provisioning</code></strong> :&ensp;<code>int</code></dt>
<dd>timeout on the deployment of the provisioning in seconds</dd>
<dt><strong><code>currency</code></strong> :&ensp;<code>str</code></dt>
<dd>"TFT" of "FreeTFT"</dd>
<dt><strong><code>bot</code></strong> :&ensp;<code>GedisChatBot</code></dt>
<dd>bot instance</dd>
</dl>
<h2 id="return">Return</h2>
<p>[jumpscale.clients.explorer.models.TfgridWorkloadsReservation1]: reservation create object</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def register_reservation(
    self, reservation, expiration, customer_tid, expiration_provisioning=1000, currency=None, bot=None
):
    &#34;&#34;&#34;Register any reservation through the chatflow.
    This reservation could include anything such as a new network, container, kubernetes cluster, or zdb.
    It returns the reservation id of the registered reservation.

    Args:
        reservation (jumpscale.clients.explorer.models.TfgridWorkloadsReservation1): reservation object
        expiration (int): epoch time when the reservation should be canceled automaticly
        customer_tid (int): Id of the customer making the reservation
        expiration_provisioning (int): timeout on the deployment of the provisioning in seconds
        currency (str): &#34;TFT&#34; of &#34;FreeTFT&#34;
        bot (GedisChatBot): bot instance

    Return:
        [jumpscale.clients.explorer.models.TfgridWorkloadsReservation1]: reservation create object

    &#34;&#34;&#34;
    expiration_provisioning += j.data.time.get().timestamp
    try:
        reservation_create = j.sals.zos.get().reservation_register(
            reservation,
            expiration,
            expiration_provisioning=expiration_provisioning,
            customer_tid=customer_tid,
            currencies=[currency],
        )
    except requests.HTTPError as e:
        try:
            msg = e.response.json()[&#34;error&#34;]
        except (KeyError, json.JSONDecodeError):
            msg = e.response.text
        raise StopChatFlow(f&#34;The following error occured: {msg}&#34;)

    rid = reservation_create.reservation_id
    reservation.id = rid

    # TODO: FIXME TO SET DEPLOYER in config
    if j.core.config.get_config().get(&#34;DEPLOYER&#34;) and customer_tid:
        # create a new object from deployed_reservation with the reservation and the tid
        explorer_name = self._explorer.url.split(&#34;.&#34;)[1]
        deployed_reservation = self.deployed_reservations.get(f&#34;{explorer_name}_{rid}&#34;)
        deployed_reservation.reservation_id = rid
        deployed_reservation.customer_tid = customer_tid
        deployed_reservation.save()
    return reservation_create</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.reservation_chatflow.reservation_chatflow.ReservationChatflow.save_reservation"><code class="name flex">
<span>def <span class="ident">save_reservation</span></span>(<span>self, rid, name, solution_type, form_info=None)</span>
</code></dt>
<dd>
<section class="desc"><p>save user reservation in local config manager</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>rid</code></strong> :&ensp;<code>int</code></dt>
<dd>user identity (j.core.identity.me.tid)</dd>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>reservation name</dd>
<dt><strong><code>solution_type</code></strong> :&ensp;<code>SolutionType</code></dt>
<dd>type of the solution from types enum</dd>
<dt><strong><code>form_info</code></strong> :&ensp;<code>dict</code>, optional</dt>
<dd>reservation user info. Defaults to None.</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def save_reservation(self, rid, name, solution_type, form_info=None):
    &#34;&#34;&#34;save user reservation in local config manager

    Args:
        rid (int): user identity (j.core.identity.me.tid)
        name (str): reservation name
        solution_type (SolutionType): type of the solution from types enum
        form_info (dict, optional): reservation user info. Defaults to None.
    &#34;&#34;&#34;
    form_info = form_info or {}
    explorer_name = self._explorer.url.split(&#34;.&#34;)[1]
    reservation = self.solutions.get(f&#34;{explorer_name}_{rid}&#34;)
    reservation.rid = rid
    reservation.name = name
    reservation.solution_type = solution_type
    reservation.form_info = form_info
    reservation.explorer = self._explorer.url
    reservation.save()</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.reservation_chatflow.reservation_chatflow.ReservationChatflow.select_farms"><code class="name flex">
<span>def <span class="ident">select_farms</span></span>(<span>self, bot, message=None, currency=None, retry=False, sru=None, cru=None, hru=None, mru=None)</span>
</code></dt>
<dd>
<section class="desc"><p>prompt user to select farm to deploy on</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>bot</code></strong> :&ensp;<code>GedisChatBot</code></dt>
<dd>bot instance</dd>
<dt><strong><code>message</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>bot screen message. Defaults to None.</dd>
<dt><strong><code>currency</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>wanted currency to deal with. Defaults to None.</dd>
<dt><strong><code>retry</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>retry if failed. Defaults to False.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>farm</code> <code>object</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def select_farms(self, bot, message=None, currency=None, retry=False, sru=None, cru=None, hru=None, mru=None):
    &#34;&#34;&#34;prompt user to select farm to deploy on

    Args:
        bot (GedisChatBot): bot instance
        message (str, optional): bot screen message. Defaults to None.
        currency (str, optional): wanted currency to deal with. Defaults to None.
        retry (bool, optional): retry if failed. Defaults to False.

    Returns:
        farm object
    &#34;&#34;&#34;
    message = message or &#34;Select 1 or more farms to distribute nodes on&#34;
    farms = self._explorer.farms.list()
    farm_names = []
    for f in farms:
        if j.sals.zos.get().nodes_finder.filter_farm_currency(f, currency) and self.check_farm_resources(
            farm_id=f.id, sru=sru, cru=cru, hru=hru, mru=mru, currency=currency
        ):
            farm_names.append(f.name)
    if not farm_names:
        bot.stop(&#34;No farms with available resources that match the specified.&#34;)
    farms_selected = bot.multi_list_choice(message, farm_names, retry=retry, auto_complete=True)
    return farms_selected</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.reservation_chatflow.reservation_chatflow.ReservationChatflow.select_gateway"><code class="name flex">
<span>def <span class="ident">select_gateway</span></span>(<span>self, bot, currency=None)</span>
</code></dt>
<dd>
<section class="desc"><p>prompt user about available gateways that supports passed currency</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>bot</code></strong> :&ensp;<code>GedisChatBot</code></dt>
<dd>bot instance</dd>
<dt><strong><code>currency</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>"TFT" or "FreeTFT". Defaults to None.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>[TfgridDirectoryGateway1]</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def select_gateway(self, bot, currency=None):
    &#34;&#34;&#34;prompt user about available gateways that supports passed currency

    Args:
        bot (GedisChatBot): bot instance
        currency (str, optional): &#34;TFT&#34; or &#34;FreeTFT&#34;. Defaults to None.

    Returns:
        [TfgridDirectoryGateway1]
    &#34;&#34;&#34;
    gateways = self.list_gateways(bot, currency)
    if not gateways:
        bot.stop(&#34;No available gateways&#34;)
    options = sorted(list(gateways.keys()))
    gateway = bot.drop_down_choice(&#34;Please choose a gateway&#34;, options, required=True)
    return gateways[gateway]</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.reservation_chatflow.reservation_chatflow.ReservationChatflow.select_network"><code class="name flex">
<span>def <span class="ident">select_network</span></span>(<span>self, bot, customer_tid)</span>
</code></dt>
<dd>
<section class="desc"><p>prompt user to select a specific network</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>bot</code></strong> :&ensp;<code>GedisChatBot</code></dt>
<dd>bot instance</dd>
<dt><strong><code>customer_tid</code></strong> :&ensp;<code>int</code></dt>
<dd>user tid</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><a title="jumpscale.sals.reservation_chatflow.reservation_chatflow.Network" href="#jumpscale.sals.reservation_chatflow.reservation_chatflow.Network"><code>Network</code></a> <code>object</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def select_network(self, bot, customer_tid):
    &#34;&#34;&#34;prompt user to select a specific network

    Args:
        bot (GedisChatBot): bot instance
        customer_tid (int): user tid

    Returns:
        Network object
    &#34;&#34;&#34;
    reservations = j.sals.zos.get().reservation_list(tid=customer_tid, next_action=&#34;DEPLOY&#34;)
    networks = self.list_networks(customer_tid, reservations)
    names = []
    for n in networks.keys():
        names.append(n)
    if not names:
        res = &#34;You don&#39;t have any networks, please use the network chatflow to create one&#34;
        res = j.tools.jinja2.render_template(template_text=res)
        bot.stop(res)
    while True:
        result = bot.single_choice(&#34;Choose a network&#34;, names, required=True)
        if result not in networks:
            continue
        network, expiration, currency, resv_id = networks[result]
        return Network(network, expiration, bot, reservations, currency, resv_id)</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.reservation_chatflow.reservation_chatflow.ReservationChatflow.show_escrow_qr"><code class="name flex">
<span>def <span class="ident">show_escrow_qr</span></span>(<span>self, bot, reservation_create_resp, expiration_provisioning)</span>
</code></dt>
<dd>
<section class="desc"><p>Show in chatflow the QR code with the details of the escrow information for payment</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def show_escrow_qr(self, bot, reservation_create_resp, expiration_provisioning):
    &#34;&#34;&#34;
    Show in chatflow the QR code with the details of the escrow information for payment
    &#34;&#34;&#34;
    escrow_info = j.sals.zos.get().reservation_escrow_information_with_qrcodes(reservation_create_resp)
    escrow_address = escrow_info[&#34;escrow_address&#34;]
    escrow_asset = escrow_info[&#34;escrow_asset&#34;]
    reservationid = escrow_info[&#34;reservationid&#34;]
    qrcode = escrow_info[&#34;qrcode&#34;]
    remaning_time = j.data.time.get(expiration_provisioning).humanize()
    payment_details = self.get_payment_details(escrow_info, escrow_asset.split(&#34;:&#34;)[0])

    message_text = f&#34;&#34;&#34;
    &lt;h3&gt;Make a Payment&lt;/h3&gt;
    Scan the QR code with your wallet (do not change the message) or enter the information below manually and proceed with the payment. Make sure to add the reservationid as memo_text.
    &lt;p&gt;If no payment is made {remaning_time} the reservation will be canceled&lt;/p&gt;

    &lt;h4&gt; Destination Wallet Address: &lt;/h4&gt;  {escrow_address} \n
    &lt;h4&gt; Currency: &lt;/h4&gt;  {escrow_asset} \n
    &lt;h4&gt; Reservation ID: &lt;/h4&gt;  {reservationid} \n
    &lt;h4&gt; Payment Details: &lt;/h4&gt; {payment_details} \n
    &#34;&#34;&#34;

    bot.qrcode_show(data=qrcode, msg=message_text, scale=4, update=True, html=True)</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.reservation_chatflow.reservation_chatflow.ReservationChatflow.show_payments"><code class="name flex">
<span>def <span class="ident">show_payments</span></span>(<span>self, bot, reservation_create_resp, currency)</span>
</code></dt>
<dd>
<section class="desc"><p>Show valid payment options in chatflow available. All available wallets possible are shown or usage of External wallet (QR code) is shown
where a QR code is viewed for the user to scan and continue with their payment</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>bot</code></strong> :&ensp;<code>GedisChatBot</code></dt>
<dd>instance of the used bot</dd>
<dt><strong><code>reservation_create_resp</code></strong> :&ensp;<code>jumpscale.clients.explorer.models.TfgridWorkloadsReservation1</code></dt>
<dd>result of reservation</dd>
<dt><strong><code>currency</code></strong> :&ensp;<code>str</code></dt>
<dd>currency used</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>[jumpscale.clients.explorer.models.TfgridSolutionsPayment1]: payment object wallet in case a wallet is used</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def show_payments(self, bot, reservation_create_resp, currency):
    &#34;&#34;&#34;Show valid payment options in chatflow available. All available wallets possible are shown or usage of External wallet (QR code) is shown
    where a QR code is viewed for the user to scan and continue with their payment

    Args:
        bot (GedisChatBot): instance of the used bot
        reservation_create_resp (jumpscale.clients.explorer.models.TfgridWorkloadsReservation1): result of reservation
        currency (str): currency used

    Returns:
        [jumpscale.clients.explorer.models.TfgridSolutionsPayment1]: payment object wallet in case a wallet is used
    &#34;&#34;&#34;
    payment = {&#34;wallet&#34;: None, &#34;free&#34;: False}
    if not (reservation_create_resp.escrow_information and reservation_create_resp.escrow_information.details):
        payment[&#34;free&#34;] = True
        return payment, None
    escrow_info = j.sals.zos.get().reservation_escrow_information_with_qrcodes(reservation_create_resp)

    escrow_address = escrow_info[&#34;escrow_address&#34;]
    escrow_asset = escrow_info[&#34;escrow_asset&#34;]
    total_amount = escrow_info[&#34;total_amount&#34;]
    rid = reservation_create_resp.reservation_id

    wallets = self.list_wallets()
    wallet_names = []
    for w in wallets.keys():
        wallet_names.append(w)
    wallet_names.append(&#34;External Wallet (QR Code)&#34;)

    payment_details = self.get_payment_details(escrow_info, currency)

    message = f&#34;&#34;&#34;
    Billing details:
    &lt;h4&gt; Destination Wallet address: &lt;/h4&gt;  {escrow_address} \n
    &lt;h4&gt; Currency: &lt;/h4&gt;  {escrow_asset} \n
    &lt;h4&gt; Payment Details: &lt;/h4&gt; {payment_details} \n
    &lt;h4&gt; Choose a wallet name to use for payment or proceed with the payment through an external wallet (QR Code) &lt;/h4&gt;
    &#34;&#34;&#34;
    retry = False
    while True:

        result = bot.single_choice(message, wallet_names, html=True, retry=retry)

        if result not in wallet_names:
            retry = True
            continue
        if result == &#34;External Wallet (QR Code)&#34;:
            reservation = self._explorer.reservations.get(rid)
            self.show_escrow_qr(bot, reservation_create_resp, reservation.data_reservation.expiration_provisioning)
            payment_obj = self.create_payment(
                rid=rid,
                currency=currency,
                escrow_address=escrow_address,
                escrow_asset=escrow_asset,
                total_amount=total_amount,
                payment_source=&#34;external_wallet&#34;,
                farmer_payments=escrow_info[&#34;farmer_payments&#34;],
            )
            return payment, payment_obj
        else:
            payment[&#34;wallet&#34;] = wallets[result]
            balances = payment[&#34;wallet&#34;].get_balance().balances
            current_balance = None
            for balance in balances:
                if balance.asset_code == currency:
                    current_balance = balance.balance
                    if float(current_balance) &gt;= total_amount:
                        payment_obj = self.create_payment(
                            rid=rid,
                            currency=currency,
                            escrow_address=escrow_address,
                            escrow_asset=escrow_asset,
                            total_amount=total_amount,
                            payment_source=result,
                            farmer_payments=escrow_info[&#34;farmer_payments&#34;],
                        )
                        return payment, payment_obj
            retry = True
            message = f&#34;&#34;&#34;
            &lt;h2 style=&#34;color: #142850;&#34;&gt;&lt;b style=&#34;color: #00909e;&#34;&gt;{total_amount} {currency}&lt;/b&gt; are required, but only &lt;b style=&#34;color: #00909e;&#34;&gt;{current_balance} {currency}&lt;/b&gt; are available in wallet &lt;b style=&#34;color: #00909e;&#34;&gt;{payment[&#34;wallet&#34;].name}&lt;/b&gt;&lt;/h2&gt;
            Billing details:
            &lt;h4&gt; Wallet address: &lt;/h4&gt;  {escrow_address} \n
            &lt;h4&gt; Currency: &lt;/h4&gt;  {escrow_asset} \n
            &lt;h4&gt; Payment details: &lt;/h4&gt; {payment_details} \n
            &lt;h4&gt; Choose a wallet name to use for payment or proceed with payment through External Wallet (QR Code) &lt;/h4&gt;
            &#34;&#34;&#34;</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.reservation_chatflow.reservation_chatflow.ReservationChatflow.unblock_node"><code class="name flex">
<span>def <span class="ident">unblock_node</span></span>(<span>self, node_id, reset=True)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def unblock_node(self, node_id, reset=True):
    node_key = f&#34;{NODES_DISALLOW_PREFIX}:{node_id}&#34;
    j.core.db.delete(node_key)
    if reset:
        j.core.db.hdel(NODES_COUNT_KEY, node_id)</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.reservation_chatflow.reservation_chatflow.ReservationChatflow.update_local_reservations"><code class="name flex">
<span>def <span class="ident">update_local_reservations</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>update local reserfvations with new ones</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def update_local_reservations(self):
    &#34;&#34;&#34;update local reserfvations with new ones&#34;&#34;&#34;
    for obj in self.solutions.list_all():
        self.solutions.delete(obj)
    reservations = self.get_solutions_explorer()
    for reservation in reservations:
        self.save_reservation(
            reservation[&#34;id&#34;], reservation[&#34;name&#34;], reservation[&#34;solution_type&#34;], form_info=reservation[&#34;form_info&#34;]
        )</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.reservation_chatflow.reservation_chatflow.ReservationChatflow.validate_node"><code class="name flex">
<span>def <span class="ident">validate_node</span></span>(<span>self, nodeid, query=None, currency=None)</span>
</code></dt>
<dd>
<section class="desc"><p>validate the node if it's ok to use and have enough resources</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>nodeid</code></strong> :&ensp;<code>str</code></dt>
<dd>node id</dd>
<dt><strong><code>query</code></strong> :&ensp;<code>dict</code>, optional</dt>
<dd>search paramas. Defaults to None.</dd>
<dt><strong><code>currency</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>wanted currency. Defaults to None.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Node</code> <code>object</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def validate_node(self, nodeid, query=None, currency=None):
    &#34;&#34;&#34;validate the node if it&#39;s ok to use and have enough resources

    Args:
        nodeid (str): node id
        query (dict, optional): search paramas. Defaults to None.
        currency (str, optional): wanted currency. Defaults to None.

    Returns:
        Node object
    &#34;&#34;&#34;
    try:
        node = self._explorer.nodes.get(nodeid)
    except requests.exceptions.HTTPError:
        raise j.exceptions.NotFound(f&#34;Node {nodeid} doesn&#39;t exists please enter a valid nodeid&#34;)
    if not j.sals.zos.get().nodes_finder.filter_is_up(node):
        raise j.exceptions.NotFound(f&#34;Node {nodeid} doesn&#39;t seem to be up please choose another nodeid&#34;)

    if currency:
        if currency == &#34;FreeTFT&#34; and not node.free_to_use:
            raise j.exceptions.Value(
                f&#34;The specified node ({nodeid}) should support the same type of currency as the network you are using ({currency})&#34;
            )
    if query:
        for unit, value in query.items():
            if unit == &#34;currency&#34;:
                continue
            freevalue = getattr(node.total_resources, unit) - getattr(node.used_resources, unit)
            if freevalue &lt; value:
                raise j.exceptions.Value(
                    f&#34;Node {nodeid} does not have enough available {unit} resources for this request {value} required {freevalue} available, please choose another one&#34;
                )
    return node</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.reservation_chatflow.reservation_chatflow.ReservationChatflow.validate_user"><code class="name flex">
<span>def <span class="ident">validate_user</span></span>(<span>self, user_info)</span>
</code></dt>
<dd>
<section class="desc"><p>validate user information data to authentication</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>user_info</code></strong> :&ensp;<code>dict</code></dt>
<dd>user information</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def validate_user(self, user_info):
    &#34;&#34;&#34;validate user information data to authentication

    Args:
        user_info (dict): user information
    &#34;&#34;&#34;
    if not j.core.config.get_config().get(&#34;threebot_connect&#34;, True):
        error_msg = &#34;&#34;&#34;
        This chatflow is not supported when 3Bot is in dev mode.
        To enable 3Bot connect : `j.core.config.set(&#39;threebot_connect&#39;, True)`
        &#34;&#34;&#34;
        raise j.exceptions.Runtime(error_msg)
    if not user_info[&#34;email&#34;]:
        raise j.exceptions.Value(&#34;Email shouldn&#39;t be empty&#34;)
    if not user_info[&#34;username&#34;]:
        raise j.exceptions.Value(&#34;Name of logged in user shouldn&#39;t be empty&#34;)
    return self._explorer.users.get(name=user_info[&#34;username&#34;], email=user_info[&#34;email&#34;])</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.reservation_chatflow.reservation_chatflow.ReservationChatflow.wait_payment"><code class="name flex">
<span>def <span class="ident">wait_payment</span></span>(<span>self, bot, rid, threebot_app=False, reservation_create_resp=None)</span>
</code></dt>
<dd>
<section class="desc"><p>wait slide untill payment is ready</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>bot</code></strong> :&ensp;<code>GedisChatBot</code></dt>
<dd>bot instance</dd>
<dt><strong><code>rid</code></strong> :&ensp;<code>int</code></dt>
<dd>customer tid</dd>
<dt><strong><code>threebot_app</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>is using threebot app payment. Defaults to False.</dd>
<dt><strong><code>reservation_create_resp</code></strong> :&ensp;<code>jumpscale.clients.explorer.models.TfgridWorkloadsReservation1</code>, optional</dt>
<dd>reservation object response. Defaults to None.</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def wait_payment(self, bot, rid, threebot_app=False, reservation_create_resp=None):
    &#34;&#34;&#34;wait slide untill payment is ready

    Args:
        bot (GedisChatBot): bot instance
        rid (int): customer tid
        threebot_app (bool, optional): is using threebot app payment. Defaults to False.
        reservation_create_resp (jumpscale.clients.explorer.models.TfgridWorkloadsReservation1, optional): reservation object response. Defaults to None.
    &#34;&#34;&#34;

    # wait to check payment is actually done next_action changed from:PAY
    def is_expired(reservation):
        return reservation.data_reservation.expiration_provisioning.timestamp() &lt; j.data.time.get().timestamp

    reservation = self._explorer.reservations.get(rid)
    while True:
        remaning_time = j.data.time.get(reservation.data_reservation.expiration_provisioning).humanize(
            granularity=[&#34;minute&#34;, &#34;second&#34;]
        )
        deploying_message = f&#34;&#34;&#34;\
        # Payment being processed...

        &lt;br /&gt;Deployment will be cancelled if payment is not successful {remaning_time}
        &#34;&#34;&#34;
        bot.md_show_update(dedent(deploying_message), md=True)
        if reservation.next_action != &#34;PAY&#34;:
            return
        if is_expired(reservation):
            res = f&#34;# Failed to wait for payment for reservation:```{reservation.id}```:\n&#34;
            for x in reservation.results:
                if x.state == &#34;ERROR&#34;:
                    res += f&#34;\n### {x.category}: ```{x.message}```\n&#34;
            link = f&#34;{self._explorer.url}/reservations/{reservation.id}&#34;
            res += f&#34;&lt;h2&gt; &lt;a href={link}&gt;Full reservation info&lt;/a&gt;&lt;/h2&gt;&#34;
            j.sals.zos.get().reservation_cancel(rid)
            bot.stop(res, md=True, html=True)
        if threebot_app and reservation_create_resp:
            self.show_escrow_qr(bot, reservation_create_resp, reservation.data_reservation.expiration_provisioning)
        time.sleep(5)
        reservation = self._explorer.reservations.get(rid)</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.reservation_chatflow.reservation_chatflow.ReservationChatflow.wait_reservation"><code class="name flex">
<span>def <span class="ident">wait_reservation</span></span>(<span>self, bot, rid)</span>
</code></dt>
<dd>
<section class="desc"><p>Wait for reservation results to be complete, have errors, or expire.
If there are errors then error message is previewed in the chatflow to the user and the chat is ended.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>bot</code></strong> :&ensp;<code>GedisChatBot</code></dt>
<dd>bot instance</dd>
<dt><strong><code>rid</code></strong> :&ensp;<code>int</code></dt>
<dd>user tid</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def wait_reservation(self, bot, rid):
    &#34;&#34;&#34;
    Wait for reservation results to be complete, have errors, or expire.
    If there are errors then error message is previewed in the chatflow to the user and the chat is ended.

    Args:
        bot (GedisChatBot): bot instance
        rid (int): user tid
    &#34;&#34;&#34;

    def is_finished(reservation):
        count = 0
        count += len(reservation.data_reservation.volumes)
        count += len(reservation.data_reservation.zdbs)
        count += len(reservation.data_reservation.containers)
        count += len(reservation.data_reservation.kubernetes)
        count += len(reservation.data_reservation.proxies)
        count += len(reservation.data_reservation.reverse_proxies)
        count += len(reservation.data_reservation.subdomains)
        count += len(reservation.data_reservation.domain_delegates)
        count += len(reservation.data_reservation.gateway4to6)
        for network in reservation.data_reservation.networks:
            count += len(network.network_resources)
        return len(reservation.results) &gt;= count

    def is_expired(reservation):
        &#34;&#34;&#34;[summary]

        Args:
            reservation (jumpscale.clients.explorer.models.TfgridWorkloadsReservation1): reservation object

        Returns:
            [bool]: True if the reservation is expired
        &#34;&#34;&#34;
        return reservation.data_reservation.expiration_provisioning.timestamp() &lt; j.data.time.get().timestamp

    reservation = self._explorer.reservations.get(rid)
    while True:
        remaning_time = j.data.time.get(reservation.data_reservation.expiration_provisioning).humanize(
            granularity=[&#34;minute&#34;, &#34;second&#34;]
        )
        deploying_message = f&#34;&#34;&#34;
        # Deploying...

        &lt;br /&gt;Deployment will be cancelled if it is not successful in {remaning_time}
        &#34;&#34;&#34;
        bot.md_show_update(dedent(deploying_message), md=True)
        self._reservation_failed(bot, reservation)

        if is_finished(reservation):
            if reservation.next_action != NextAction.DEPLOY:
                res = f&#34;# Sorry your reservation ```{reservation.id}``` failed to deploy\n&#34;
                for x in reservation.results:
                    if x.state == &#34;ERROR&#34;:
                        res += f&#34;\n### {x.category}: ```{x.message}```\n&#34;
                bot.stop(res, md=True, html=True)
            return reservation.results
        if is_expired(reservation):
            res = f&#34;# Sorry your reservation ```{reservation.id}``` failed to deploy in time:\n&#34;
            for x in reservation.results:
                if x.state == &#34;ERROR&#34;:
                    res += f&#34;\n### {x.category}: ```{x.message}```\n&#34;
            link = f&#34;{self._explorer.url}/reservations/{reservation.id}&#34;
            res += f&#34;&lt;h2&gt; &lt;a href={link}&gt;Full reservation info&lt;/a&gt;&lt;/h2&gt;&#34;
            j.sals.zos.get().reservation_cancel(rid)
            bot.stop(res, md=True, html=True)
        time.sleep(1)
        reservation = self._explorer.reservations.get(rid)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="jumpscale.sals.reservation_chatflow" href="index.html">jumpscale.sals.reservation_chatflow</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="jumpscale.sals.reservation_chatflow.reservation_chatflow.Network" href="#jumpscale.sals.reservation_chatflow.reservation_chatflow.Network">Network</a></code></h4>
<ul class="two-column">
<li><code><a title="jumpscale.sals.reservation_chatflow.reservation_chatflow.Network.add_node" href="#jumpscale.sals.reservation_chatflow.reservation_chatflow.Network.add_node">add_node</a></code></li>
<li><code><a title="jumpscale.sals.reservation_chatflow.reservation_chatflow.Network.ask_ip_from_node" href="#jumpscale.sals.reservation_chatflow.reservation_chatflow.Network.ask_ip_from_node">ask_ip_from_node</a></code></li>
<li><code><a title="jumpscale.sals.reservation_chatflow.reservation_chatflow.Network.copy" href="#jumpscale.sals.reservation_chatflow.reservation_chatflow.Network.copy">copy</a></code></li>
<li><code><a title="jumpscale.sals.reservation_chatflow.reservation_chatflow.Network.get_free_ip" href="#jumpscale.sals.reservation_chatflow.reservation_chatflow.Network.get_free_ip">get_free_ip</a></code></li>
<li><code><a title="jumpscale.sals.reservation_chatflow.reservation_chatflow.Network.get_node_range" href="#jumpscale.sals.reservation_chatflow.reservation_chatflow.Network.get_node_range">get_node_range</a></code></li>
<li><code><a title="jumpscale.sals.reservation_chatflow.reservation_chatflow.Network.update" href="#jumpscale.sals.reservation_chatflow.reservation_chatflow.Network.update">update</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="jumpscale.sals.reservation_chatflow.reservation_chatflow.ReservationChatflow" href="#jumpscale.sals.reservation_chatflow.reservation_chatflow.ReservationChatflow">ReservationChatflow</a></code></h4>
<ul class="">
<li><code><a title="jumpscale.sals.reservation_chatflow.reservation_chatflow.ReservationChatflow.add_reservation_metadata" href="#jumpscale.sals.reservation_chatflow.reservation_chatflow.ReservationChatflow.add_reservation_metadata">add_reservation_metadata</a></code></li>
<li><code><a title="jumpscale.sals.reservation_chatflow.reservation_chatflow.ReservationChatflow.block_node" href="#jumpscale.sals.reservation_chatflow.reservation_chatflow.ReservationChatflow.block_node">block_node</a></code></li>
<li><code><a title="jumpscale.sals.reservation_chatflow.reservation_chatflow.ReservationChatflow.cancel_solution_reservation" href="#jumpscale.sals.reservation_chatflow.reservation_chatflow.ReservationChatflow.cancel_solution_reservation">cancel_solution_reservation</a></code></li>
<li><code><a title="jumpscale.sals.reservation_chatflow.reservation_chatflow.ReservationChatflow.check_farm_resources" href="#jumpscale.sals.reservation_chatflow.reservation_chatflow.ReservationChatflow.check_farm_resources">check_farm_resources</a></code></li>
<li><code><a title="jumpscale.sals.reservation_chatflow.reservation_chatflow.ReservationChatflow.check_farms" href="#jumpscale.sals.reservation_chatflow.reservation_chatflow.ReservationChatflow.check_farms">check_farms</a></code></li>
<li><code><a title="jumpscale.sals.reservation_chatflow.reservation_chatflow.ReservationChatflow.check_solution_type" href="#jumpscale.sals.reservation_chatflow.reservation_chatflow.ReservationChatflow.check_solution_type">check_solution_type</a></code></li>
<li><code><a title="jumpscale.sals.reservation_chatflow.reservation_chatflow.ReservationChatflow.clear_blocked_nodes" href="#jumpscale.sals.reservation_chatflow.reservation_chatflow.ReservationChatflow.clear_blocked_nodes">clear_blocked_nodes</a></code></li>
<li><code><a title="jumpscale.sals.reservation_chatflow.reservation_chatflow.ReservationChatflow.create_network" href="#jumpscale.sals.reservation_chatflow.reservation_chatflow.ReservationChatflow.create_network">create_network</a></code></li>
<li><code><a title="jumpscale.sals.reservation_chatflow.reservation_chatflow.ReservationChatflow.create_payment" href="#jumpscale.sals.reservation_chatflow.reservation_chatflow.ReservationChatflow.create_payment">create_payment</a></code></li>
<li><code><a title="jumpscale.sals.reservation_chatflow.reservation_chatflow.ReservationChatflow.decrypt_reservation_metadata" href="#jumpscale.sals.reservation_chatflow.reservation_chatflow.ReservationChatflow.decrypt_reservation_metadata">decrypt_reservation_metadata</a></code></li>
<li><code><a title="jumpscale.sals.reservation_chatflow.reservation_chatflow.ReservationChatflow.filter_nodes" href="#jumpscale.sals.reservation_chatflow.reservation_chatflow.ReservationChatflow.filter_nodes">filter_nodes</a></code></li>
<li><code><a title="jumpscale.sals.reservation_chatflow.reservation_chatflow.ReservationChatflow.get_currency" href="#jumpscale.sals.reservation_chatflow.reservation_chatflow.ReservationChatflow.get_currency">get_currency</a></code></li>
<li><code><a title="jumpscale.sals.reservation_chatflow.reservation_chatflow.ReservationChatflow.get_farm_names" href="#jumpscale.sals.reservation_chatflow.reservation_chatflow.ReservationChatflow.get_farm_names">get_farm_names</a></code></li>
<li><code><a title="jumpscale.sals.reservation_chatflow.reservation_chatflow.ReservationChatflow.get_ip_range" href="#jumpscale.sals.reservation_chatflow.reservation_chatflow.ReservationChatflow.get_ip_range">get_ip_range</a></code></li>
<li><code><a title="jumpscale.sals.reservation_chatflow.reservation_chatflow.ReservationChatflow.get_kube_network_ip" href="#jumpscale.sals.reservation_chatflow.reservation_chatflow.ReservationChatflow.get_kube_network_ip">get_kube_network_ip</a></code></li>
<li><code><a title="jumpscale.sals.reservation_chatflow.reservation_chatflow.ReservationChatflow.get_network" href="#jumpscale.sals.reservation_chatflow.reservation_chatflow.ReservationChatflow.get_network">get_network</a></code></li>
<li><code><a title="jumpscale.sals.reservation_chatflow.reservation_chatflow.ReservationChatflow.get_nodes" href="#jumpscale.sals.reservation_chatflow.reservation_chatflow.ReservationChatflow.get_nodes">get_nodes</a></code></li>
<li><code><a title="jumpscale.sals.reservation_chatflow.reservation_chatflow.ReservationChatflow.get_payment_details" href="#jumpscale.sals.reservation_chatflow.reservation_chatflow.ReservationChatflow.get_payment_details">get_payment_details</a></code></li>
<li><code><a title="jumpscale.sals.reservation_chatflow.reservation_chatflow.ReservationChatflow.get_solution_domain_delegates_info" href="#jumpscale.sals.reservation_chatflow.reservation_chatflow.ReservationChatflow.get_solution_domain_delegates_info">get_solution_domain_delegates_info</a></code></li>
<li><code><a title="jumpscale.sals.reservation_chatflow.reservation_chatflow.ReservationChatflow.get_solution_exposed_info" href="#jumpscale.sals.reservation_chatflow.reservation_chatflow.ReservationChatflow.get_solution_exposed_info">get_solution_exposed_info</a></code></li>
<li><code><a title="jumpscale.sals.reservation_chatflow.reservation_chatflow.ReservationChatflow.get_solution_flist_info" href="#jumpscale.sals.reservation_chatflow.reservation_chatflow.ReservationChatflow.get_solution_flist_info">get_solution_flist_info</a></code></li>
<li><code><a title="jumpscale.sals.reservation_chatflow.reservation_chatflow.ReservationChatflow.get_solution_metadata" href="#jumpscale.sals.reservation_chatflow.reservation_chatflow.ReservationChatflow.get_solution_metadata">get_solution_metadata</a></code></li>
<li><code><a title="jumpscale.sals.reservation_chatflow.reservation_chatflow.ReservationChatflow.get_solution_ubuntu_info" href="#jumpscale.sals.reservation_chatflow.reservation_chatflow.ReservationChatflow.get_solution_ubuntu_info">get_solution_ubuntu_info</a></code></li>
<li><code><a title="jumpscale.sals.reservation_chatflow.reservation_chatflow.ReservationChatflow.get_solutions" href="#jumpscale.sals.reservation_chatflow.reservation_chatflow.ReservationChatflow.get_solutions">get_solutions</a></code></li>
<li><code><a title="jumpscale.sals.reservation_chatflow.reservation_chatflow.ReservationChatflow.get_solutions_explorer" href="#jumpscale.sals.reservation_chatflow.reservation_chatflow.ReservationChatflow.get_solutions_explorer">get_solutions_explorer</a></code></li>
<li><code><a title="jumpscale.sals.reservation_chatflow.reservation_chatflow.ReservationChatflow.list_blocked_nodes" href="#jumpscale.sals.reservation_chatflow.reservation_chatflow.ReservationChatflow.list_blocked_nodes">list_blocked_nodes</a></code></li>
<li><code><a title="jumpscale.sals.reservation_chatflow.reservation_chatflow.ReservationChatflow.list_delegate_domains" href="#jumpscale.sals.reservation_chatflow.reservation_chatflow.ReservationChatflow.list_delegate_domains">list_delegate_domains</a></code></li>
<li><code><a title="jumpscale.sals.reservation_chatflow.reservation_chatflow.ReservationChatflow.list_gateways" href="#jumpscale.sals.reservation_chatflow.reservation_chatflow.ReservationChatflow.list_gateways">list_gateways</a></code></li>
<li><code><a title="jumpscale.sals.reservation_chatflow.reservation_chatflow.ReservationChatflow.list_networks" href="#jumpscale.sals.reservation_chatflow.reservation_chatflow.ReservationChatflow.list_networks">list_networks</a></code></li>
<li><code><a title="jumpscale.sals.reservation_chatflow.reservation_chatflow.ReservationChatflow.list_wallets" href="#jumpscale.sals.reservation_chatflow.reservation_chatflow.ReservationChatflow.list_wallets">list_wallets</a></code></li>
<li><code><a title="jumpscale.sals.reservation_chatflow.reservation_chatflow.ReservationChatflow.me" href="#jumpscale.sals.reservation_chatflow.reservation_chatflow.ReservationChatflow.me">me</a></code></li>
<li><code><a title="jumpscale.sals.reservation_chatflow.reservation_chatflow.ReservationChatflow.register_and_pay_reservation" href="#jumpscale.sals.reservation_chatflow.reservation_chatflow.ReservationChatflow.register_and_pay_reservation">register_and_pay_reservation</a></code></li>
<li><code><a title="jumpscale.sals.reservation_chatflow.reservation_chatflow.ReservationChatflow.register_reservation" href="#jumpscale.sals.reservation_chatflow.reservation_chatflow.ReservationChatflow.register_reservation">register_reservation</a></code></li>
<li><code><a title="jumpscale.sals.reservation_chatflow.reservation_chatflow.ReservationChatflow.save_reservation" href="#jumpscale.sals.reservation_chatflow.reservation_chatflow.ReservationChatflow.save_reservation">save_reservation</a></code></li>
<li><code><a title="jumpscale.sals.reservation_chatflow.reservation_chatflow.ReservationChatflow.select_farms" href="#jumpscale.sals.reservation_chatflow.reservation_chatflow.ReservationChatflow.select_farms">select_farms</a></code></li>
<li><code><a title="jumpscale.sals.reservation_chatflow.reservation_chatflow.ReservationChatflow.select_gateway" href="#jumpscale.sals.reservation_chatflow.reservation_chatflow.ReservationChatflow.select_gateway">select_gateway</a></code></li>
<li><code><a title="jumpscale.sals.reservation_chatflow.reservation_chatflow.ReservationChatflow.select_network" href="#jumpscale.sals.reservation_chatflow.reservation_chatflow.ReservationChatflow.select_network">select_network</a></code></li>
<li><code><a title="jumpscale.sals.reservation_chatflow.reservation_chatflow.ReservationChatflow.show_escrow_qr" href="#jumpscale.sals.reservation_chatflow.reservation_chatflow.ReservationChatflow.show_escrow_qr">show_escrow_qr</a></code></li>
<li><code><a title="jumpscale.sals.reservation_chatflow.reservation_chatflow.ReservationChatflow.show_payments" href="#jumpscale.sals.reservation_chatflow.reservation_chatflow.ReservationChatflow.show_payments">show_payments</a></code></li>
<li><code><a title="jumpscale.sals.reservation_chatflow.reservation_chatflow.ReservationChatflow.unblock_node" href="#jumpscale.sals.reservation_chatflow.reservation_chatflow.ReservationChatflow.unblock_node">unblock_node</a></code></li>
<li><code><a title="jumpscale.sals.reservation_chatflow.reservation_chatflow.ReservationChatflow.update_local_reservations" href="#jumpscale.sals.reservation_chatflow.reservation_chatflow.ReservationChatflow.update_local_reservations">update_local_reservations</a></code></li>
<li><code><a title="jumpscale.sals.reservation_chatflow.reservation_chatflow.ReservationChatflow.validate_node" href="#jumpscale.sals.reservation_chatflow.reservation_chatflow.ReservationChatflow.validate_node">validate_node</a></code></li>
<li><code><a title="jumpscale.sals.reservation_chatflow.reservation_chatflow.ReservationChatflow.validate_user" href="#jumpscale.sals.reservation_chatflow.reservation_chatflow.ReservationChatflow.validate_user">validate_user</a></code></li>
<li><code><a title="jumpscale.sals.reservation_chatflow.reservation_chatflow.ReservationChatflow.wait_payment" href="#jumpscale.sals.reservation_chatflow.reservation_chatflow.ReservationChatflow.wait_payment">wait_payment</a></code></li>
<li><code><a title="jumpscale.sals.reservation_chatflow.reservation_chatflow.ReservationChatflow.wait_reservation" href="#jumpscale.sals.reservation_chatflow.reservation_chatflow.ReservationChatflow.wait_reservation">wait_reservation</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.6.4</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>
