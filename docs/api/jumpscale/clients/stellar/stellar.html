<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.6.4" />
<title>jumpscale.clients.stellar.stellar API documentation</title>
<meta name="description" content="" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase;cursor:pointer}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>jumpscale.clients.stellar.stellar</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>Source code</summary>
<pre><code class="python">import math
import base64
import time
from enum import Enum
import decimal
from urllib import parse
from urllib.parse import urlparse
from typing import Union

import stellar_sdk
from jumpscale.clients.base import Client
from jumpscale.core.base import fields
from jumpscale.loader import j
from stellar_sdk import Asset, TransactionBuilder

from .wrapped import Account, Server
from .balance import AccountBalances, Balance, EscrowAccount
from .transaction import Effect, PaymentSummary, TransactionSummary
from .exceptions import UnAuthorized


_THREEFOLDFOUNDATION_TFTSTELLAR_SERVICES = {&#34;TEST&#34;: &#34;testnet.threefold.io&#34;, &#34;STD&#34;: &#34;tokenservices.threefold.io&#34;}
_HORIZON_NETWORKS = {&#34;TEST&#34;: &#34;https://horizon-testnet.stellar.org&#34;, &#34;STD&#34;: &#34;https://horizon.stellar.org&#34;}
_NETWORK_PASSPHRASES = {
    &#34;TEST&#34;: stellar_sdk.Network.TESTNET_NETWORK_PASSPHRASE,
    &#34;STD&#34;: stellar_sdk.Network.PUBLIC_NETWORK_PASSPHRASE,
}
_NETWORK_KNOWN_TRUSTS = {
    &#34;TEST&#34;: {
        &#34;TFT&#34;: &#34;GA47YZA3PKFUZMPLQ3B5F2E3CJIB57TGGU7SPCQT2WAEYKN766PWIMB3&#34;,
        &#34;FreeTFT&#34;: &#34;GBLDUINEFYTF7XEE7YNWA3JQS4K2VD37YU7I2YAE7R5AHZDKQXSS2J6R&#34;,
        &#34;TFTA&#34;: &#34;GB55A4RR4G2MIORJTQA4L6FENZU7K4W7ATGY6YOT2CW47M5SZYGYKSCT&#34;,
    },
    &#34;STD&#34;: {
        &#34;TFT&#34;: &#34;GBOVQKJYHXRR3DX6NOX2RRYFRCUMSADGDESTDNBDS6CDVLGVESRTAC47&#34;,
        &#34;FreeTFT&#34;: &#34;GCBGS5TFE2BPPUVY55ZPEMWWGR6CLQ7T6P46SOFGHXEBJ34MSP6HVEUT&#34;,
        &#34;TFTA&#34;: &#34;GBUT4GP5GJ6B3XW5PXENHQA7TXJI5GOPW3NF4W3ZIW6OOO4ISY6WNLN2&#34;,
    },
}
_THREEFOLDFOUNDATION_TFTSTELLAR_ENDPOINT = {
    &#34;FUND&#34;: &#34;/threefoldfoundation/transactionfunding_service/fund_transaction&#34;,
    &#34;CREATE_UNLOCK&#34;: &#34;/threefoldfoundation/unlock_service/create_unlockhash_transaction&#34;,
    &#34;GET_UNLOCK&#34;: &#34;/threefoldfoundation/unlock_service/get_unlockhash_transaction&#34;,
    &#34;CREATE_ACTIVATION_CODE&#34;: &#34;/threefoldfoundation/activation_service/create_activation_code&#34;,
    &#34;ACTIVATE_ACCOUNT&#34;: &#34;/threefoldfoundation/activation_service/activate_account&#34;,
}


class Network(Enum):
    STD = &#34;STD&#34;
    TEST = &#34;TEST&#34;


class Stellar(Client):
    network = fields.Enum(Network)
    address = fields.String()

    def secret_updated(self, value):
        self.address = stellar_sdk.Keypair.from_secret(value).public_key

    secret = fields.String(on_update=secret_updated)

    def _get_horizon_server(self):
        server_url = _HORIZON_NETWORKS[self.network.value]
        server = Server(horizon_url=server_url)
        return server

    def _get_free_balances(self, address=None):
        address = address or self.address
        balances = AccountBalances(address)
        response = self._get_horizon_server().accounts().account_id(address).call()
        for response_balance in response[&#34;balances&#34;]:
            balances.add_balance(Balance.from_horizon_response(response_balance))
        return balances

    def load_account(self):
        horizonServer = self._get_horizon_server()
        saccount = horizonServer.load_account(self.address)
        account = Account(saccount.account_id, saccount.sequence, self)
        return account

    def _get_url(self, endpoint):
        url = _THREEFOLDFOUNDATION_TFTSTELLAR_SERVICES[self.network.value]
        if not j.sals.nettools.wait_connection_test(url, 443, 5):
            raise j.exceptions.Timeout(f&#34;Can not connect to server {url}, connection timeout&#34;)
        endpoint = _THREEFOLDFOUNDATION_TFTSTELLAR_ENDPOINT[endpoint]
        return f&#34;https://{url}{endpoint}&#34;

    def _fund_transaction(self, transaction):
        data = {&#34;transaction&#34;: transaction}
        resp = j.tools.http.post(self._get_url(&#34;FUND&#34;), json={&#34;args&#34;: data})
        resp.raise_for_status()
        return resp.json()

    def _create_unlockhash_transaction(self, unlock_hash, transaction_xdr):
        data = {&#34;unlockhash&#34;: unlock_hash, &#34;transaction_xdr&#34;: transaction_xdr}
        resp = j.tools.http.post(self._get_url(&#34;CREATE_UNLOCK&#34;), json={&#34;args&#34;: data})
        resp.raise_for_status()
        return resp.json()

    def _get_unlockhash_transaction(self, unlockhash):
        data = {&#34;unlockhash&#34;: unlockhash}
        resp = j.tools.http.post(self._get_url(&#34;GET_UNLOCK&#34;), json={&#34;args&#34;: data})
        resp.raise_for_status()
        return resp.json()

    def _create_activation_code(self):
        data = {&#34;address&#34;: self.address}
        resp = j.tools.http.post(self._get_url(&#34;CREATE_ACTIVATION_CODE&#34;), json={&#34;args&#34;: data})
        resp.raise_for_status()
        return resp.json()

    def _activation_account(self, activation_code):
        data = {&#34;activation_code&#34;: activation_code}
        resp = j.tools.http.post(self._get_url(&#34;ACTIVATE_ACCOUNT&#34;), json={&#34;args&#34;: data})
        resp.raise_for_status()
        return resp.json()

    def set_unlock_transaction(self, unlock_transaction):
        &#34;&#34;&#34;
        Adds a xdr encoded unlocktransaction
        :param unlock_transaction: xdr encoded unlocktransactionaddress of the destination.
        :type destination_address: str
        &#34;&#34;&#34;
        txe = stellar_sdk.TransactionEnvelope.from_xdr(unlock_transaction, _NETWORK_PASSPHRASES[self.network.value])
        tx_hash = txe.hash()
        unlock_hash = stellar_sdk.strkey.StrKey.encode_pre_auth_tx(tx_hash)

        self._create_unlockhash_transaction(unlock_hash=unlock_hash, transaction_xdr=txe.to_xdr())

    def get_balance(self, address=None):
        &#34;&#34;&#34;Gets balance for a stellar address
        &#34;&#34;&#34;
        if address is None:
            address = self.address
        all_balances = self._get_free_balances(address)
        for account in self._find_escrow_accounts(address):
            all_balances.add_escrow_account(account)
        return all_balances

    def _find_escrow_accounts(self, address=None):
        if address is None:
            address = self.address
        escrow_accounts = []
        accounts_endpoint = self._get_horizon_server().accounts()
        accounts_endpoint.signer(address)
        old_cursor = &#34;old&#34;
        new_cursor = &#34;&#34;
        while new_cursor != old_cursor:
            old_cursor = new_cursor
            accounts_endpoint.cursor(new_cursor)
            response = accounts_endpoint.call()
            next_link = response[&#34;_links&#34;][&#34;next&#34;][&#34;href&#34;]
            next_link_query = parse.urlsplit(next_link).query
            new_cursor = parse.parse_qs(next_link_query)[&#34;cursor&#34;][0]
            accounts = response[&#34;_embedded&#34;][&#34;records&#34;]
            for account in accounts:
                account_id = account[&#34;account_id&#34;]
                if account_id == address:
                    continue  # Do not take the receiver&#39;s account
                all_signers = account[&#34;signers&#34;]
                preauth_signers = [signer[&#34;key&#34;] for signer in all_signers if signer[&#34;type&#34;] == &#34;preauth_tx&#34;]
                # TODO check the tresholds and signers
                # TODO if we can merge, the amount is unlocked ( if len(preauth_signers))==0
                balances = []
                for response_balance in account[&#34;balances&#34;]:
                    balances.append(Balance.from_horizon_response(response_balance))

                escrow_account = EscrowAccount(
                    account_id,
                    preauth_signers,
                    balances,
                    _NETWORK_PASSPHRASES[self.network.value],
                    self._get_unlockhash_transaction,
                )
                escrow_accounts.append(escrow_account)
        return escrow_accounts

    def claim_locked_funds(self):
        balances = self.get_balance()
        for locked_account in balances.escrow_accounts:
            if locked_account.can_be_unlocked():
                self._unlock_account(locked_account)

    def _unlock_account(self, escrow_account):
        submitted_unlock_transactions = 0
        for unlockhash in escrow_account.unlockhashes:
            unlockhash_transation = self._get_unlockhash_transaction(unlockhash=unlockhash)
            if unlockhash_transation is None:
                return
            j.logger.info(unlockhash_transation[&#34;transaction_xdr&#34;])
            self._get_horizon_server().submit_transaction(unlockhash_transation[&#34;transaction_xdr&#34;])
            submitted_unlock_transactions += 1

        if submitted_unlock_transactions == len(escrow_account.unlockhashes):
            self._merge_account(escrow_account.address)

    def _merge_account(self, address):
        server = self._get_horizon_server()
        account = server.load_account(address)
        # Increment the sequence number in case the unlock transaction was not processed before the load_account call
        # account.increment_sequence_number()
        balances = self._get_free_balances(address)
        base_fee = server.fetch_base_fee()
        transaction_builder = stellar_sdk.TransactionBuilder(
            source_account=account, network_passphrase=_NETWORK_PASSPHRASES[self.network.value], base_fee=base_fee
        )
        for balance in balances.balances:
            if balance.is_native():
                continue
            # Step 1: Transfer custom assets
            transaction_builder.append_payment_op(
                destination=self.address,
                amount=balance.balance,
                asset_code=balance.asset_code,
                asset_issuer=balance.asset_issuer,
            )
            # Step 2: Delete trustlines
            transaction_builder.append_change_trust_op(
                asset_issuer=balance.asset_issuer, asset_code=balance.asset_code, limit=&#34;0&#34;
            )
        # Step 3: Merge account
        transaction_builder.append_account_merge_op(self.address)

        transaction_builder.set_timeout(30)
        transaction = transaction_builder.build()
        signer_kp = stellar_sdk.Keypair.from_secret(self.secret)
        transaction.sign(signer_kp)
        server.submit_transaction(transaction)

    def activate_through_friendbot(self):
        &#34;&#34;&#34;Activates and funds a testnet account using riendbot
        &#34;&#34;&#34;
        if self.network.value != &#34;TEST&#34;:
            raise Exception(&#34;Account activation through friendbot is only available on testnet&#34;)

        resp = j.tools.http.get(&#34;https://friendbot.stellar.org/&#34;, params={&#34;addr&#34;: self.address})
        resp.raise_for_status()
        j.logger.info(f&#34;account with address {self.address} activated and  funded through friendbot&#34;)

    def activate_through_threefold_service(self):
        &#34;&#34;&#34;
        Activate your weallet through threefold services
        &#34;&#34;&#34;
        activationdata = self._create_activation_code()
        self._activation_account(activationdata[&#34;activation_code&#34;])

    def activate_account(self, destination_address, starting_balance=&#34;12.50&#34;):
        &#34;&#34;&#34;Activates another account

        Args:
            destination_address (str): address of the destination
            starting_balance (str, optional): the balance that the destination address will start with. Must be a positive integer expressed as a string. Defaults to &#34;12.50&#34;.
        &#34;&#34;&#34;
        server = self._get_horizon_server()
        source_keypair = stellar_sdk.Keypair.from_secret(self.secret)

        source_account = self.load_account()

        base_fee = server.fetch_base_fee()
        transaction = (
            stellar_sdk.TransactionBuilder(
                source_account=source_account,
                network_passphrase=_NETWORK_PASSPHRASES[self.network.value],
                base_fee=base_fee,
            )
            .append_create_account_op(destination=destination_address, starting_balance=starting_balance)
            .build()
        )
        transaction.sign(source_keypair)
        try:
            response = server.submit_transaction(transaction)
            j.logger.info(&#34;Transaction hash: {}&#34;.format(response[&#34;hash&#34;]))
        except stellar_sdk.exceptions.BadRequestError as e:
            j.logger.debug(e)

    def add_trustline(self, asset_code, issuer, secret=None):
        &#34;&#34;&#34;Create a trustline to an asset

        Args:
            asset_code (str): code of the asset. For example: &#39;BTC&#39;, &#39;TFT&#39;, ...
            issuer (str): address of the asset issuer
            secret (str, optional): Secret to use will use instance property if empty. Defaults to None.
        &#34;&#34;&#34;
        self._change_trustline(asset_code, issuer, secret=secret)

    def add_known_trustline(self, asset_code):
        &#34;&#34;&#34;Will add a trustline known by threefold for chosen asset_code

        Args:
            asset_code (str): code of the asset. For example: &#39;BTC&#39;, &#39;TFT&#39;, ...
        &#34;&#34;&#34;
        issuer = _NETWORK_KNOWN_TRUSTS.get(self.network.value, {}).get(asset_code)
        if not issuer:
            raise j.exceptions.NotFound(f&#34;We do not provide a known issuers for {asset_code} on network {self.network}&#34;)
        self._change_trustline(asset_code, issuer)

    def delete_trustline(self, asset_code, issuer, secret=None):
        &#34;&#34;&#34;Deletes a trustline

        Args:
            asset_code (str): code of the asset. For example: &#39;BTC&#39;, &#39;XRP&#39;, ...
            issuer (str): address of the asset issuer
            secret (str, optional): Secret to use will use instance property if empty. Defaults to None.
        &#34;&#34;&#34;
        self._change_trustline(asset_code, issuer, limit=&#34;0&#34;, secret=secret)

    def _change_trustline(self, asset_code, issuer, limit=None, secret=None):
        &#34;&#34;&#34;Create a trustline between you and the issuer of an asset

        Args:
            asset_code (str): code which form the asset. For example: &#39;BTC&#39;, &#39;TFT&#39;, ...
            issuer (str): address of the asset issuer
            limit ([type], optional): The limit for the asset, defaults to max int64(922337203685.4775807). If the limit is set to “0” it deletes the trustline. Defaults to None.
            secret (str, optional): Secret to use will use instance property if empty. Defaults to None.
        &#34;&#34;&#34;
        # if no secret is provided we assume we change trustlines for this account
        secret = secret or self.secret

        server = self._get_horizon_server()
        source_keypair = stellar_sdk.Keypair.from_secret(secret)
        source_public_key = source_keypair.public_key
        source_account = server.load_account(source_public_key)

        base_fee = server.fetch_base_fee()

        transaction = (
            stellar_sdk.TransactionBuilder(
                source_account=source_account,
                network_passphrase=_NETWORK_PASSPHRASES[self.network.value],
                base_fee=base_fee,
            )
            .append_change_trust_op(asset_issuer=issuer, asset_code=asset_code, limit=limit)
            .set_timeout(30)
            .build()
        )

        transaction.sign(source_keypair)

        try:
            response = server.submit_transaction(transaction)
            j.logger.info(&#34;Transaction hash: {}&#34;.format(response[&#34;hash&#34;]))
        except stellar_sdk.exceptions.BadRequestError as e:
            j.logger.debug(e)
            raise e

    def transfer(
        self,
        destination_address,
        amount,
        asset=&#34;XLM&#34;,
        locked_until=None,
        memo_text=None,
        memo_hash=None,
        fund_transaction=True,
        from_address=None,
        timeout=30,
        sequence_number: int = None,
        sign: bool = True,
    ):
        &#34;&#34;&#34;Transfer assets to another address

        Args:
            destination_address (str): address of the destination
            amount (str): can be a floating point number with 7 numbers after the decimal point expressed as a string
            asset (str, optional): asset to transfer. Defaults to &#34;XLM&#34;. if you wish to specify an asset it should be in format &#39;assetcode:issuer&#39;. Where issuer is the address of the
            issuer of the asset.
            locked_until (float, optional): epoch timestamp indicating until when the tokens  should be locked. Defaults to None.
            memo_text (Union[str, bytes], optional): memo text to add to the transaction, a string encoded using either ASCII or UTF-8, up to 28-bytes long. Defaults to None.
            memo_hash (Union[str, bytes], optional): memo hash to add to the transaction, A 32 byte hash. Defaults to None.
            fund_transaction (bool, optional): use the threefoldfoundation transaction funding service. Defautls to True.
            from_address (str, optional): Use a different address to send the tokens from, useful in multisig use cases. Defaults to None.
            timeout (int,optional: Seconds from now on until when the transaction to be submitted to the stellar network
            sequence_number (int,optional): specify a specific sequence number ( will still be increased by one) instead of loading it from the account
            sign (bool,optional) : Do not sign and submit the transaction

        Raises:
            Exception: If asset not in correct format
            stellar_sdk.exceptions.BadRequestError: not enough funds for opertaion
            stellar_sdk.exceptions.BadRequestError: bad transfer authentication

        Returns:
            [type]: [description]
        &#34;&#34;&#34;
        issuer = None
        j.logger.info(f&#34;Sending {amount} {asset} to {destination_address}&#34;)
        if asset != &#34;XLM&#34;:
            assetStr = asset.split(&#34;:&#34;)
            if len(assetStr) != 2:
                raise Exception(f&#34;Wrong asset format should be in format &#39;assetcode:issuer&#39;, but received {assetStr}&#34;)
            asset = assetStr[0]
            issuer = assetStr[1]

        if locked_until is not None:
            return self._transfer_locked_tokens(
                destination_address,
                amount,
                asset,
                issuer,
                locked_until,
                memo_text=memo_text,
                memo_hash=memo_hash,
                fund_transaction=fund_transaction,
                from_address=from_address,
            )

        horizon_server = self._get_horizon_server()

        base_fee = horizon_server.fetch_base_fee()
        if from_address:
            source_account = horizon_server.load_account(from_address)
        else:
            source_account = self.load_account()

        if sequence_number:
            source_account.sequence = sequence_number

        transaction_builder = stellar_sdk.TransactionBuilder(
            source_account=source_account,
            network_passphrase=_NETWORK_PASSPHRASES[self.network.value],
            base_fee=base_fee,
        )
        transaction_builder.append_payment_op(
            destination=destination_address,
            amount=str(amount),
            asset_code=asset,
            asset_issuer=issuer,
            source=source_account.account_id,
        )
        transaction_builder.set_timeout(timeout)
        if memo_text is not None:
            transaction_builder.add_text_memo(memo_text)
        if memo_hash is not None:
            transaction_builder.add_hash_memo(memo_hash)

        transaction = transaction_builder.build()
        transaction = transaction.to_xdr()

        if asset == &#34;TFT&#34; or asset == &#34;FreeTFT&#34;:
            if fund_transaction:
                transaction = self._fund_transaction(transaction=transaction)
                transaction = transaction[&#34;transaction_xdr&#34;]

        if not sign:
            return transaction

        transaction = stellar_sdk.TransactionEnvelope.from_xdr(transaction, _NETWORK_PASSPHRASES[self.network.value])

        my_keypair = stellar_sdk.Keypair.from_secret(self.secret)
        transaction.sign(my_keypair)
        response = horizon_server.submit_transaction(transaction)
        tx_hash = response[&#34;hash&#34;]
        j.logger.info(f&#34;Transaction hash: {tx_hash}&#34;)
        return tx_hash

    def list_payments(self, address: str = None, asset: str = None, cursor: str = None):
        &#34;&#34;&#34;Get the transactions for an adddress
        :param address: address of the effects.In None, the address of this wallet is taken
        :param asset: stellar asset in the code:issuer form( except for XLM, which does not need an issuer)
        :param cursor:pass a cursor to continue after the last call or an empty str to start receivibg a cursor
         if a cursor is passed, a tuple of the payments and the cursor is returned
        &#34;&#34;&#34;
        if address is None:
            address = self.address
        tx_endpoint = self._get_horizon_server().payments()
        tx_endpoint.for_account(address)
        tx_endpoint.limit(50)
        payments = []
        old_cursor = &#34;old&#34;
        new_cursor = &#34;&#34;
        if cursor is not None:
            new_cursor = cursor
        while old_cursor != new_cursor:
            old_cursor = new_cursor
            tx_endpoint.cursor(new_cursor)
            response = tx_endpoint.call()
            next_link = response[&#34;_links&#34;][&#34;next&#34;][&#34;href&#34;]
            next_link_query = parse.urlsplit(next_link).query
            new_cursor = parse.parse_qs(next_link_query)[&#34;cursor&#34;][0]
            response_payments = response[&#34;_embedded&#34;][&#34;records&#34;]
            for response_payment in response_payments:
                ps = PaymentSummary.from_horizon_response(response_payment, address)
                if asset:
                    split_asset = asset.split(&#34;:&#34;)
                    assetcode = split_asset[0]
                    assetissuer = None
                    if len(split_asset) &gt; 1:
                        assetissuer = split_asset[1]
                    if ps.balance and ps.balance.asset_code == assetcode:
                        if assetissuer and assetissuer == ps.balance.asset_issuer:
                            payments.append(ps)
                else:
                    payments.append(ps)
        if cursor is not None:
            return {&#34;payments&#34;: payments, &#34;cursor&#34;: new_cursor}

        return payments

    def list_transactions(self, address: str = None, cursor: str = None):
        &#34;&#34;&#34;Get the transactions for an adddres
        :param address (str, optional): address of the effects.If None, the address of this wallet is taken. Defaults to None.
        :param cursor:pass a cursor to continue after the last call or an empty str to start receivibg a cursor
         if a cursor is passed, a tuple of the payments and the cursor is returned

        Returns:
            list: list of TransactionSummary objects
            dictionary: {&#34;transactions&#34;:list of TransactionSummary objects, &#34;cursor&#34;:cursor}
        &#34;&#34;&#34;
        address = address or self.address
        tx_endpoint = self._get_horizon_server().transactions()
        tx_endpoint.for_account(address)
        tx_endpoint.include_failed(True)
        transactions = []
        old_cursor = &#34;old&#34;
        new_cursor = &#34;&#34;
        if cursor is not None:
            new_cursor = cursor
        while old_cursor != new_cursor:
            old_cursor = new_cursor
            tx_endpoint.cursor(new_cursor)
            response = tx_endpoint.call()
            next_link = response[&#34;_links&#34;][&#34;next&#34;][&#34;href&#34;]
            next_link_query = parse.urlsplit(next_link).query
            new_cursor = parse.parse_qs(next_link_query)[&#34;cursor&#34;][0]
            response_transactions = response[&#34;_embedded&#34;][&#34;records&#34;]
            for response_transaction in response_transactions:
                if response_transaction[&#34;successful&#34;]:
                    transactions.append(TransactionSummary.from_horizon_response(response_transaction))

        if cursor is not None:
            return {&#34;transactions&#34;: transactions, &#34;cursor&#34;: new_cursor}
        return transactions

    def get_transaction_effects(self, transaction_hash, address=None):
        &#34;&#34;&#34;Get the effects on an adddressfor a specific transaction

        Args:
            transaction_hash (str): hash of the transaction
            address (str, optional): address of the effects.If None, the address of this wallet is taken. Defaults to None.

        Returns:
            list: list of Effect objects
        &#34;&#34;&#34;
        address = address or self.address
        effects = []
        endpoint = self._get_horizon_server().effects()
        endpoint.for_transaction(transaction_hash)
        old_cursor = &#34;old&#34;
        new_cursor = &#34;&#34;
        while old_cursor != new_cursor:
            old_cursor = new_cursor
            endpoint.cursor(new_cursor)
            response = endpoint.call()
            next_link = response[&#34;_links&#34;][&#34;next&#34;][&#34;href&#34;]
            next_link_query = parse.urlsplit(next_link).query
            new_cursor = parse.parse_qs(next_link_query)[&#34;cursor&#34;][0]
            response_effects = response[&#34;_embedded&#34;][&#34;records&#34;]
            for response_effect in response_effects:
                if &#34;account&#34; in response_effect and response_effect[&#34;account&#34;] == address:
                    effects.append(Effect.from_horizon_response(response_effect))
        return effects

    def _transfer_locked_tokens(
        self,
        destination_address,
        amount,
        asset_code,
        asset_issuer,
        unlock_time,
        memo_text=None,
        memo_hash=None,
        fund_transaction=True,
        from_address=None,
    ):
        &#34;&#34;&#34;Transfer locked assets to another address

        Args:
            destination_address (str): address of the destination
            amount (str): amount, can be a floating point number with 7 numbers after the decimal point expressed as a string
            asset_code (str): asset to transfer
            asset_issuer (str): if the asset_code is different from &#39;XlM&#39;, the issuer address
            unlock_time (float):  an epoch timestamp indicating when the funds should be unlocked
            memo_text (Union[str, bytes], optional): memo text to add to the transaction, a string encoded using either ASCII or UTF-8, up to 28-bytes long
            memo_hash (Union[str, bytes], optional): memo hash to add to the transaction, A 32 byte hash
            fund_transaction (bool, optional): use the threefoldfoundation transaction funding service.Defaults to True.
            from_address (str, optional): Use a different address to send the tokens from, useful in multisig use cases. Defaults to None.

        Returns:
            [type]: [description]
        &#34;&#34;&#34;

        unlock_time = math.ceil(unlock_time)

        self._log_info(&#34;Creating escrow account&#34;)
        escrow_kp = stellar_sdk.Keypair.random()

        # minimum account balance as described at https://www.stellar.org/developers/guides/concepts/fees.html#minimum-account-balance
        horizon_server = self._get_horizon_server()
        base_fee = horizon_server.fetch_base_fee()
        base_reserve = 0.5
        minimum_account_balance = (2 + 1 + 3) * base_reserve  # 1 trustline and 3 signers
        required_XLM = minimum_account_balance + base_fee * 0.0000001 * 3

        self._log_info(&#34;Activating escrow account&#34;)
        self.activate_account(escrow_kp.public_key, str(math.ceil(required_XLM)))

        if asset_code != &#34;XLM&#34;:
            self._log_info(&#34;Adding trustline to escrow account&#34;)
            self.add_trustline(asset_code, asset_issuer, escrow_kp.secret)

        preauth_tx = self._create_unlock_transaction(escrow_kp, unlock_time)
        preauth_tx_hash = preauth_tx.hash()

        # save the preauth transaction in our unlock service
        unlock_hash = stellar_sdk.strkey.StrKey.encode_pre_auth_tx(preauth_tx_hash)
        self._create_unlockhash_transaction(unlock_hash=unlock_hash, transaction_xdr=preauth_tx.to_xdr())

        self._set_escrow_account_signers(escrow_kp.public_key, destination_address, preauth_tx_hash, escrow_kp)
        self._log_info(&#34;Unlock Transaction:&#34;)
        self._log_info(preauth_tx.to_xdr())

        self.transfer(
            escrow_kp.public_key,
            amount,
            asset_code + &#34;:&#34; + asset_issuer,
            memo_text=memo_text,
            memo_hash=memo_hash,
            fund_transaction=fund_transaction,
            from_address=from_address,
        )
        return preauth_tx.to_xdr()

    def _create_unlock_transaction(self, escrow_kp, unlock_time):
        server = self._get_horizon_server()
        escrow_account = server.load_account(escrow_kp.public_key)
        escrow_account.increment_sequence_number()
        tx = (
            stellar_sdk.TransactionBuilder(escrow_account)
            .append_set_options_op(master_weight=0, low_threshold=1, med_threshold=1, high_threshold=1)
            .add_time_bounds(unlock_time, 0)
            .build()
        )
        tx.sign(escrow_kp)
        return tx

    def _set_account_signers(self, address, public_key_signer, preauth_tx_hash, signer_kp):
        server = self._get_horizon_server()
        if address == self.address:
            account = self.load_account()
        else:
            account = server.load_account(address)
        tx = (
            stellar_sdk.TransactionBuilder(account)
            .append_pre_auth_tx_signer(preauth_tx_hash, 1)
            .append_ed25519_public_key_signer(public_key_signer, 1)
            .append_set_options_op(master_weight=1, low_threshold=2, med_threshold=2, high_threshold=2)
            .build()
        )

        tx.sign(signer_kp)
        response = server.submit_transaction(tx)
        j.logger.info(response)
        j.logger.info(f&#34;Set the signers of {address} to {public_key_signer} and {preauth_tx_hash}&#34;)

    def get_signing_requirements(self, address: str = None):
        address = address or self.address
        response = self._get_horizon_server().accounts().account_id(address).call()
        signing_requirements = {}
        signing_requirements[&#34;thresholds&#34;] = response[&#34;thresholds&#34;]
        signing_requirements[&#34;signers&#34;] = response[&#34;signers&#34;]
        return signing_requirements

    def modify_signing_requirements(
        self, public_keys_signers, signature_count, low_treshold=0, high_treshold=2, master_weight=2
    ):
        &#34;&#34;&#34;modify_signing_requirements sets to amount of signatures required for the creation of multisig account. It also adds
           the public keys of the signer to this account

        Args:
            public_keys_signers (list): list of public keys of signers
            signature_count (int): amount of signatures requires to transfer funds
            low_treshold (int, optional): amount of signatures required for low security operations (transaction processing, allow trust, bump sequence). Defaults to 1.
            high_treshold (int, optional): amount of signatures required for high security operations (set options, account merge). Defaults to 2.
            master_weight (int, optional): A number from 0-255 (inclusive) representing the weight of the master key. If the weight of the master key is updated to 0, it is effectively disabled. Defaults to 2.
        &#34;&#34;&#34;
        server = self._get_horizon_server()
        account = self.load_account()
        source_keypair = stellar_sdk.Keypair.from_secret(self.secret)

        transaction_builder = stellar_sdk.TransactionBuilder(account)
        # set the signing options
        transaction_builder.append_set_options_op(
            low_threshold=low_treshold,
            med_threshold=signature_count,
            high_threshold=high_treshold,
            master_weight=master_weight,
        )

        # For every public key given, add it as a signer to this account
        for public_key_signer in public_keys_signers:
            transaction_builder.append_ed25519_public_key_signer(public_key_signer, 1)

        transaction_builder.set_timeout(30)
        tx = transaction_builder.build()
        tx.sign(source_keypair)

        try:
            response = server.submit_transaction(tx)
            j.logger.info(response)
            j.logger.info(f&#34;Set the signers of {self.address} to require {signature_count} signers&#34;)
        except stellar_sdk.exceptions.BadRequestError:
            j.logger.info(&#34;Transaction need additional signatures in order to send&#34;)
            return tx.to_xdr()

    def sign(self, tx_xdr: str, submit: bool = True):
        &#34;&#34;&#34; sign signs a transaction xdr and optionally submits it to the network

        Args:
            tx_xdr (str): transaction to sign in xdr format
            submit (bool,optional): submit the transaction tro the Stellar network
        &#34;&#34;&#34;

        source_keypair = stellar_sdk.Keypair.from_secret(self.secret)
        tx = stellar_sdk.TransactionEnvelope.from_xdr(tx_xdr, _NETWORK_PASSPHRASES[self.network.value])
        tx.sign(source_keypair)
        if submit:
            horizon_server = self._get_horizon_server()
            horizon_server.submit_transaction(tx)
        else:
            return tx.to_xdr()

    def sign_multisig_transaction(self, tx_xdr):
        &#34;&#34;&#34;sign_multisig_transaction signs a transaction xdr and tries to submit it to the network

           Deprecated, use sign instead

        Args:
            tx_xdr (str): transaction to sign in xdr format
        &#34;&#34;&#34;

        try:
            self.sign(tx_xdr)
            j.logger.info(&#34;Multisig tx signed and sent&#34;)
        except UnAuthorized as e:
            j.logger.info(&#34;Transaction needs additional signatures in order to send&#34;)
            return e.transaction_xdr

    def remove_signer(self, public_key_signer):
        &#34;&#34;&#34;remove_signer removes a public key as a signer from the source account

        Args:
            public_key_signer (str): public key of an account
        &#34;&#34;&#34;
        server = self._get_horizon_server()
        account = self.load_account()
        tx = stellar_sdk.TransactionBuilder(account).append_ed25519_public_key_signer(public_key_signer, 0).build()

        source_keypair = stellar_sdk.Keypair.from_secret(self.secret)

        tx.sign(source_keypair)
        try:
            response = server.submit_transaction(tx)
            j.logger.info(response)
            j.logger.info(&#34;Multisig tx signed and sent&#34;)
        except stellar_sdk.exceptions.BadRequestError:
            j.logger.info(&#34;Transaction need additional signatures in order to send&#34;)
            return tx.to_xdr()

    def get_sender_wallet_address(self, transaction_hash):
        &#34;&#34;&#34;Get the sender&#39;s wallet address from a transaction hash

        Args:
            transaction_hash (String): Transaction hash

        Returns:
            String : Wallet Hash

        &#34;&#34;&#34;
        server = self._get_horizon_server()
        endpoint = server.operations().for_transaction(transaction_hash)
        response = endpoint.call()
        # not possible for a transaction to have more than a source, so will take first one
        wallet_address = response[&#34;_embedded&#34;][&#34;records&#34;][0][&#34;source_account&#34;]
        return wallet_address

    def check_is_payment_transaction(self, transaction_hash):
        &#34;&#34;&#34;Some transactions doesn&#39;t have an amount like activating the wallet
        This helper method to help in iterating in transactions

        Args:
            transaction_hash (String): Transaction hash

        Returns:
            Bool: True if transaction has amount - False if not
        &#34;&#34;&#34;

        server = self._get_horizon_server()
        endpoint = server.operations().for_transaction(transaction_hash)
        response = endpoint.call()
        results = response[&#34;_embedded&#34;][&#34;records&#34;][0]
        return results[&#34;type&#34;] == &#34;payment&#34;

    def get_asset(self, code=&#34;TFT&#34;, issuer=None) -&gt; stellar_sdk.Asset:
        &#34;&#34;&#34;Gets an stellar_sdk.Asset object by code.
        if the code is TFT or TFTA we quickly return the Asset object based on the code.
        if the code is native (XLM) we return the Asset object with None issuer.
        if the code isn&#39;t unknown, exception is raised to manually construct the Asset object.

        Args:
            code (str, optional): code for the asset. Defaults to &#34;TFT&#34;.
            issuer (str, optional): issuer for the asset. Defaults to None.

        Raises:
            ValueError: empty code, In case of issuer is None and not XLM or the code isn&#39;t for TFT or TFTA.
            stellar_sdk.exceptions.AssetIssuerInvalidError: Invalid issuer
        Returns:
            stellar_sdk.Asset: Asset object.
        &#34;&#34;&#34;
        network = self.network.value
        KNOWN_ASSETS = list(_NETWORK_KNOWN_TRUSTS[network].keys()) + [&#34;XLM&#34;]

        if issuer and code:
            return Asset(code, issuer)

        if not code:
            raise ValueError(&#34;need to provide code&#34;)

        if not issuer and code not in KNOWN_ASSETS:
            raise ValueError(
                f&#34;Make sure to supply the issuer for {code}, issuer is allowed to be none only in case of {KNOWN_ASSETS}&#34;
            )

        if not issuer and code in KNOWN_ASSETS:
            asset_issuer = _NETWORK_KNOWN_TRUSTS[network].get(code, None)
            return Asset(code, asset_issuer)

    def cancel_sell_order(
        self,
        offer_id,
        selling_asset: stellar_sdk.Asset,
        buying_asset: stellar_sdk.Asset,
        price: Union[str, decimal.Decimal],
    ):
        &#34;&#34;&#34;Deletes a selling order for amount `amount` of `selling_asset` for `buying_asset` with the price of `price`

        Args:
            selling_asset (stellar_sdk.Asset): Selling Asset object - check wallet object.get_asset_by_code function
            buying_asset (stellar_sdk.Asset): Buying Asset object - Asset object - check wallet object.get_asset_by_code function
            offer_id (int): pass the current offer id and set the amount to 0 to cancel this offer
            price (str): order price
        &#34;&#34;&#34;
        return self._manage_sell_order(
            selling_asset=selling_asset, buying_asset=buying_asset, amount=&#34;0&#34;, price=price, offer_id=offer_id
        )

    def _manage_sell_order(
        self,
        selling_asset: stellar_sdk.Asset,
        buying_asset: stellar_sdk.Asset,
        amount: Union[str, decimal.Decimal],
        price: Union[str, decimal.Decimal],
        timeout=30,
        offer_id=0,
    ):
        &#34;&#34;&#34;Places/Deletes a selling order for amount `amount` of `selling_asset` for `buying_asset` with the price of `price`

        Args:
            selling_asset (stellar_sdk.Asset): Selling Asset object - check wallet object.get_asset_by_code function
            buying_asset (stellar_sdk.Asset): Buying Asset object - Asset object - check wallet object.get_asset_by_code function
            amount (Union[str, decimal.Decimal]): Amount to sell.
            price (Union[str, decimal.Decimal]): Price for selling.
            timeout (int, optional): Timeout for submitting the transaction. Defaults to 30.
            offer_id: pass the current offer id and set the amount to 0 to cancel this offer or another amount to update the offer

        Raises:
            ValueError: In case of invalid issuer.
            RuntimeError: Error happened during submission of the transaction.

        Returns:
            (dict): response as the result of sumbit the transaction
        &#34;&#34;&#34;
        server = self._get_horizon_server()
        tb = TransactionBuilder(self.load_account(), network_passphrase=_NETWORK_PASSPHRASES[self.network.value])
        try:
            tx = (
                tb.append_manage_sell_offer_op(
                    selling_code=selling_asset.code,
                    selling_issuer=selling_asset.issuer,
                    buying_code=buying_asset.code,
                    buying_issuer=buying_asset.issuer,
                    amount=amount,
                    price=price,
                    offer_id=offer_id,
                )
                .set_timeout(timeout)
                .build()
            )
        except stellar_sdk.exceptions.AssetIssuerInvalidError as e:
            raise ValueError(&#34;invalid issuer&#34;) from e
        except Exception as e:
            raise RuntimeError(
                f&#34;error happened for placing selling order for selling: {selling_asset}, buying: {buying_asset}, amount: {amount} price: {price}&#34;
            ) from e
        else:
            tx.sign(self.secret)
            try:
                resp = server.submit_transaction(tx)
            except Exception as e:
                raise RuntimeError(
                    f&#34;couldn&#39;t submit sell offer, probably wallet is unfunded. Please check the error stacktrace for more information.&#34;
                ) from e
            return resp

    place_sell_order = _manage_sell_order

    def get_created_offers(self, wallet_address: str = None):
        &#34;&#34;&#34;Returns a list of the currently created offers

        Args:
            wallet_address (Str, optional): wallet address you want to get offers to. Defaults to self.address.

        Returns:
            list
        &#34;&#34;&#34;
        wallet_address = wallet_address or self.address
        server = self._get_horizon_server()
        endpoint = server.offers()
        endpoint.account(wallet_address)
        response = endpoint.call()
        offers = response[&#34;_embedded&#34;][&#34;records&#34;]
        return offers

    def set_data_entry(self, name: str, value: str, address: str = None):
        &#34;&#34;&#34;Sets, modifies or deletes a data entry (name/value pair) for an account

        To delete a data entry, set the value to an empty string.

        &#34;&#34;&#34;

        address = address or self.address
        signing_key = stellar_sdk.Keypair.from_secret(self.secret)
        horizon_server = self._get_horizon_server()
        if address == self.address:
            account = self.load_account()
        else:
            account = horizon_server.load_account(address)
        base_fee = horizon_server.fetch_base_fee()
        transaction = (
            stellar_sdk.TransactionBuilder(
                source_account=account, network_passphrase=_NETWORK_PASSPHRASES[self.network.value], base_fee=base_fee,
            )
            .append_manage_data_op(name, value)
            .set_timeout(30)
            .build()
        )

        transaction.sign(signing_key)

        try:
            response = horizon_server.submit_transaction(transaction)
            j.logger.info(&#34;Transaction hash: {}&#34;.format(response[&#34;hash&#34;]))
        except stellar_sdk.exceptions.BadRequestError as e:
            j.logger.debug(e)
            raise e

    def get_data_entries(self, address: str = None):
        address = address or self.address
        horizon_server = self._get_horizon_server()
        response = horizon_server.accounts().account_id(address).call()
        data = {}
        for data_name, data_value in response[&#34;data&#34;].items():
            data[data_name] = base64.b64decode(data_value).decode(&#34;utf-8&#34;)
        return data</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="jumpscale.clients.stellar.stellar.Network"><code class="flex name class">
<span>class <span class="ident">Network</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>An enumeration.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">class Network(Enum):
    STD = &#34;STD&#34;
    TEST = &#34;TEST&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="jumpscale.clients.stellar.stellar.Network.STD"><code class="name">var <span class="ident">STD</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="jumpscale.clients.stellar.stellar.Network.TEST"><code class="name">var <span class="ident">TEST</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
</dd>
<dt id="jumpscale.clients.stellar.stellar.Stellar"><code class="flex name class">
<span>class <span class="ident">Stellar</span></span>
<span>(</span><span>parent_=None, instance_name_=None, **values)</span>
</code></dt>
<dd>
<section class="desc"><p>A simple attribute-based namespace.</p>
<p>SimpleNamespace(**kwargs)</p>
<p>base class implementation for any class with fields which supports getting/setting raw data for any instance fields.</p>
<p>any instance can have an optional name and a parent.</p>
<pre><code class="python">class Person(Base):
    name = fields.String()
    age = fields.Float()

p = Person(name=&quot;ahmed&quot;, age=&quot;19&quot;)
print(p.name, p.age)
</code></pre>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>parent_</code></strong> :&ensp;<code>Base</code>, optional</dt>
<dd>parent instance. Defaults to None.</dd>
<dt><strong><code>instance_name_</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>instance name. Defaults to None.</dd>
<dt><strong><code>**values</code></strong></dt>
<dd>any given field values to initiate the instance with</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">class Stellar(Client):
    network = fields.Enum(Network)
    address = fields.String()

    def secret_updated(self, value):
        self.address = stellar_sdk.Keypair.from_secret(value).public_key

    secret = fields.String(on_update=secret_updated)

    def _get_horizon_server(self):
        server_url = _HORIZON_NETWORKS[self.network.value]
        server = Server(horizon_url=server_url)
        return server

    def _get_free_balances(self, address=None):
        address = address or self.address
        balances = AccountBalances(address)
        response = self._get_horizon_server().accounts().account_id(address).call()
        for response_balance in response[&#34;balances&#34;]:
            balances.add_balance(Balance.from_horizon_response(response_balance))
        return balances

    def load_account(self):
        horizonServer = self._get_horizon_server()
        saccount = horizonServer.load_account(self.address)
        account = Account(saccount.account_id, saccount.sequence, self)
        return account

    def _get_url(self, endpoint):
        url = _THREEFOLDFOUNDATION_TFTSTELLAR_SERVICES[self.network.value]
        if not j.sals.nettools.wait_connection_test(url, 443, 5):
            raise j.exceptions.Timeout(f&#34;Can not connect to server {url}, connection timeout&#34;)
        endpoint = _THREEFOLDFOUNDATION_TFTSTELLAR_ENDPOINT[endpoint]
        return f&#34;https://{url}{endpoint}&#34;

    def _fund_transaction(self, transaction):
        data = {&#34;transaction&#34;: transaction}
        resp = j.tools.http.post(self._get_url(&#34;FUND&#34;), json={&#34;args&#34;: data})
        resp.raise_for_status()
        return resp.json()

    def _create_unlockhash_transaction(self, unlock_hash, transaction_xdr):
        data = {&#34;unlockhash&#34;: unlock_hash, &#34;transaction_xdr&#34;: transaction_xdr}
        resp = j.tools.http.post(self._get_url(&#34;CREATE_UNLOCK&#34;), json={&#34;args&#34;: data})
        resp.raise_for_status()
        return resp.json()

    def _get_unlockhash_transaction(self, unlockhash):
        data = {&#34;unlockhash&#34;: unlockhash}
        resp = j.tools.http.post(self._get_url(&#34;GET_UNLOCK&#34;), json={&#34;args&#34;: data})
        resp.raise_for_status()
        return resp.json()

    def _create_activation_code(self):
        data = {&#34;address&#34;: self.address}
        resp = j.tools.http.post(self._get_url(&#34;CREATE_ACTIVATION_CODE&#34;), json={&#34;args&#34;: data})
        resp.raise_for_status()
        return resp.json()

    def _activation_account(self, activation_code):
        data = {&#34;activation_code&#34;: activation_code}
        resp = j.tools.http.post(self._get_url(&#34;ACTIVATE_ACCOUNT&#34;), json={&#34;args&#34;: data})
        resp.raise_for_status()
        return resp.json()

    def set_unlock_transaction(self, unlock_transaction):
        &#34;&#34;&#34;
        Adds a xdr encoded unlocktransaction
        :param unlock_transaction: xdr encoded unlocktransactionaddress of the destination.
        :type destination_address: str
        &#34;&#34;&#34;
        txe = stellar_sdk.TransactionEnvelope.from_xdr(unlock_transaction, _NETWORK_PASSPHRASES[self.network.value])
        tx_hash = txe.hash()
        unlock_hash = stellar_sdk.strkey.StrKey.encode_pre_auth_tx(tx_hash)

        self._create_unlockhash_transaction(unlock_hash=unlock_hash, transaction_xdr=txe.to_xdr())

    def get_balance(self, address=None):
        &#34;&#34;&#34;Gets balance for a stellar address
        &#34;&#34;&#34;
        if address is None:
            address = self.address
        all_balances = self._get_free_balances(address)
        for account in self._find_escrow_accounts(address):
            all_balances.add_escrow_account(account)
        return all_balances

    def _find_escrow_accounts(self, address=None):
        if address is None:
            address = self.address
        escrow_accounts = []
        accounts_endpoint = self._get_horizon_server().accounts()
        accounts_endpoint.signer(address)
        old_cursor = &#34;old&#34;
        new_cursor = &#34;&#34;
        while new_cursor != old_cursor:
            old_cursor = new_cursor
            accounts_endpoint.cursor(new_cursor)
            response = accounts_endpoint.call()
            next_link = response[&#34;_links&#34;][&#34;next&#34;][&#34;href&#34;]
            next_link_query = parse.urlsplit(next_link).query
            new_cursor = parse.parse_qs(next_link_query)[&#34;cursor&#34;][0]
            accounts = response[&#34;_embedded&#34;][&#34;records&#34;]
            for account in accounts:
                account_id = account[&#34;account_id&#34;]
                if account_id == address:
                    continue  # Do not take the receiver&#39;s account
                all_signers = account[&#34;signers&#34;]
                preauth_signers = [signer[&#34;key&#34;] for signer in all_signers if signer[&#34;type&#34;] == &#34;preauth_tx&#34;]
                # TODO check the tresholds and signers
                # TODO if we can merge, the amount is unlocked ( if len(preauth_signers))==0
                balances = []
                for response_balance in account[&#34;balances&#34;]:
                    balances.append(Balance.from_horizon_response(response_balance))

                escrow_account = EscrowAccount(
                    account_id,
                    preauth_signers,
                    balances,
                    _NETWORK_PASSPHRASES[self.network.value],
                    self._get_unlockhash_transaction,
                )
                escrow_accounts.append(escrow_account)
        return escrow_accounts

    def claim_locked_funds(self):
        balances = self.get_balance()
        for locked_account in balances.escrow_accounts:
            if locked_account.can_be_unlocked():
                self._unlock_account(locked_account)

    def _unlock_account(self, escrow_account):
        submitted_unlock_transactions = 0
        for unlockhash in escrow_account.unlockhashes:
            unlockhash_transation = self._get_unlockhash_transaction(unlockhash=unlockhash)
            if unlockhash_transation is None:
                return
            j.logger.info(unlockhash_transation[&#34;transaction_xdr&#34;])
            self._get_horizon_server().submit_transaction(unlockhash_transation[&#34;transaction_xdr&#34;])
            submitted_unlock_transactions += 1

        if submitted_unlock_transactions == len(escrow_account.unlockhashes):
            self._merge_account(escrow_account.address)

    def _merge_account(self, address):
        server = self._get_horizon_server()
        account = server.load_account(address)
        # Increment the sequence number in case the unlock transaction was not processed before the load_account call
        # account.increment_sequence_number()
        balances = self._get_free_balances(address)
        base_fee = server.fetch_base_fee()
        transaction_builder = stellar_sdk.TransactionBuilder(
            source_account=account, network_passphrase=_NETWORK_PASSPHRASES[self.network.value], base_fee=base_fee
        )
        for balance in balances.balances:
            if balance.is_native():
                continue
            # Step 1: Transfer custom assets
            transaction_builder.append_payment_op(
                destination=self.address,
                amount=balance.balance,
                asset_code=balance.asset_code,
                asset_issuer=balance.asset_issuer,
            )
            # Step 2: Delete trustlines
            transaction_builder.append_change_trust_op(
                asset_issuer=balance.asset_issuer, asset_code=balance.asset_code, limit=&#34;0&#34;
            )
        # Step 3: Merge account
        transaction_builder.append_account_merge_op(self.address)

        transaction_builder.set_timeout(30)
        transaction = transaction_builder.build()
        signer_kp = stellar_sdk.Keypair.from_secret(self.secret)
        transaction.sign(signer_kp)
        server.submit_transaction(transaction)

    def activate_through_friendbot(self):
        &#34;&#34;&#34;Activates and funds a testnet account using riendbot
        &#34;&#34;&#34;
        if self.network.value != &#34;TEST&#34;:
            raise Exception(&#34;Account activation through friendbot is only available on testnet&#34;)

        resp = j.tools.http.get(&#34;https://friendbot.stellar.org/&#34;, params={&#34;addr&#34;: self.address})
        resp.raise_for_status()
        j.logger.info(f&#34;account with address {self.address} activated and  funded through friendbot&#34;)

    def activate_through_threefold_service(self):
        &#34;&#34;&#34;
        Activate your weallet through threefold services
        &#34;&#34;&#34;
        activationdata = self._create_activation_code()
        self._activation_account(activationdata[&#34;activation_code&#34;])

    def activate_account(self, destination_address, starting_balance=&#34;12.50&#34;):
        &#34;&#34;&#34;Activates another account

        Args:
            destination_address (str): address of the destination
            starting_balance (str, optional): the balance that the destination address will start with. Must be a positive integer expressed as a string. Defaults to &#34;12.50&#34;.
        &#34;&#34;&#34;
        server = self._get_horizon_server()
        source_keypair = stellar_sdk.Keypair.from_secret(self.secret)

        source_account = self.load_account()

        base_fee = server.fetch_base_fee()
        transaction = (
            stellar_sdk.TransactionBuilder(
                source_account=source_account,
                network_passphrase=_NETWORK_PASSPHRASES[self.network.value],
                base_fee=base_fee,
            )
            .append_create_account_op(destination=destination_address, starting_balance=starting_balance)
            .build()
        )
        transaction.sign(source_keypair)
        try:
            response = server.submit_transaction(transaction)
            j.logger.info(&#34;Transaction hash: {}&#34;.format(response[&#34;hash&#34;]))
        except stellar_sdk.exceptions.BadRequestError as e:
            j.logger.debug(e)

    def add_trustline(self, asset_code, issuer, secret=None):
        &#34;&#34;&#34;Create a trustline to an asset

        Args:
            asset_code (str): code of the asset. For example: &#39;BTC&#39;, &#39;TFT&#39;, ...
            issuer (str): address of the asset issuer
            secret (str, optional): Secret to use will use instance property if empty. Defaults to None.
        &#34;&#34;&#34;
        self._change_trustline(asset_code, issuer, secret=secret)

    def add_known_trustline(self, asset_code):
        &#34;&#34;&#34;Will add a trustline known by threefold for chosen asset_code

        Args:
            asset_code (str): code of the asset. For example: &#39;BTC&#39;, &#39;TFT&#39;, ...
        &#34;&#34;&#34;
        issuer = _NETWORK_KNOWN_TRUSTS.get(self.network.value, {}).get(asset_code)
        if not issuer:
            raise j.exceptions.NotFound(f&#34;We do not provide a known issuers for {asset_code} on network {self.network}&#34;)
        self._change_trustline(asset_code, issuer)

    def delete_trustline(self, asset_code, issuer, secret=None):
        &#34;&#34;&#34;Deletes a trustline

        Args:
            asset_code (str): code of the asset. For example: &#39;BTC&#39;, &#39;XRP&#39;, ...
            issuer (str): address of the asset issuer
            secret (str, optional): Secret to use will use instance property if empty. Defaults to None.
        &#34;&#34;&#34;
        self._change_trustline(asset_code, issuer, limit=&#34;0&#34;, secret=secret)

    def _change_trustline(self, asset_code, issuer, limit=None, secret=None):
        &#34;&#34;&#34;Create a trustline between you and the issuer of an asset

        Args:
            asset_code (str): code which form the asset. For example: &#39;BTC&#39;, &#39;TFT&#39;, ...
            issuer (str): address of the asset issuer
            limit ([type], optional): The limit for the asset, defaults to max int64(922337203685.4775807). If the limit is set to “0” it deletes the trustline. Defaults to None.
            secret (str, optional): Secret to use will use instance property if empty. Defaults to None.
        &#34;&#34;&#34;
        # if no secret is provided we assume we change trustlines for this account
        secret = secret or self.secret

        server = self._get_horizon_server()
        source_keypair = stellar_sdk.Keypair.from_secret(secret)
        source_public_key = source_keypair.public_key
        source_account = server.load_account(source_public_key)

        base_fee = server.fetch_base_fee()

        transaction = (
            stellar_sdk.TransactionBuilder(
                source_account=source_account,
                network_passphrase=_NETWORK_PASSPHRASES[self.network.value],
                base_fee=base_fee,
            )
            .append_change_trust_op(asset_issuer=issuer, asset_code=asset_code, limit=limit)
            .set_timeout(30)
            .build()
        )

        transaction.sign(source_keypair)

        try:
            response = server.submit_transaction(transaction)
            j.logger.info(&#34;Transaction hash: {}&#34;.format(response[&#34;hash&#34;]))
        except stellar_sdk.exceptions.BadRequestError as e:
            j.logger.debug(e)
            raise e

    def transfer(
        self,
        destination_address,
        amount,
        asset=&#34;XLM&#34;,
        locked_until=None,
        memo_text=None,
        memo_hash=None,
        fund_transaction=True,
        from_address=None,
        timeout=30,
        sequence_number: int = None,
        sign: bool = True,
    ):
        &#34;&#34;&#34;Transfer assets to another address

        Args:
            destination_address (str): address of the destination
            amount (str): can be a floating point number with 7 numbers after the decimal point expressed as a string
            asset (str, optional): asset to transfer. Defaults to &#34;XLM&#34;. if you wish to specify an asset it should be in format &#39;assetcode:issuer&#39;. Where issuer is the address of the
            issuer of the asset.
            locked_until (float, optional): epoch timestamp indicating until when the tokens  should be locked. Defaults to None.
            memo_text (Union[str, bytes], optional): memo text to add to the transaction, a string encoded using either ASCII or UTF-8, up to 28-bytes long. Defaults to None.
            memo_hash (Union[str, bytes], optional): memo hash to add to the transaction, A 32 byte hash. Defaults to None.
            fund_transaction (bool, optional): use the threefoldfoundation transaction funding service. Defautls to True.
            from_address (str, optional): Use a different address to send the tokens from, useful in multisig use cases. Defaults to None.
            timeout (int,optional: Seconds from now on until when the transaction to be submitted to the stellar network
            sequence_number (int,optional): specify a specific sequence number ( will still be increased by one) instead of loading it from the account
            sign (bool,optional) : Do not sign and submit the transaction

        Raises:
            Exception: If asset not in correct format
            stellar_sdk.exceptions.BadRequestError: not enough funds for opertaion
            stellar_sdk.exceptions.BadRequestError: bad transfer authentication

        Returns:
            [type]: [description]
        &#34;&#34;&#34;
        issuer = None
        j.logger.info(f&#34;Sending {amount} {asset} to {destination_address}&#34;)
        if asset != &#34;XLM&#34;:
            assetStr = asset.split(&#34;:&#34;)
            if len(assetStr) != 2:
                raise Exception(f&#34;Wrong asset format should be in format &#39;assetcode:issuer&#39;, but received {assetStr}&#34;)
            asset = assetStr[0]
            issuer = assetStr[1]

        if locked_until is not None:
            return self._transfer_locked_tokens(
                destination_address,
                amount,
                asset,
                issuer,
                locked_until,
                memo_text=memo_text,
                memo_hash=memo_hash,
                fund_transaction=fund_transaction,
                from_address=from_address,
            )

        horizon_server = self._get_horizon_server()

        base_fee = horizon_server.fetch_base_fee()
        if from_address:
            source_account = horizon_server.load_account(from_address)
        else:
            source_account = self.load_account()

        if sequence_number:
            source_account.sequence = sequence_number

        transaction_builder = stellar_sdk.TransactionBuilder(
            source_account=source_account,
            network_passphrase=_NETWORK_PASSPHRASES[self.network.value],
            base_fee=base_fee,
        )
        transaction_builder.append_payment_op(
            destination=destination_address,
            amount=str(amount),
            asset_code=asset,
            asset_issuer=issuer,
            source=source_account.account_id,
        )
        transaction_builder.set_timeout(timeout)
        if memo_text is not None:
            transaction_builder.add_text_memo(memo_text)
        if memo_hash is not None:
            transaction_builder.add_hash_memo(memo_hash)

        transaction = transaction_builder.build()
        transaction = transaction.to_xdr()

        if asset == &#34;TFT&#34; or asset == &#34;FreeTFT&#34;:
            if fund_transaction:
                transaction = self._fund_transaction(transaction=transaction)
                transaction = transaction[&#34;transaction_xdr&#34;]

        if not sign:
            return transaction

        transaction = stellar_sdk.TransactionEnvelope.from_xdr(transaction, _NETWORK_PASSPHRASES[self.network.value])

        my_keypair = stellar_sdk.Keypair.from_secret(self.secret)
        transaction.sign(my_keypair)
        response = horizon_server.submit_transaction(transaction)
        tx_hash = response[&#34;hash&#34;]
        j.logger.info(f&#34;Transaction hash: {tx_hash}&#34;)
        return tx_hash

    def list_payments(self, address: str = None, asset: str = None, cursor: str = None):
        &#34;&#34;&#34;Get the transactions for an adddress
        :param address: address of the effects.In None, the address of this wallet is taken
        :param asset: stellar asset in the code:issuer form( except for XLM, which does not need an issuer)
        :param cursor:pass a cursor to continue after the last call or an empty str to start receivibg a cursor
         if a cursor is passed, a tuple of the payments and the cursor is returned
        &#34;&#34;&#34;
        if address is None:
            address = self.address
        tx_endpoint = self._get_horizon_server().payments()
        tx_endpoint.for_account(address)
        tx_endpoint.limit(50)
        payments = []
        old_cursor = &#34;old&#34;
        new_cursor = &#34;&#34;
        if cursor is not None:
            new_cursor = cursor
        while old_cursor != new_cursor:
            old_cursor = new_cursor
            tx_endpoint.cursor(new_cursor)
            response = tx_endpoint.call()
            next_link = response[&#34;_links&#34;][&#34;next&#34;][&#34;href&#34;]
            next_link_query = parse.urlsplit(next_link).query
            new_cursor = parse.parse_qs(next_link_query)[&#34;cursor&#34;][0]
            response_payments = response[&#34;_embedded&#34;][&#34;records&#34;]
            for response_payment in response_payments:
                ps = PaymentSummary.from_horizon_response(response_payment, address)
                if asset:
                    split_asset = asset.split(&#34;:&#34;)
                    assetcode = split_asset[0]
                    assetissuer = None
                    if len(split_asset) &gt; 1:
                        assetissuer = split_asset[1]
                    if ps.balance and ps.balance.asset_code == assetcode:
                        if assetissuer and assetissuer == ps.balance.asset_issuer:
                            payments.append(ps)
                else:
                    payments.append(ps)
        if cursor is not None:
            return {&#34;payments&#34;: payments, &#34;cursor&#34;: new_cursor}

        return payments

    def list_transactions(self, address: str = None, cursor: str = None):
        &#34;&#34;&#34;Get the transactions for an adddres
        :param address (str, optional): address of the effects.If None, the address of this wallet is taken. Defaults to None.
        :param cursor:pass a cursor to continue after the last call or an empty str to start receivibg a cursor
         if a cursor is passed, a tuple of the payments and the cursor is returned

        Returns:
            list: list of TransactionSummary objects
            dictionary: {&#34;transactions&#34;:list of TransactionSummary objects, &#34;cursor&#34;:cursor}
        &#34;&#34;&#34;
        address = address or self.address
        tx_endpoint = self._get_horizon_server().transactions()
        tx_endpoint.for_account(address)
        tx_endpoint.include_failed(True)
        transactions = []
        old_cursor = &#34;old&#34;
        new_cursor = &#34;&#34;
        if cursor is not None:
            new_cursor = cursor
        while old_cursor != new_cursor:
            old_cursor = new_cursor
            tx_endpoint.cursor(new_cursor)
            response = tx_endpoint.call()
            next_link = response[&#34;_links&#34;][&#34;next&#34;][&#34;href&#34;]
            next_link_query = parse.urlsplit(next_link).query
            new_cursor = parse.parse_qs(next_link_query)[&#34;cursor&#34;][0]
            response_transactions = response[&#34;_embedded&#34;][&#34;records&#34;]
            for response_transaction in response_transactions:
                if response_transaction[&#34;successful&#34;]:
                    transactions.append(TransactionSummary.from_horizon_response(response_transaction))

        if cursor is not None:
            return {&#34;transactions&#34;: transactions, &#34;cursor&#34;: new_cursor}
        return transactions

    def get_transaction_effects(self, transaction_hash, address=None):
        &#34;&#34;&#34;Get the effects on an adddressfor a specific transaction

        Args:
            transaction_hash (str): hash of the transaction
            address (str, optional): address of the effects.If None, the address of this wallet is taken. Defaults to None.

        Returns:
            list: list of Effect objects
        &#34;&#34;&#34;
        address = address or self.address
        effects = []
        endpoint = self._get_horizon_server().effects()
        endpoint.for_transaction(transaction_hash)
        old_cursor = &#34;old&#34;
        new_cursor = &#34;&#34;
        while old_cursor != new_cursor:
            old_cursor = new_cursor
            endpoint.cursor(new_cursor)
            response = endpoint.call()
            next_link = response[&#34;_links&#34;][&#34;next&#34;][&#34;href&#34;]
            next_link_query = parse.urlsplit(next_link).query
            new_cursor = parse.parse_qs(next_link_query)[&#34;cursor&#34;][0]
            response_effects = response[&#34;_embedded&#34;][&#34;records&#34;]
            for response_effect in response_effects:
                if &#34;account&#34; in response_effect and response_effect[&#34;account&#34;] == address:
                    effects.append(Effect.from_horizon_response(response_effect))
        return effects

    def _transfer_locked_tokens(
        self,
        destination_address,
        amount,
        asset_code,
        asset_issuer,
        unlock_time,
        memo_text=None,
        memo_hash=None,
        fund_transaction=True,
        from_address=None,
    ):
        &#34;&#34;&#34;Transfer locked assets to another address

        Args:
            destination_address (str): address of the destination
            amount (str): amount, can be a floating point number with 7 numbers after the decimal point expressed as a string
            asset_code (str): asset to transfer
            asset_issuer (str): if the asset_code is different from &#39;XlM&#39;, the issuer address
            unlock_time (float):  an epoch timestamp indicating when the funds should be unlocked
            memo_text (Union[str, bytes], optional): memo text to add to the transaction, a string encoded using either ASCII or UTF-8, up to 28-bytes long
            memo_hash (Union[str, bytes], optional): memo hash to add to the transaction, A 32 byte hash
            fund_transaction (bool, optional): use the threefoldfoundation transaction funding service.Defaults to True.
            from_address (str, optional): Use a different address to send the tokens from, useful in multisig use cases. Defaults to None.

        Returns:
            [type]: [description]
        &#34;&#34;&#34;

        unlock_time = math.ceil(unlock_time)

        self._log_info(&#34;Creating escrow account&#34;)
        escrow_kp = stellar_sdk.Keypair.random()

        # minimum account balance as described at https://www.stellar.org/developers/guides/concepts/fees.html#minimum-account-balance
        horizon_server = self._get_horizon_server()
        base_fee = horizon_server.fetch_base_fee()
        base_reserve = 0.5
        minimum_account_balance = (2 + 1 + 3) * base_reserve  # 1 trustline and 3 signers
        required_XLM = minimum_account_balance + base_fee * 0.0000001 * 3

        self._log_info(&#34;Activating escrow account&#34;)
        self.activate_account(escrow_kp.public_key, str(math.ceil(required_XLM)))

        if asset_code != &#34;XLM&#34;:
            self._log_info(&#34;Adding trustline to escrow account&#34;)
            self.add_trustline(asset_code, asset_issuer, escrow_kp.secret)

        preauth_tx = self._create_unlock_transaction(escrow_kp, unlock_time)
        preauth_tx_hash = preauth_tx.hash()

        # save the preauth transaction in our unlock service
        unlock_hash = stellar_sdk.strkey.StrKey.encode_pre_auth_tx(preauth_tx_hash)
        self._create_unlockhash_transaction(unlock_hash=unlock_hash, transaction_xdr=preauth_tx.to_xdr())

        self._set_escrow_account_signers(escrow_kp.public_key, destination_address, preauth_tx_hash, escrow_kp)
        self._log_info(&#34;Unlock Transaction:&#34;)
        self._log_info(preauth_tx.to_xdr())

        self.transfer(
            escrow_kp.public_key,
            amount,
            asset_code + &#34;:&#34; + asset_issuer,
            memo_text=memo_text,
            memo_hash=memo_hash,
            fund_transaction=fund_transaction,
            from_address=from_address,
        )
        return preauth_tx.to_xdr()

    def _create_unlock_transaction(self, escrow_kp, unlock_time):
        server = self._get_horizon_server()
        escrow_account = server.load_account(escrow_kp.public_key)
        escrow_account.increment_sequence_number()
        tx = (
            stellar_sdk.TransactionBuilder(escrow_account)
            .append_set_options_op(master_weight=0, low_threshold=1, med_threshold=1, high_threshold=1)
            .add_time_bounds(unlock_time, 0)
            .build()
        )
        tx.sign(escrow_kp)
        return tx

    def _set_account_signers(self, address, public_key_signer, preauth_tx_hash, signer_kp):
        server = self._get_horizon_server()
        if address == self.address:
            account = self.load_account()
        else:
            account = server.load_account(address)
        tx = (
            stellar_sdk.TransactionBuilder(account)
            .append_pre_auth_tx_signer(preauth_tx_hash, 1)
            .append_ed25519_public_key_signer(public_key_signer, 1)
            .append_set_options_op(master_weight=1, low_threshold=2, med_threshold=2, high_threshold=2)
            .build()
        )

        tx.sign(signer_kp)
        response = server.submit_transaction(tx)
        j.logger.info(response)
        j.logger.info(f&#34;Set the signers of {address} to {public_key_signer} and {preauth_tx_hash}&#34;)

    def get_signing_requirements(self, address: str = None):
        address = address or self.address
        response = self._get_horizon_server().accounts().account_id(address).call()
        signing_requirements = {}
        signing_requirements[&#34;thresholds&#34;] = response[&#34;thresholds&#34;]
        signing_requirements[&#34;signers&#34;] = response[&#34;signers&#34;]
        return signing_requirements

    def modify_signing_requirements(
        self, public_keys_signers, signature_count, low_treshold=0, high_treshold=2, master_weight=2
    ):
        &#34;&#34;&#34;modify_signing_requirements sets to amount of signatures required for the creation of multisig account. It also adds
           the public keys of the signer to this account

        Args:
            public_keys_signers (list): list of public keys of signers
            signature_count (int): amount of signatures requires to transfer funds
            low_treshold (int, optional): amount of signatures required for low security operations (transaction processing, allow trust, bump sequence). Defaults to 1.
            high_treshold (int, optional): amount of signatures required for high security operations (set options, account merge). Defaults to 2.
            master_weight (int, optional): A number from 0-255 (inclusive) representing the weight of the master key. If the weight of the master key is updated to 0, it is effectively disabled. Defaults to 2.
        &#34;&#34;&#34;
        server = self._get_horizon_server()
        account = self.load_account()
        source_keypair = stellar_sdk.Keypair.from_secret(self.secret)

        transaction_builder = stellar_sdk.TransactionBuilder(account)
        # set the signing options
        transaction_builder.append_set_options_op(
            low_threshold=low_treshold,
            med_threshold=signature_count,
            high_threshold=high_treshold,
            master_weight=master_weight,
        )

        # For every public key given, add it as a signer to this account
        for public_key_signer in public_keys_signers:
            transaction_builder.append_ed25519_public_key_signer(public_key_signer, 1)

        transaction_builder.set_timeout(30)
        tx = transaction_builder.build()
        tx.sign(source_keypair)

        try:
            response = server.submit_transaction(tx)
            j.logger.info(response)
            j.logger.info(f&#34;Set the signers of {self.address} to require {signature_count} signers&#34;)
        except stellar_sdk.exceptions.BadRequestError:
            j.logger.info(&#34;Transaction need additional signatures in order to send&#34;)
            return tx.to_xdr()

    def sign(self, tx_xdr: str, submit: bool = True):
        &#34;&#34;&#34; sign signs a transaction xdr and optionally submits it to the network

        Args:
            tx_xdr (str): transaction to sign in xdr format
            submit (bool,optional): submit the transaction tro the Stellar network
        &#34;&#34;&#34;

        source_keypair = stellar_sdk.Keypair.from_secret(self.secret)
        tx = stellar_sdk.TransactionEnvelope.from_xdr(tx_xdr, _NETWORK_PASSPHRASES[self.network.value])
        tx.sign(source_keypair)
        if submit:
            horizon_server = self._get_horizon_server()
            horizon_server.submit_transaction(tx)
        else:
            return tx.to_xdr()

    def sign_multisig_transaction(self, tx_xdr):
        &#34;&#34;&#34;sign_multisig_transaction signs a transaction xdr and tries to submit it to the network

           Deprecated, use sign instead

        Args:
            tx_xdr (str): transaction to sign in xdr format
        &#34;&#34;&#34;

        try:
            self.sign(tx_xdr)
            j.logger.info(&#34;Multisig tx signed and sent&#34;)
        except UnAuthorized as e:
            j.logger.info(&#34;Transaction needs additional signatures in order to send&#34;)
            return e.transaction_xdr

    def remove_signer(self, public_key_signer):
        &#34;&#34;&#34;remove_signer removes a public key as a signer from the source account

        Args:
            public_key_signer (str): public key of an account
        &#34;&#34;&#34;
        server = self._get_horizon_server()
        account = self.load_account()
        tx = stellar_sdk.TransactionBuilder(account).append_ed25519_public_key_signer(public_key_signer, 0).build()

        source_keypair = stellar_sdk.Keypair.from_secret(self.secret)

        tx.sign(source_keypair)
        try:
            response = server.submit_transaction(tx)
            j.logger.info(response)
            j.logger.info(&#34;Multisig tx signed and sent&#34;)
        except stellar_sdk.exceptions.BadRequestError:
            j.logger.info(&#34;Transaction need additional signatures in order to send&#34;)
            return tx.to_xdr()

    def get_sender_wallet_address(self, transaction_hash):
        &#34;&#34;&#34;Get the sender&#39;s wallet address from a transaction hash

        Args:
            transaction_hash (String): Transaction hash

        Returns:
            String : Wallet Hash

        &#34;&#34;&#34;
        server = self._get_horizon_server()
        endpoint = server.operations().for_transaction(transaction_hash)
        response = endpoint.call()
        # not possible for a transaction to have more than a source, so will take first one
        wallet_address = response[&#34;_embedded&#34;][&#34;records&#34;][0][&#34;source_account&#34;]
        return wallet_address

    def check_is_payment_transaction(self, transaction_hash):
        &#34;&#34;&#34;Some transactions doesn&#39;t have an amount like activating the wallet
        This helper method to help in iterating in transactions

        Args:
            transaction_hash (String): Transaction hash

        Returns:
            Bool: True if transaction has amount - False if not
        &#34;&#34;&#34;

        server = self._get_horizon_server()
        endpoint = server.operations().for_transaction(transaction_hash)
        response = endpoint.call()
        results = response[&#34;_embedded&#34;][&#34;records&#34;][0]
        return results[&#34;type&#34;] == &#34;payment&#34;

    def get_asset(self, code=&#34;TFT&#34;, issuer=None) -&gt; stellar_sdk.Asset:
        &#34;&#34;&#34;Gets an stellar_sdk.Asset object by code.
        if the code is TFT or TFTA we quickly return the Asset object based on the code.
        if the code is native (XLM) we return the Asset object with None issuer.
        if the code isn&#39;t unknown, exception is raised to manually construct the Asset object.

        Args:
            code (str, optional): code for the asset. Defaults to &#34;TFT&#34;.
            issuer (str, optional): issuer for the asset. Defaults to None.

        Raises:
            ValueError: empty code, In case of issuer is None and not XLM or the code isn&#39;t for TFT or TFTA.
            stellar_sdk.exceptions.AssetIssuerInvalidError: Invalid issuer
        Returns:
            stellar_sdk.Asset: Asset object.
        &#34;&#34;&#34;
        network = self.network.value
        KNOWN_ASSETS = list(_NETWORK_KNOWN_TRUSTS[network].keys()) + [&#34;XLM&#34;]

        if issuer and code:
            return Asset(code, issuer)

        if not code:
            raise ValueError(&#34;need to provide code&#34;)

        if not issuer and code not in KNOWN_ASSETS:
            raise ValueError(
                f&#34;Make sure to supply the issuer for {code}, issuer is allowed to be none only in case of {KNOWN_ASSETS}&#34;
            )

        if not issuer and code in KNOWN_ASSETS:
            asset_issuer = _NETWORK_KNOWN_TRUSTS[network].get(code, None)
            return Asset(code, asset_issuer)

    def cancel_sell_order(
        self,
        offer_id,
        selling_asset: stellar_sdk.Asset,
        buying_asset: stellar_sdk.Asset,
        price: Union[str, decimal.Decimal],
    ):
        &#34;&#34;&#34;Deletes a selling order for amount `amount` of `selling_asset` for `buying_asset` with the price of `price`

        Args:
            selling_asset (stellar_sdk.Asset): Selling Asset object - check wallet object.get_asset_by_code function
            buying_asset (stellar_sdk.Asset): Buying Asset object - Asset object - check wallet object.get_asset_by_code function
            offer_id (int): pass the current offer id and set the amount to 0 to cancel this offer
            price (str): order price
        &#34;&#34;&#34;
        return self._manage_sell_order(
            selling_asset=selling_asset, buying_asset=buying_asset, amount=&#34;0&#34;, price=price, offer_id=offer_id
        )

    def _manage_sell_order(
        self,
        selling_asset: stellar_sdk.Asset,
        buying_asset: stellar_sdk.Asset,
        amount: Union[str, decimal.Decimal],
        price: Union[str, decimal.Decimal],
        timeout=30,
        offer_id=0,
    ):
        &#34;&#34;&#34;Places/Deletes a selling order for amount `amount` of `selling_asset` for `buying_asset` with the price of `price`

        Args:
            selling_asset (stellar_sdk.Asset): Selling Asset object - check wallet object.get_asset_by_code function
            buying_asset (stellar_sdk.Asset): Buying Asset object - Asset object - check wallet object.get_asset_by_code function
            amount (Union[str, decimal.Decimal]): Amount to sell.
            price (Union[str, decimal.Decimal]): Price for selling.
            timeout (int, optional): Timeout for submitting the transaction. Defaults to 30.
            offer_id: pass the current offer id and set the amount to 0 to cancel this offer or another amount to update the offer

        Raises:
            ValueError: In case of invalid issuer.
            RuntimeError: Error happened during submission of the transaction.

        Returns:
            (dict): response as the result of sumbit the transaction
        &#34;&#34;&#34;
        server = self._get_horizon_server()
        tb = TransactionBuilder(self.load_account(), network_passphrase=_NETWORK_PASSPHRASES[self.network.value])
        try:
            tx = (
                tb.append_manage_sell_offer_op(
                    selling_code=selling_asset.code,
                    selling_issuer=selling_asset.issuer,
                    buying_code=buying_asset.code,
                    buying_issuer=buying_asset.issuer,
                    amount=amount,
                    price=price,
                    offer_id=offer_id,
                )
                .set_timeout(timeout)
                .build()
            )
        except stellar_sdk.exceptions.AssetIssuerInvalidError as e:
            raise ValueError(&#34;invalid issuer&#34;) from e
        except Exception as e:
            raise RuntimeError(
                f&#34;error happened for placing selling order for selling: {selling_asset}, buying: {buying_asset}, amount: {amount} price: {price}&#34;
            ) from e
        else:
            tx.sign(self.secret)
            try:
                resp = server.submit_transaction(tx)
            except Exception as e:
                raise RuntimeError(
                    f&#34;couldn&#39;t submit sell offer, probably wallet is unfunded. Please check the error stacktrace for more information.&#34;
                ) from e
            return resp

    place_sell_order = _manage_sell_order

    def get_created_offers(self, wallet_address: str = None):
        &#34;&#34;&#34;Returns a list of the currently created offers

        Args:
            wallet_address (Str, optional): wallet address you want to get offers to. Defaults to self.address.

        Returns:
            list
        &#34;&#34;&#34;
        wallet_address = wallet_address or self.address
        server = self._get_horizon_server()
        endpoint = server.offers()
        endpoint.account(wallet_address)
        response = endpoint.call()
        offers = response[&#34;_embedded&#34;][&#34;records&#34;]
        return offers

    def set_data_entry(self, name: str, value: str, address: str = None):
        &#34;&#34;&#34;Sets, modifies or deletes a data entry (name/value pair) for an account

        To delete a data entry, set the value to an empty string.

        &#34;&#34;&#34;

        address = address or self.address
        signing_key = stellar_sdk.Keypair.from_secret(self.secret)
        horizon_server = self._get_horizon_server()
        if address == self.address:
            account = self.load_account()
        else:
            account = horizon_server.load_account(address)
        base_fee = horizon_server.fetch_base_fee()
        transaction = (
            stellar_sdk.TransactionBuilder(
                source_account=account, network_passphrase=_NETWORK_PASSPHRASES[self.network.value], base_fee=base_fee,
            )
            .append_manage_data_op(name, value)
            .set_timeout(30)
            .build()
        )

        transaction.sign(signing_key)

        try:
            response = horizon_server.submit_transaction(transaction)
            j.logger.info(&#34;Transaction hash: {}&#34;.format(response[&#34;hash&#34;]))
        except stellar_sdk.exceptions.BadRequestError as e:
            j.logger.debug(e)
            raise e

    def get_data_entries(self, address: str = None):
        address = address or self.address
        horizon_server = self._get_horizon_server()
        response = horizon_server.accounts().account_id(address).call()
        data = {}
        for data_name, data_value in response[&#34;data&#34;].items():
            data[data_name] = base64.b64decode(data_value).decode(&#34;utf-8&#34;)
        return data</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="jumpscale.clients.base.Client" href="../base.html#jumpscale.clients.base.Client">Client</a></li>
<li><a title="jumpscale.core.base.meta.Base" href="../../core/base/meta.html#jumpscale.core.base.meta.Base">Base</a></li>
<li>types.SimpleNamespace</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="jumpscale.clients.stellar.stellar.Stellar.address"><code class="name">var <span class="ident">address</span></code></dt>
<dd>
<section class="desc"><p>getter method this property</p>
<p>will call <code>_get_value</code>, which would if the value is already defined
and will get the default value if not</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>any</code></strong></dt>
<dd>the field value</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def getter(self):
    &#34;&#34;&#34;
    getter method this property

    will call `_get_value`, which would if the value is already defined
    and will get the default value if not

    Returns:
        any: the field value
    &#34;&#34;&#34;
    return self._get_value(name, field)</code></pre>
</details>
</dd>
<dt id="jumpscale.clients.stellar.stellar.Stellar.network"><code class="name">var <span class="ident">network</span></code></dt>
<dd>
<section class="desc"><p>getter method this property</p>
<p>will call <code>_get_value</code>, which would if the value is already defined
and will get the default value if not</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>any</code></strong></dt>
<dd>the field value</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def getter(self):
    &#34;&#34;&#34;
    getter method this property

    will call `_get_value`, which would if the value is already defined
    and will get the default value if not

    Returns:
        any: the field value
    &#34;&#34;&#34;
    return self._get_value(name, field)</code></pre>
</details>
</dd>
<dt id="jumpscale.clients.stellar.stellar.Stellar.secret"><code class="name">var <span class="ident">secret</span></code></dt>
<dd>
<section class="desc"><p>getter method this property</p>
<p>will call <code>_get_value</code>, which would if the value is already defined
and will get the default value if not</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>any</code></strong></dt>
<dd>the field value</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def getter(self):
    &#34;&#34;&#34;
    getter method this property

    will call `_get_value`, which would if the value is already defined
    and will get the default value if not

    Returns:
        any: the field value
    &#34;&#34;&#34;
    return self._get_value(name, field)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="jumpscale.clients.stellar.stellar.Stellar.activate_account"><code class="name flex">
<span>def <span class="ident">activate_account</span></span>(<span>self, destination_address, starting_balance=&#39;12.50&#39;)</span>
</code></dt>
<dd>
<section class="desc"><p>Activates another account</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>destination_address</code></strong> :&ensp;<code>str</code></dt>
<dd>address of the destination</dd>
<dt><strong><code>starting_balance</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>the balance that the destination address will start with. Must be a positive integer expressed as a string. Defaults to "12.50".</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def activate_account(self, destination_address, starting_balance=&#34;12.50&#34;):
    &#34;&#34;&#34;Activates another account

    Args:
        destination_address (str): address of the destination
        starting_balance (str, optional): the balance that the destination address will start with. Must be a positive integer expressed as a string. Defaults to &#34;12.50&#34;.
    &#34;&#34;&#34;
    server = self._get_horizon_server()
    source_keypair = stellar_sdk.Keypair.from_secret(self.secret)

    source_account = self.load_account()

    base_fee = server.fetch_base_fee()
    transaction = (
        stellar_sdk.TransactionBuilder(
            source_account=source_account,
            network_passphrase=_NETWORK_PASSPHRASES[self.network.value],
            base_fee=base_fee,
        )
        .append_create_account_op(destination=destination_address, starting_balance=starting_balance)
        .build()
    )
    transaction.sign(source_keypair)
    try:
        response = server.submit_transaction(transaction)
        j.logger.info(&#34;Transaction hash: {}&#34;.format(response[&#34;hash&#34;]))
    except stellar_sdk.exceptions.BadRequestError as e:
        j.logger.debug(e)</code></pre>
</details>
</dd>
<dt id="jumpscale.clients.stellar.stellar.Stellar.activate_through_friendbot"><code class="name flex">
<span>def <span class="ident">activate_through_friendbot</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Activates and funds a testnet account using riendbot</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def activate_through_friendbot(self):
    &#34;&#34;&#34;Activates and funds a testnet account using riendbot
    &#34;&#34;&#34;
    if self.network.value != &#34;TEST&#34;:
        raise Exception(&#34;Account activation through friendbot is only available on testnet&#34;)

    resp = j.tools.http.get(&#34;https://friendbot.stellar.org/&#34;, params={&#34;addr&#34;: self.address})
    resp.raise_for_status()
    j.logger.info(f&#34;account with address {self.address} activated and  funded through friendbot&#34;)</code></pre>
</details>
</dd>
<dt id="jumpscale.clients.stellar.stellar.Stellar.activate_through_threefold_service"><code class="name flex">
<span>def <span class="ident">activate_through_threefold_service</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Activate your weallet through threefold services</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def activate_through_threefold_service(self):
    &#34;&#34;&#34;
    Activate your weallet through threefold services
    &#34;&#34;&#34;
    activationdata = self._create_activation_code()
    self._activation_account(activationdata[&#34;activation_code&#34;])</code></pre>
</details>
</dd>
<dt id="jumpscale.clients.stellar.stellar.Stellar.add_known_trustline"><code class="name flex">
<span>def <span class="ident">add_known_trustline</span></span>(<span>self, asset_code)</span>
</code></dt>
<dd>
<section class="desc"><p>Will add a trustline known by threefold for chosen asset_code</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>asset_code</code></strong> :&ensp;<code>str</code></dt>
<dd>code of the asset. For example: 'BTC', 'TFT', &hellip;</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def add_known_trustline(self, asset_code):
    &#34;&#34;&#34;Will add a trustline known by threefold for chosen asset_code

    Args:
        asset_code (str): code of the asset. For example: &#39;BTC&#39;, &#39;TFT&#39;, ...
    &#34;&#34;&#34;
    issuer = _NETWORK_KNOWN_TRUSTS.get(self.network.value, {}).get(asset_code)
    if not issuer:
        raise j.exceptions.NotFound(f&#34;We do not provide a known issuers for {asset_code} on network {self.network}&#34;)
    self._change_trustline(asset_code, issuer)</code></pre>
</details>
</dd>
<dt id="jumpscale.clients.stellar.stellar.Stellar.add_trustline"><code class="name flex">
<span>def <span class="ident">add_trustline</span></span>(<span>self, asset_code, issuer, secret=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Create a trustline to an asset</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>asset_code</code></strong> :&ensp;<code>str</code></dt>
<dd>code of the asset. For example: 'BTC', 'TFT', &hellip;</dd>
<dt><strong><code>issuer</code></strong> :&ensp;<code>str</code></dt>
<dd>address of the asset issuer</dd>
<dt><strong><code>secret</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Secret to use will use instance property if empty. Defaults to None.</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def add_trustline(self, asset_code, issuer, secret=None):
    &#34;&#34;&#34;Create a trustline to an asset

    Args:
        asset_code (str): code of the asset. For example: &#39;BTC&#39;, &#39;TFT&#39;, ...
        issuer (str): address of the asset issuer
        secret (str, optional): Secret to use will use instance property if empty. Defaults to None.
    &#34;&#34;&#34;
    self._change_trustline(asset_code, issuer, secret=secret)</code></pre>
</details>
</dd>
<dt id="jumpscale.clients.stellar.stellar.Stellar.cancel_sell_order"><code class="name flex">
<span>def <span class="ident">cancel_sell_order</span></span>(<span>self, offer_id, selling_asset, buying_asset, price)</span>
</code></dt>
<dd>
<section class="desc"><p>Deletes a selling order for amount <code>amount</code> of <code>selling_asset</code> for <code>buying_asset</code> with the price of <code>price</code></p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>selling_asset</code></strong> :&ensp;<code>stellar_sdk.Asset</code></dt>
<dd>Selling Asset object - check wallet object.get_asset_by_code function</dd>
<dt><strong><code>buying_asset</code></strong> :&ensp;<code>stellar_sdk.Asset</code></dt>
<dd>Buying Asset object - Asset object - check wallet object.get_asset_by_code function</dd>
<dt><strong><code>offer_id</code></strong> :&ensp;<code>int</code></dt>
<dd>pass the current offer id and set the amount to 0 to cancel this offer</dd>
<dt><strong><code>price</code></strong> :&ensp;<code>str</code></dt>
<dd>order price</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def cancel_sell_order(
    self,
    offer_id,
    selling_asset: stellar_sdk.Asset,
    buying_asset: stellar_sdk.Asset,
    price: Union[str, decimal.Decimal],
):
    &#34;&#34;&#34;Deletes a selling order for amount `amount` of `selling_asset` for `buying_asset` with the price of `price`

    Args:
        selling_asset (stellar_sdk.Asset): Selling Asset object - check wallet object.get_asset_by_code function
        buying_asset (stellar_sdk.Asset): Buying Asset object - Asset object - check wallet object.get_asset_by_code function
        offer_id (int): pass the current offer id and set the amount to 0 to cancel this offer
        price (str): order price
    &#34;&#34;&#34;
    return self._manage_sell_order(
        selling_asset=selling_asset, buying_asset=buying_asset, amount=&#34;0&#34;, price=price, offer_id=offer_id
    )</code></pre>
</details>
</dd>
<dt id="jumpscale.clients.stellar.stellar.Stellar.check_is_payment_transaction"><code class="name flex">
<span>def <span class="ident">check_is_payment_transaction</span></span>(<span>self, transaction_hash)</span>
</code></dt>
<dd>
<section class="desc"><p>Some transactions doesn't have an amount like activating the wallet
This helper method to help in iterating in transactions</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>transaction_hash</code></strong> :&ensp;<code>String</code></dt>
<dd>Transaction hash</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>Bool</code></strong></dt>
<dd>True if transaction has amount - False if not</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def check_is_payment_transaction(self, transaction_hash):
    &#34;&#34;&#34;Some transactions doesn&#39;t have an amount like activating the wallet
    This helper method to help in iterating in transactions

    Args:
        transaction_hash (String): Transaction hash

    Returns:
        Bool: True if transaction has amount - False if not
    &#34;&#34;&#34;

    server = self._get_horizon_server()
    endpoint = server.operations().for_transaction(transaction_hash)
    response = endpoint.call()
    results = response[&#34;_embedded&#34;][&#34;records&#34;][0]
    return results[&#34;type&#34;] == &#34;payment&#34;</code></pre>
</details>
</dd>
<dt id="jumpscale.clients.stellar.stellar.Stellar.claim_locked_funds"><code class="name flex">
<span>def <span class="ident">claim_locked_funds</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def claim_locked_funds(self):
    balances = self.get_balance()
    for locked_account in balances.escrow_accounts:
        if locked_account.can_be_unlocked():
            self._unlock_account(locked_account)</code></pre>
</details>
</dd>
<dt id="jumpscale.clients.stellar.stellar.Stellar.delete_trustline"><code class="name flex">
<span>def <span class="ident">delete_trustline</span></span>(<span>self, asset_code, issuer, secret=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Deletes a trustline</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>asset_code</code></strong> :&ensp;<code>str</code></dt>
<dd>code of the asset. For example: 'BTC', 'XRP', &hellip;</dd>
<dt><strong><code>issuer</code></strong> :&ensp;<code>str</code></dt>
<dd>address of the asset issuer</dd>
<dt><strong><code>secret</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Secret to use will use instance property if empty. Defaults to None.</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def delete_trustline(self, asset_code, issuer, secret=None):
    &#34;&#34;&#34;Deletes a trustline

    Args:
        asset_code (str): code of the asset. For example: &#39;BTC&#39;, &#39;XRP&#39;, ...
        issuer (str): address of the asset issuer
        secret (str, optional): Secret to use will use instance property if empty. Defaults to None.
    &#34;&#34;&#34;
    self._change_trustline(asset_code, issuer, limit=&#34;0&#34;, secret=secret)</code></pre>
</details>
</dd>
<dt id="jumpscale.clients.stellar.stellar.Stellar.get_asset"><code class="name flex">
<span>def <span class="ident">get_asset</span></span>(<span>self, code=&#39;TFT&#39;, issuer=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Gets an stellar_sdk.Asset object by code.
if the code is TFT or TFTA we quickly return the Asset object based on the code.
if the code is native (XLM) we return the Asset object with None issuer.
if the code isn't unknown, exception is raised to manually construct the Asset object.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>code</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>code for the asset. Defaults to "TFT".</dd>
<dt><strong><code>issuer</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>issuer for the asset. Defaults to None.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><strong><code>ValueError</code></strong></dt>
<dd>empty code, In case of issuer is None and not XLM or the code isn't for TFT or TFTA.</dd>
<dt><code>stellar_sdk.exceptions.AssetIssuerInvalidError</code>: <code>Invalid</code> <code>issuer</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>stellar_sdk.Asset: Asset object.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def get_asset(self, code=&#34;TFT&#34;, issuer=None) -&gt; stellar_sdk.Asset:
    &#34;&#34;&#34;Gets an stellar_sdk.Asset object by code.
    if the code is TFT or TFTA we quickly return the Asset object based on the code.
    if the code is native (XLM) we return the Asset object with None issuer.
    if the code isn&#39;t unknown, exception is raised to manually construct the Asset object.

    Args:
        code (str, optional): code for the asset. Defaults to &#34;TFT&#34;.
        issuer (str, optional): issuer for the asset. Defaults to None.

    Raises:
        ValueError: empty code, In case of issuer is None and not XLM or the code isn&#39;t for TFT or TFTA.
        stellar_sdk.exceptions.AssetIssuerInvalidError: Invalid issuer
    Returns:
        stellar_sdk.Asset: Asset object.
    &#34;&#34;&#34;
    network = self.network.value
    KNOWN_ASSETS = list(_NETWORK_KNOWN_TRUSTS[network].keys()) + [&#34;XLM&#34;]

    if issuer and code:
        return Asset(code, issuer)

    if not code:
        raise ValueError(&#34;need to provide code&#34;)

    if not issuer and code not in KNOWN_ASSETS:
        raise ValueError(
            f&#34;Make sure to supply the issuer for {code}, issuer is allowed to be none only in case of {KNOWN_ASSETS}&#34;
        )

    if not issuer and code in KNOWN_ASSETS:
        asset_issuer = _NETWORK_KNOWN_TRUSTS[network].get(code, None)
        return Asset(code, asset_issuer)</code></pre>
</details>
</dd>
<dt id="jumpscale.clients.stellar.stellar.Stellar.get_balance"><code class="name flex">
<span>def <span class="ident">get_balance</span></span>(<span>self, address=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Gets balance for a stellar address</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def get_balance(self, address=None):
    &#34;&#34;&#34;Gets balance for a stellar address
    &#34;&#34;&#34;
    if address is None:
        address = self.address
    all_balances = self._get_free_balances(address)
    for account in self._find_escrow_accounts(address):
        all_balances.add_escrow_account(account)
    return all_balances</code></pre>
</details>
</dd>
<dt id="jumpscale.clients.stellar.stellar.Stellar.get_created_offers"><code class="name flex">
<span>def <span class="ident">get_created_offers</span></span>(<span>self, wallet_address=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns a list of the currently created offers</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>wallet_address</code></strong> :&ensp;<code>Str</code>, optional</dt>
<dd>wallet address you want to get offers to. Defaults to self.address.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def get_created_offers(self, wallet_address: str = None):
    &#34;&#34;&#34;Returns a list of the currently created offers

    Args:
        wallet_address (Str, optional): wallet address you want to get offers to. Defaults to self.address.

    Returns:
        list
    &#34;&#34;&#34;
    wallet_address = wallet_address or self.address
    server = self._get_horizon_server()
    endpoint = server.offers()
    endpoint.account(wallet_address)
    response = endpoint.call()
    offers = response[&#34;_embedded&#34;][&#34;records&#34;]
    return offers</code></pre>
</details>
</dd>
<dt id="jumpscale.clients.stellar.stellar.Stellar.get_data_entries"><code class="name flex">
<span>def <span class="ident">get_data_entries</span></span>(<span>self, address=None)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def get_data_entries(self, address: str = None):
    address = address or self.address
    horizon_server = self._get_horizon_server()
    response = horizon_server.accounts().account_id(address).call()
    data = {}
    for data_name, data_value in response[&#34;data&#34;].items():
        data[data_name] = base64.b64decode(data_value).decode(&#34;utf-8&#34;)
    return data</code></pre>
</details>
</dd>
<dt id="jumpscale.clients.stellar.stellar.Stellar.get_sender_wallet_address"><code class="name flex">
<span>def <span class="ident">get_sender_wallet_address</span></span>(<span>self, transaction_hash)</span>
</code></dt>
<dd>
<section class="desc"><p>Get the sender's wallet address from a transaction hash</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>transaction_hash</code></strong> :&ensp;<code>String</code></dt>
<dd>Transaction hash</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>String</code></strong> :&ensp;<code>Wallet</code> <code>Hash</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def get_sender_wallet_address(self, transaction_hash):
    &#34;&#34;&#34;Get the sender&#39;s wallet address from a transaction hash

    Args:
        transaction_hash (String): Transaction hash

    Returns:
        String : Wallet Hash

    &#34;&#34;&#34;
    server = self._get_horizon_server()
    endpoint = server.operations().for_transaction(transaction_hash)
    response = endpoint.call()
    # not possible for a transaction to have more than a source, so will take first one
    wallet_address = response[&#34;_embedded&#34;][&#34;records&#34;][0][&#34;source_account&#34;]
    return wallet_address</code></pre>
</details>
</dd>
<dt id="jumpscale.clients.stellar.stellar.Stellar.get_signing_requirements"><code class="name flex">
<span>def <span class="ident">get_signing_requirements</span></span>(<span>self, address=None)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def get_signing_requirements(self, address: str = None):
    address = address or self.address
    response = self._get_horizon_server().accounts().account_id(address).call()
    signing_requirements = {}
    signing_requirements[&#34;thresholds&#34;] = response[&#34;thresholds&#34;]
    signing_requirements[&#34;signers&#34;] = response[&#34;signers&#34;]
    return signing_requirements</code></pre>
</details>
</dd>
<dt id="jumpscale.clients.stellar.stellar.Stellar.get_transaction_effects"><code class="name flex">
<span>def <span class="ident">get_transaction_effects</span></span>(<span>self, transaction_hash, address=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Get the effects on an adddressfor a specific transaction</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>transaction_hash</code></strong> :&ensp;<code>str</code></dt>
<dd>hash of the transaction</dd>
<dt><strong><code>address</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>address of the effects.If None, the address of this wallet is taken. Defaults to None.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>list</code></strong></dt>
<dd>list of Effect objects</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def get_transaction_effects(self, transaction_hash, address=None):
    &#34;&#34;&#34;Get the effects on an adddressfor a specific transaction

    Args:
        transaction_hash (str): hash of the transaction
        address (str, optional): address of the effects.If None, the address of this wallet is taken. Defaults to None.

    Returns:
        list: list of Effect objects
    &#34;&#34;&#34;
    address = address or self.address
    effects = []
    endpoint = self._get_horizon_server().effects()
    endpoint.for_transaction(transaction_hash)
    old_cursor = &#34;old&#34;
    new_cursor = &#34;&#34;
    while old_cursor != new_cursor:
        old_cursor = new_cursor
        endpoint.cursor(new_cursor)
        response = endpoint.call()
        next_link = response[&#34;_links&#34;][&#34;next&#34;][&#34;href&#34;]
        next_link_query = parse.urlsplit(next_link).query
        new_cursor = parse.parse_qs(next_link_query)[&#34;cursor&#34;][0]
        response_effects = response[&#34;_embedded&#34;][&#34;records&#34;]
        for response_effect in response_effects:
            if &#34;account&#34; in response_effect and response_effect[&#34;account&#34;] == address:
                effects.append(Effect.from_horizon_response(response_effect))
    return effects</code></pre>
</details>
</dd>
<dt id="jumpscale.clients.stellar.stellar.Stellar.list_payments"><code class="name flex">
<span>def <span class="ident">list_payments</span></span>(<span>self, address=None, asset=None, cursor=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Get the transactions for an adddress
:param address: address of the effects.In None, the address of this wallet is taken
:param asset: stellar asset in the code:issuer form( except for XLM, which does not need an issuer)
:param cursor:pass a cursor to continue after the last call or an empty str to start receivibg a cursor
if a cursor is passed, a tuple of the payments and the cursor is returned</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def list_payments(self, address: str = None, asset: str = None, cursor: str = None):
    &#34;&#34;&#34;Get the transactions for an adddress
    :param address: address of the effects.In None, the address of this wallet is taken
    :param asset: stellar asset in the code:issuer form( except for XLM, which does not need an issuer)
    :param cursor:pass a cursor to continue after the last call or an empty str to start receivibg a cursor
     if a cursor is passed, a tuple of the payments and the cursor is returned
    &#34;&#34;&#34;
    if address is None:
        address = self.address
    tx_endpoint = self._get_horizon_server().payments()
    tx_endpoint.for_account(address)
    tx_endpoint.limit(50)
    payments = []
    old_cursor = &#34;old&#34;
    new_cursor = &#34;&#34;
    if cursor is not None:
        new_cursor = cursor
    while old_cursor != new_cursor:
        old_cursor = new_cursor
        tx_endpoint.cursor(new_cursor)
        response = tx_endpoint.call()
        next_link = response[&#34;_links&#34;][&#34;next&#34;][&#34;href&#34;]
        next_link_query = parse.urlsplit(next_link).query
        new_cursor = parse.parse_qs(next_link_query)[&#34;cursor&#34;][0]
        response_payments = response[&#34;_embedded&#34;][&#34;records&#34;]
        for response_payment in response_payments:
            ps = PaymentSummary.from_horizon_response(response_payment, address)
            if asset:
                split_asset = asset.split(&#34;:&#34;)
                assetcode = split_asset[0]
                assetissuer = None
                if len(split_asset) &gt; 1:
                    assetissuer = split_asset[1]
                if ps.balance and ps.balance.asset_code == assetcode:
                    if assetissuer and assetissuer == ps.balance.asset_issuer:
                        payments.append(ps)
            else:
                payments.append(ps)
    if cursor is not None:
        return {&#34;payments&#34;: payments, &#34;cursor&#34;: new_cursor}

    return payments</code></pre>
</details>
</dd>
<dt id="jumpscale.clients.stellar.stellar.Stellar.list_transactions"><code class="name flex">
<span>def <span class="ident">list_transactions</span></span>(<span>self, address=None, cursor=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Get the transactions for an adddres
:param address (str, optional): address of the effects.If None, the address of this wallet is taken. Defaults to None.
:param cursor:pass a cursor to continue after the last call or an empty str to start receivibg a cursor
if a cursor is passed, a tuple of the payments and the cursor is returned</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>list</code></strong></dt>
<dd>list of TransactionSummary objects</dd>
<dt><strong><code>dictionary</code></strong></dt>
<dd>{"transactions":list of TransactionSummary objects, "cursor":cursor}</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def list_transactions(self, address: str = None, cursor: str = None):
    &#34;&#34;&#34;Get the transactions for an adddres
    :param address (str, optional): address of the effects.If None, the address of this wallet is taken. Defaults to None.
    :param cursor:pass a cursor to continue after the last call or an empty str to start receivibg a cursor
     if a cursor is passed, a tuple of the payments and the cursor is returned

    Returns:
        list: list of TransactionSummary objects
        dictionary: {&#34;transactions&#34;:list of TransactionSummary objects, &#34;cursor&#34;:cursor}
    &#34;&#34;&#34;
    address = address or self.address
    tx_endpoint = self._get_horizon_server().transactions()
    tx_endpoint.for_account(address)
    tx_endpoint.include_failed(True)
    transactions = []
    old_cursor = &#34;old&#34;
    new_cursor = &#34;&#34;
    if cursor is not None:
        new_cursor = cursor
    while old_cursor != new_cursor:
        old_cursor = new_cursor
        tx_endpoint.cursor(new_cursor)
        response = tx_endpoint.call()
        next_link = response[&#34;_links&#34;][&#34;next&#34;][&#34;href&#34;]
        next_link_query = parse.urlsplit(next_link).query
        new_cursor = parse.parse_qs(next_link_query)[&#34;cursor&#34;][0]
        response_transactions = response[&#34;_embedded&#34;][&#34;records&#34;]
        for response_transaction in response_transactions:
            if response_transaction[&#34;successful&#34;]:
                transactions.append(TransactionSummary.from_horizon_response(response_transaction))

    if cursor is not None:
        return {&#34;transactions&#34;: transactions, &#34;cursor&#34;: new_cursor}
    return transactions</code></pre>
</details>
</dd>
<dt id="jumpscale.clients.stellar.stellar.Stellar.load_account"><code class="name flex">
<span>def <span class="ident">load_account</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def load_account(self):
    horizonServer = self._get_horizon_server()
    saccount = horizonServer.load_account(self.address)
    account = Account(saccount.account_id, saccount.sequence, self)
    return account</code></pre>
</details>
</dd>
<dt id="jumpscale.clients.stellar.stellar.Stellar.modify_signing_requirements"><code class="name flex">
<span>def <span class="ident">modify_signing_requirements</span></span>(<span>self, public_keys_signers, signature_count, low_treshold=0, high_treshold=2, master_weight=2)</span>
</code></dt>
<dd>
<section class="desc"><p>modify_signing_requirements sets to amount of signatures required for the creation of multisig account. It also adds
the public keys of the signer to this account</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>public_keys_signers</code></strong> :&ensp;<code>list</code></dt>
<dd>list of public keys of signers</dd>
<dt><strong><code>signature_count</code></strong> :&ensp;<code>int</code></dt>
<dd>amount of signatures requires to transfer funds</dd>
<dt><strong><code>low_treshold</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>amount of signatures required for low security operations (transaction processing, allow trust, bump sequence). Defaults to 1.</dd>
<dt><strong><code>high_treshold</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>amount of signatures required for high security operations (set options, account merge). Defaults to 2.</dd>
<dt><strong><code>master_weight</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>A number from 0-255 (inclusive) representing the weight of the master key. If the weight of the master key is updated to 0, it is effectively disabled. Defaults to 2.</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def modify_signing_requirements(
    self, public_keys_signers, signature_count, low_treshold=0, high_treshold=2, master_weight=2
):
    &#34;&#34;&#34;modify_signing_requirements sets to amount of signatures required for the creation of multisig account. It also adds
       the public keys of the signer to this account

    Args:
        public_keys_signers (list): list of public keys of signers
        signature_count (int): amount of signatures requires to transfer funds
        low_treshold (int, optional): amount of signatures required for low security operations (transaction processing, allow trust, bump sequence). Defaults to 1.
        high_treshold (int, optional): amount of signatures required for high security operations (set options, account merge). Defaults to 2.
        master_weight (int, optional): A number from 0-255 (inclusive) representing the weight of the master key. If the weight of the master key is updated to 0, it is effectively disabled. Defaults to 2.
    &#34;&#34;&#34;
    server = self._get_horizon_server()
    account = self.load_account()
    source_keypair = stellar_sdk.Keypair.from_secret(self.secret)

    transaction_builder = stellar_sdk.TransactionBuilder(account)
    # set the signing options
    transaction_builder.append_set_options_op(
        low_threshold=low_treshold,
        med_threshold=signature_count,
        high_threshold=high_treshold,
        master_weight=master_weight,
    )

    # For every public key given, add it as a signer to this account
    for public_key_signer in public_keys_signers:
        transaction_builder.append_ed25519_public_key_signer(public_key_signer, 1)

    transaction_builder.set_timeout(30)
    tx = transaction_builder.build()
    tx.sign(source_keypair)

    try:
        response = server.submit_transaction(tx)
        j.logger.info(response)
        j.logger.info(f&#34;Set the signers of {self.address} to require {signature_count} signers&#34;)
    except stellar_sdk.exceptions.BadRequestError:
        j.logger.info(&#34;Transaction need additional signatures in order to send&#34;)
        return tx.to_xdr()</code></pre>
</details>
</dd>
<dt id="jumpscale.clients.stellar.stellar.Stellar.place_sell_order"><code class="name flex">
<span>def <span class="ident">place_sell_order</span></span>(<span>self, selling_asset, buying_asset, amount, price, timeout=30, offer_id=0)</span>
</code></dt>
<dd>
<section class="desc"><p>Places/Deletes a selling order for amount <code>amount</code> of <code>selling_asset</code> for <code>buying_asset</code> with the price of <code>price</code></p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>selling_asset</code></strong> :&ensp;<code>stellar_sdk.Asset</code></dt>
<dd>Selling Asset object - check wallet object.get_asset_by_code function</dd>
<dt><strong><code>buying_asset</code></strong> :&ensp;<code>stellar_sdk.Asset</code></dt>
<dd>Buying Asset object - Asset object - check wallet object.get_asset_by_code function</dd>
<dt><strong><code>amount</code></strong> :&ensp;<code>Union</code>[<code>str</code>, <code>decimal.Decimal</code>]</dt>
<dd>Amount to sell.</dd>
<dt><strong><code>price</code></strong> :&ensp;<code>Union</code>[<code>str</code>, <code>decimal.Decimal</code>]</dt>
<dd>Price for selling.</dd>
<dt><strong><code>timeout</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Timeout for submitting the transaction. Defaults to 30.</dd>
<dt><strong><code>offer_id</code></strong></dt>
<dd>pass the current offer id and set the amount to 0 to cancel this offer or another amount to update the offer</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><strong><code>ValueError</code></strong></dt>
<dd>In case of invalid issuer.</dd>
<dt><strong><code>RuntimeError</code></strong></dt>
<dd>Error happened during submission of the transaction.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>(dict): response as the result of sumbit the transaction</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def _manage_sell_order(
    self,
    selling_asset: stellar_sdk.Asset,
    buying_asset: stellar_sdk.Asset,
    amount: Union[str, decimal.Decimal],
    price: Union[str, decimal.Decimal],
    timeout=30,
    offer_id=0,
):
    &#34;&#34;&#34;Places/Deletes a selling order for amount `amount` of `selling_asset` for `buying_asset` with the price of `price`

    Args:
        selling_asset (stellar_sdk.Asset): Selling Asset object - check wallet object.get_asset_by_code function
        buying_asset (stellar_sdk.Asset): Buying Asset object - Asset object - check wallet object.get_asset_by_code function
        amount (Union[str, decimal.Decimal]): Amount to sell.
        price (Union[str, decimal.Decimal]): Price for selling.
        timeout (int, optional): Timeout for submitting the transaction. Defaults to 30.
        offer_id: pass the current offer id and set the amount to 0 to cancel this offer or another amount to update the offer

    Raises:
        ValueError: In case of invalid issuer.
        RuntimeError: Error happened during submission of the transaction.

    Returns:
        (dict): response as the result of sumbit the transaction
    &#34;&#34;&#34;
    server = self._get_horizon_server()
    tb = TransactionBuilder(self.load_account(), network_passphrase=_NETWORK_PASSPHRASES[self.network.value])
    try:
        tx = (
            tb.append_manage_sell_offer_op(
                selling_code=selling_asset.code,
                selling_issuer=selling_asset.issuer,
                buying_code=buying_asset.code,
                buying_issuer=buying_asset.issuer,
                amount=amount,
                price=price,
                offer_id=offer_id,
            )
            .set_timeout(timeout)
            .build()
        )
    except stellar_sdk.exceptions.AssetIssuerInvalidError as e:
        raise ValueError(&#34;invalid issuer&#34;) from e
    except Exception as e:
        raise RuntimeError(
            f&#34;error happened for placing selling order for selling: {selling_asset}, buying: {buying_asset}, amount: {amount} price: {price}&#34;
        ) from e
    else:
        tx.sign(self.secret)
        try:
            resp = server.submit_transaction(tx)
        except Exception as e:
            raise RuntimeError(
                f&#34;couldn&#39;t submit sell offer, probably wallet is unfunded. Please check the error stacktrace for more information.&#34;
            ) from e
        return resp</code></pre>
</details>
</dd>
<dt id="jumpscale.clients.stellar.stellar.Stellar.remove_signer"><code class="name flex">
<span>def <span class="ident">remove_signer</span></span>(<span>self, public_key_signer)</span>
</code></dt>
<dd>
<section class="desc"><p>remove_signer removes a public key as a signer from the source account</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>public_key_signer</code></strong> :&ensp;<code>str</code></dt>
<dd>public key of an account</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def remove_signer(self, public_key_signer):
    &#34;&#34;&#34;remove_signer removes a public key as a signer from the source account

    Args:
        public_key_signer (str): public key of an account
    &#34;&#34;&#34;
    server = self._get_horizon_server()
    account = self.load_account()
    tx = stellar_sdk.TransactionBuilder(account).append_ed25519_public_key_signer(public_key_signer, 0).build()

    source_keypair = stellar_sdk.Keypair.from_secret(self.secret)

    tx.sign(source_keypair)
    try:
        response = server.submit_transaction(tx)
        j.logger.info(response)
        j.logger.info(&#34;Multisig tx signed and sent&#34;)
    except stellar_sdk.exceptions.BadRequestError:
        j.logger.info(&#34;Transaction need additional signatures in order to send&#34;)
        return tx.to_xdr()</code></pre>
</details>
</dd>
<dt id="jumpscale.clients.stellar.stellar.Stellar.secret_updated"><code class="name flex">
<span>def <span class="ident">secret_updated</span></span>(<span>self, value)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def secret_updated(self, value):
    self.address = stellar_sdk.Keypair.from_secret(value).public_key</code></pre>
</details>
</dd>
<dt id="jumpscale.clients.stellar.stellar.Stellar.set_data_entry"><code class="name flex">
<span>def <span class="ident">set_data_entry</span></span>(<span>self, name, value, address=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Sets, modifies or deletes a data entry (name/value pair) for an account</p>
<p>To delete a data entry, set the value to an empty string.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def set_data_entry(self, name: str, value: str, address: str = None):
    &#34;&#34;&#34;Sets, modifies or deletes a data entry (name/value pair) for an account

    To delete a data entry, set the value to an empty string.

    &#34;&#34;&#34;

    address = address or self.address
    signing_key = stellar_sdk.Keypair.from_secret(self.secret)
    horizon_server = self._get_horizon_server()
    if address == self.address:
        account = self.load_account()
    else:
        account = horizon_server.load_account(address)
    base_fee = horizon_server.fetch_base_fee()
    transaction = (
        stellar_sdk.TransactionBuilder(
            source_account=account, network_passphrase=_NETWORK_PASSPHRASES[self.network.value], base_fee=base_fee,
        )
        .append_manage_data_op(name, value)
        .set_timeout(30)
        .build()
    )

    transaction.sign(signing_key)

    try:
        response = horizon_server.submit_transaction(transaction)
        j.logger.info(&#34;Transaction hash: {}&#34;.format(response[&#34;hash&#34;]))
    except stellar_sdk.exceptions.BadRequestError as e:
        j.logger.debug(e)
        raise e</code></pre>
</details>
</dd>
<dt id="jumpscale.clients.stellar.stellar.Stellar.set_unlock_transaction"><code class="name flex">
<span>def <span class="ident">set_unlock_transaction</span></span>(<span>self, unlock_transaction)</span>
</code></dt>
<dd>
<section class="desc"><p>Adds a xdr encoded unlocktransaction
:param unlock_transaction: xdr encoded unlocktransactionaddress of the destination.
:type destination_address: str</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def set_unlock_transaction(self, unlock_transaction):
    &#34;&#34;&#34;
    Adds a xdr encoded unlocktransaction
    :param unlock_transaction: xdr encoded unlocktransactionaddress of the destination.
    :type destination_address: str
    &#34;&#34;&#34;
    txe = stellar_sdk.TransactionEnvelope.from_xdr(unlock_transaction, _NETWORK_PASSPHRASES[self.network.value])
    tx_hash = txe.hash()
    unlock_hash = stellar_sdk.strkey.StrKey.encode_pre_auth_tx(tx_hash)

    self._create_unlockhash_transaction(unlock_hash=unlock_hash, transaction_xdr=txe.to_xdr())</code></pre>
</details>
</dd>
<dt id="jumpscale.clients.stellar.stellar.Stellar.sign"><code class="name flex">
<span>def <span class="ident">sign</span></span>(<span>self, tx_xdr, submit=True)</span>
</code></dt>
<dd>
<section class="desc"><p>sign signs a transaction xdr and optionally submits it to the network</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>tx_xdr</code></strong> :&ensp;<code>str</code></dt>
<dd>transaction to sign in xdr format</dd>
<dt><strong><code>submit</code></strong> :&ensp;<code>bool</code>,optional</dt>
<dd>submit the transaction tro the Stellar network</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def sign(self, tx_xdr: str, submit: bool = True):
    &#34;&#34;&#34; sign signs a transaction xdr and optionally submits it to the network

    Args:
        tx_xdr (str): transaction to sign in xdr format
        submit (bool,optional): submit the transaction tro the Stellar network
    &#34;&#34;&#34;

    source_keypair = stellar_sdk.Keypair.from_secret(self.secret)
    tx = stellar_sdk.TransactionEnvelope.from_xdr(tx_xdr, _NETWORK_PASSPHRASES[self.network.value])
    tx.sign(source_keypair)
    if submit:
        horizon_server = self._get_horizon_server()
        horizon_server.submit_transaction(tx)
    else:
        return tx.to_xdr()</code></pre>
</details>
</dd>
<dt id="jumpscale.clients.stellar.stellar.Stellar.sign_multisig_transaction"><code class="name flex">
<span>def <span class="ident">sign_multisig_transaction</span></span>(<span>self, tx_xdr)</span>
</code></dt>
<dd>
<section class="desc"><p>sign_multisig_transaction signs a transaction xdr and tries to submit it to the network</p>
<p>Deprecated, use sign instead</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>tx_xdr</code></strong> :&ensp;<code>str</code></dt>
<dd>transaction to sign in xdr format</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def sign_multisig_transaction(self, tx_xdr):
    &#34;&#34;&#34;sign_multisig_transaction signs a transaction xdr and tries to submit it to the network

       Deprecated, use sign instead

    Args:
        tx_xdr (str): transaction to sign in xdr format
    &#34;&#34;&#34;

    try:
        self.sign(tx_xdr)
        j.logger.info(&#34;Multisig tx signed and sent&#34;)
    except UnAuthorized as e:
        j.logger.info(&#34;Transaction needs additional signatures in order to send&#34;)
        return e.transaction_xdr</code></pre>
</details>
</dd>
<dt id="jumpscale.clients.stellar.stellar.Stellar.transfer"><code class="name flex">
<span>def <span class="ident">transfer</span></span>(<span>self, destination_address, amount, asset=&#39;XLM&#39;, locked_until=None, memo_text=None, memo_hash=None, fund_transaction=True, from_address=None, timeout=30, sequence_number=None, sign=True)</span>
</code></dt>
<dd>
<section class="desc"><p>Transfer assets to another address</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>destination_address</code></strong> :&ensp;<code>str</code></dt>
<dd>address of the destination</dd>
<dt><strong><code>amount</code></strong> :&ensp;<code>str</code></dt>
<dd>can be a floating point number with 7 numbers after the decimal point expressed as a string</dd>
<dt><strong><code>asset</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>asset to transfer. Defaults to "XLM". if you wish to specify an asset it should be in format 'assetcode:issuer'. Where issuer is the address of the</dd>
<dt>issuer of the asset.</dt>
<dt><strong><code>locked_until</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>epoch timestamp indicating until when the tokens
should be locked. Defaults to None.</dd>
<dt><strong><code>memo_text</code></strong> :&ensp;<code>Union</code>[<code>str</code>, <code>bytes</code>], optional</dt>
<dd>memo text to add to the transaction, a string encoded using either ASCII or UTF-8, up to 28-bytes long. Defaults to None.</dd>
<dt><strong><code>memo_hash</code></strong> :&ensp;<code>Union</code>[<code>str</code>, <code>bytes</code>], optional</dt>
<dd>memo hash to add to the transaction, A 32 byte hash. Defaults to None.</dd>
<dt><strong><code>fund_transaction</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>use the threefoldfoundation transaction funding service. Defautls to True.</dd>
<dt><strong><code>from_address</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Use a different address to send the tokens from, useful in multisig use cases. Defaults to None.</dd>
<dt>timeout (int,optional: Seconds from now on until when the transaction to be submitted to the stellar network</dt>
<dt><strong><code>sequence_number</code></strong> :&ensp;<code>int</code>,optional</dt>
<dd>specify a specific sequence number ( will still be increased by one) instead of loading it from the account</dd>
</dl>
<p>sign (bool,optional) : Do not sign and submit the transaction</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><strong><code>Exception</code></strong></dt>
<dd>If asset not in correct format</dd>
<dt><code>stellar_sdk.exceptions.BadRequestError</code>: <code>not</code> <code>enough</code> <code>funds</code> <code>for</code> <code>opertaion</code></dt>
<dd>&nbsp;</dd>
<dt><code>stellar_sdk.exceptions.BadRequestError</code>: <code>bad</code> <code>transfer</code> <code>authentication</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def transfer(
    self,
    destination_address,
    amount,
    asset=&#34;XLM&#34;,
    locked_until=None,
    memo_text=None,
    memo_hash=None,
    fund_transaction=True,
    from_address=None,
    timeout=30,
    sequence_number: int = None,
    sign: bool = True,
):
    &#34;&#34;&#34;Transfer assets to another address

    Args:
        destination_address (str): address of the destination
        amount (str): can be a floating point number with 7 numbers after the decimal point expressed as a string
        asset (str, optional): asset to transfer. Defaults to &#34;XLM&#34;. if you wish to specify an asset it should be in format &#39;assetcode:issuer&#39;. Where issuer is the address of the
        issuer of the asset.
        locked_until (float, optional): epoch timestamp indicating until when the tokens  should be locked. Defaults to None.
        memo_text (Union[str, bytes], optional): memo text to add to the transaction, a string encoded using either ASCII or UTF-8, up to 28-bytes long. Defaults to None.
        memo_hash (Union[str, bytes], optional): memo hash to add to the transaction, A 32 byte hash. Defaults to None.
        fund_transaction (bool, optional): use the threefoldfoundation transaction funding service. Defautls to True.
        from_address (str, optional): Use a different address to send the tokens from, useful in multisig use cases. Defaults to None.
        timeout (int,optional: Seconds from now on until when the transaction to be submitted to the stellar network
        sequence_number (int,optional): specify a specific sequence number ( will still be increased by one) instead of loading it from the account
        sign (bool,optional) : Do not sign and submit the transaction

    Raises:
        Exception: If asset not in correct format
        stellar_sdk.exceptions.BadRequestError: not enough funds for opertaion
        stellar_sdk.exceptions.BadRequestError: bad transfer authentication

    Returns:
        [type]: [description]
    &#34;&#34;&#34;
    issuer = None
    j.logger.info(f&#34;Sending {amount} {asset} to {destination_address}&#34;)
    if asset != &#34;XLM&#34;:
        assetStr = asset.split(&#34;:&#34;)
        if len(assetStr) != 2:
            raise Exception(f&#34;Wrong asset format should be in format &#39;assetcode:issuer&#39;, but received {assetStr}&#34;)
        asset = assetStr[0]
        issuer = assetStr[1]

    if locked_until is not None:
        return self._transfer_locked_tokens(
            destination_address,
            amount,
            asset,
            issuer,
            locked_until,
            memo_text=memo_text,
            memo_hash=memo_hash,
            fund_transaction=fund_transaction,
            from_address=from_address,
        )

    horizon_server = self._get_horizon_server()

    base_fee = horizon_server.fetch_base_fee()
    if from_address:
        source_account = horizon_server.load_account(from_address)
    else:
        source_account = self.load_account()

    if sequence_number:
        source_account.sequence = sequence_number

    transaction_builder = stellar_sdk.TransactionBuilder(
        source_account=source_account,
        network_passphrase=_NETWORK_PASSPHRASES[self.network.value],
        base_fee=base_fee,
    )
    transaction_builder.append_payment_op(
        destination=destination_address,
        amount=str(amount),
        asset_code=asset,
        asset_issuer=issuer,
        source=source_account.account_id,
    )
    transaction_builder.set_timeout(timeout)
    if memo_text is not None:
        transaction_builder.add_text_memo(memo_text)
    if memo_hash is not None:
        transaction_builder.add_hash_memo(memo_hash)

    transaction = transaction_builder.build()
    transaction = transaction.to_xdr()

    if asset == &#34;TFT&#34; or asset == &#34;FreeTFT&#34;:
        if fund_transaction:
            transaction = self._fund_transaction(transaction=transaction)
            transaction = transaction[&#34;transaction_xdr&#34;]

    if not sign:
        return transaction

    transaction = stellar_sdk.TransactionEnvelope.from_xdr(transaction, _NETWORK_PASSPHRASES[self.network.value])

    my_keypair = stellar_sdk.Keypair.from_secret(self.secret)
    transaction.sign(my_keypair)
    response = horizon_server.submit_transaction(transaction)
    tx_hash = response[&#34;hash&#34;]
    j.logger.info(f&#34;Transaction hash: {tx_hash}&#34;)
    return tx_hash</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="jumpscale.clients.base.Client" href="../base.html#jumpscale.clients.base.Client">Client</a></b></code>:
<ul class="hlist">
<li><code><a title="jumpscale.clients.base.Client.from_dict" href="../../core/base/meta.html#jumpscale.core.base.meta.Base.from_dict">from_dict</a></code></li>
<li><code><a title="jumpscale.clients.base.Client.to_dict" href="../../core/base/meta.html#jumpscale.core.base.meta.Base.to_dict">to_dict</a></code></li>
<li><code><a title="jumpscale.clients.base.Client.validate" href="../../core/base/meta.html#jumpscale.core.base.meta.Base.validate">validate</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="jumpscale.clients.stellar" href="index.html">jumpscale.clients.stellar</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="jumpscale.clients.stellar.stellar.Network" href="#jumpscale.clients.stellar.stellar.Network">Network</a></code></h4>
<ul class="">
<li><code><a title="jumpscale.clients.stellar.stellar.Network.STD" href="#jumpscale.clients.stellar.stellar.Network.STD">STD</a></code></li>
<li><code><a title="jumpscale.clients.stellar.stellar.Network.TEST" href="#jumpscale.clients.stellar.stellar.Network.TEST">TEST</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="jumpscale.clients.stellar.stellar.Stellar" href="#jumpscale.clients.stellar.stellar.Stellar">Stellar</a></code></h4>
<ul class="">
<li><code><a title="jumpscale.clients.stellar.stellar.Stellar.activate_account" href="#jumpscale.clients.stellar.stellar.Stellar.activate_account">activate_account</a></code></li>
<li><code><a title="jumpscale.clients.stellar.stellar.Stellar.activate_through_friendbot" href="#jumpscale.clients.stellar.stellar.Stellar.activate_through_friendbot">activate_through_friendbot</a></code></li>
<li><code><a title="jumpscale.clients.stellar.stellar.Stellar.activate_through_threefold_service" href="#jumpscale.clients.stellar.stellar.Stellar.activate_through_threefold_service">activate_through_threefold_service</a></code></li>
<li><code><a title="jumpscale.clients.stellar.stellar.Stellar.add_known_trustline" href="#jumpscale.clients.stellar.stellar.Stellar.add_known_trustline">add_known_trustline</a></code></li>
<li><code><a title="jumpscale.clients.stellar.stellar.Stellar.add_trustline" href="#jumpscale.clients.stellar.stellar.Stellar.add_trustline">add_trustline</a></code></li>
<li><code><a title="jumpscale.clients.stellar.stellar.Stellar.address" href="#jumpscale.clients.stellar.stellar.Stellar.address">address</a></code></li>
<li><code><a title="jumpscale.clients.stellar.stellar.Stellar.cancel_sell_order" href="#jumpscale.clients.stellar.stellar.Stellar.cancel_sell_order">cancel_sell_order</a></code></li>
<li><code><a title="jumpscale.clients.stellar.stellar.Stellar.check_is_payment_transaction" href="#jumpscale.clients.stellar.stellar.Stellar.check_is_payment_transaction">check_is_payment_transaction</a></code></li>
<li><code><a title="jumpscale.clients.stellar.stellar.Stellar.claim_locked_funds" href="#jumpscale.clients.stellar.stellar.Stellar.claim_locked_funds">claim_locked_funds</a></code></li>
<li><code><a title="jumpscale.clients.stellar.stellar.Stellar.delete_trustline" href="#jumpscale.clients.stellar.stellar.Stellar.delete_trustline">delete_trustline</a></code></li>
<li><code><a title="jumpscale.clients.stellar.stellar.Stellar.get_asset" href="#jumpscale.clients.stellar.stellar.Stellar.get_asset">get_asset</a></code></li>
<li><code><a title="jumpscale.clients.stellar.stellar.Stellar.get_balance" href="#jumpscale.clients.stellar.stellar.Stellar.get_balance">get_balance</a></code></li>
<li><code><a title="jumpscale.clients.stellar.stellar.Stellar.get_created_offers" href="#jumpscale.clients.stellar.stellar.Stellar.get_created_offers">get_created_offers</a></code></li>
<li><code><a title="jumpscale.clients.stellar.stellar.Stellar.get_data_entries" href="#jumpscale.clients.stellar.stellar.Stellar.get_data_entries">get_data_entries</a></code></li>
<li><code><a title="jumpscale.clients.stellar.stellar.Stellar.get_sender_wallet_address" href="#jumpscale.clients.stellar.stellar.Stellar.get_sender_wallet_address">get_sender_wallet_address</a></code></li>
<li><code><a title="jumpscale.clients.stellar.stellar.Stellar.get_signing_requirements" href="#jumpscale.clients.stellar.stellar.Stellar.get_signing_requirements">get_signing_requirements</a></code></li>
<li><code><a title="jumpscale.clients.stellar.stellar.Stellar.get_transaction_effects" href="#jumpscale.clients.stellar.stellar.Stellar.get_transaction_effects">get_transaction_effects</a></code></li>
<li><code><a title="jumpscale.clients.stellar.stellar.Stellar.list_payments" href="#jumpscale.clients.stellar.stellar.Stellar.list_payments">list_payments</a></code></li>
<li><code><a title="jumpscale.clients.stellar.stellar.Stellar.list_transactions" href="#jumpscale.clients.stellar.stellar.Stellar.list_transactions">list_transactions</a></code></li>
<li><code><a title="jumpscale.clients.stellar.stellar.Stellar.load_account" href="#jumpscale.clients.stellar.stellar.Stellar.load_account">load_account</a></code></li>
<li><code><a title="jumpscale.clients.stellar.stellar.Stellar.modify_signing_requirements" href="#jumpscale.clients.stellar.stellar.Stellar.modify_signing_requirements">modify_signing_requirements</a></code></li>
<li><code><a title="jumpscale.clients.stellar.stellar.Stellar.network" href="#jumpscale.clients.stellar.stellar.Stellar.network">network</a></code></li>
<li><code><a title="jumpscale.clients.stellar.stellar.Stellar.place_sell_order" href="#jumpscale.clients.stellar.stellar.Stellar.place_sell_order">place_sell_order</a></code></li>
<li><code><a title="jumpscale.clients.stellar.stellar.Stellar.remove_signer" href="#jumpscale.clients.stellar.stellar.Stellar.remove_signer">remove_signer</a></code></li>
<li><code><a title="jumpscale.clients.stellar.stellar.Stellar.secret" href="#jumpscale.clients.stellar.stellar.Stellar.secret">secret</a></code></li>
<li><code><a title="jumpscale.clients.stellar.stellar.Stellar.secret_updated" href="#jumpscale.clients.stellar.stellar.Stellar.secret_updated">secret_updated</a></code></li>
<li><code><a title="jumpscale.clients.stellar.stellar.Stellar.set_data_entry" href="#jumpscale.clients.stellar.stellar.Stellar.set_data_entry">set_data_entry</a></code></li>
<li><code><a title="jumpscale.clients.stellar.stellar.Stellar.set_unlock_transaction" href="#jumpscale.clients.stellar.stellar.Stellar.set_unlock_transaction">set_unlock_transaction</a></code></li>
<li><code><a title="jumpscale.clients.stellar.stellar.Stellar.sign" href="#jumpscale.clients.stellar.stellar.Stellar.sign">sign</a></code></li>
<li><code><a title="jumpscale.clients.stellar.stellar.Stellar.sign_multisig_transaction" href="#jumpscale.clients.stellar.stellar.Stellar.sign_multisig_transaction">sign_multisig_transaction</a></code></li>
<li><code><a title="jumpscale.clients.stellar.stellar.Stellar.transfer" href="#jumpscale.clients.stellar.stellar.Stellar.transfer">transfer</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.6.4</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>
