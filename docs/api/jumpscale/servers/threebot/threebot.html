<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>jumpscale.servers.threebot.threebot API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>jumpscale.servers.threebot.threebot</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from jumpscale.loader import j

import imp
import os
import sys
import toml
import shutil
import gevent
import signal
from urllib.parse import urlparse
from gevent.pywsgi import WSGIServer
from jumpscale.core.base import Base, fields
from jumpscale import packages as pkgnamespace
from jumpscale.sals.nginx.nginx import LocationType, PORTS
from jumpscale.sals.nginx.nginx import LocationType, PORTS, AcmeServer
from jumpscale.servers.appserver import StripPathMiddleware, apply_main_middlewares


GEDIS = &#34;gedis&#34;
GEDIS_HTTP = &#34;gedis_http&#34;
GEDIS_HTTP_HOST = &#34;127.0.0.1&#34;
GEDIS_HTTP_PORT = 8000
SERVICE_MANAGER = &#34;service_manager&#34;
CHATFLOW_SERVER_HOST = &#34;127.0.0.1&#34;
CHATFLOW_SERVER_PORT = 31000
DEFAULT_PACKAGES = {
    &#34;auth&#34;: {&#34;path&#34;: os.path.dirname(j.packages.auth.__file__), &#34;giturl&#34;: &#34;&#34;},
    &#34;chatflows&#34;: {&#34;path&#34;: os.path.dirname(j.packages.chatflows.__file__), &#34;giturl&#34;: &#34;&#34;},
    &#34;admin&#34;: {&#34;path&#34;: os.path.dirname(j.packages.admin.__file__), &#34;giturl&#34;: &#34;&#34;},
    &#34;weblibs&#34;: {&#34;path&#34;: os.path.dirname(j.packages.weblibs.__file__), &#34;giturl&#34;: &#34;&#34;},
    &#34;backup&#34;: {&#34;path&#34;: os.path.dirname(j.packages.backup.__file__), &#34;giturl&#34;: &#34;&#34;},
}
DOWNLOADED_PACKAGES_PATH = j.sals.fs.join_paths(j.core.dirs.VARDIR, &#34;downloaded_packages&#34;)


class NginxPackageConfig:
    def __init__(self, package):
        self.package = package
        self.nginx = j.sals.nginx.get(&#34;main&#34;)

    @property
    def default_config(self):
        default_server = {
            &#34;name&#34;: &#34;default&#34;,
            &#34;ports&#34;: self.package.config.get(&#34;ports&#34;),
            &#34;locations&#34;: self.package.config.get(&#34;locations&#34;, []),
            &#34;domain&#34;: self.package.default_domain,
            &#34;letsencryptemail&#34;: self.package.default_email,
            &#34;acme_server_type&#34;: self.package.default_acme_server_type,
            &#34;acme_server_url&#34;: self.package.default_acme_server_url,
        }

        is_auth = self.package.config.get(&#34;is_auth&#34;, True)
        is_admin = self.package.config.get(&#34;is_admin&#34;, True)
        is_package_authorized = self.package.config.get(&#34;is_package_authorized&#34;, False)

        for static_dir in self.package.static_dirs:
            path_url = j.data.text.removeprefix(static_dir.get(&#34;path_url&#34;), &#34;/&#34;)
            default_server[&#34;locations&#34;].append(
                {
                    &#34;is_auth&#34;: static_dir.get(&#34;is_auth&#34;, is_auth),
                    &#34;is_admin&#34;: static_dir.get(&#34;is_admin&#34;, is_admin),
                    &#34;is_package_authorized&#34;: static_dir.get(&#34;is_package_authorized&#34;, is_package_authorized),
                    &#34;type&#34;: &#34;static&#34;,
                    &#34;name&#34;: static_dir.get(&#34;name&#34;),
                    &#34;spa&#34;: static_dir.get(&#34;spa&#34;),
                    &#34;index&#34;: static_dir.get(&#34;index&#34;),
                    &#34;path_url&#34;: j.sals.fs.join_paths(self.package.base_url, path_url),
                    &#34;path_location&#34;: self.package.resolve_staticdir_location(static_dir),
                    &#34;force_https&#34;: self.package.config.get(&#34;force_https&#34;, True),
                }
            )

        for bottle_server in self.package.bottle_servers:
            path_url = j.data.text.removeprefix(bottle_server.get(&#34;path_url&#34;), &#34;/&#34;)
            if hasattr(bottle_server, &#34;standalone&#34;) and bottle_server.standalone:
                default_server[&#34;locations&#34;].append(
                    {
                        &#34;is_auth&#34;: bottle_server.get(&#34;is_auth&#34;, is_auth),
                        &#34;is_admin&#34;: bottle_server.get(&#34;is_admin&#34;, is_admin),
                        &#34;is_package_authorized&#34;: bottle_server.get(&#34;is_package_authorized&#34;, is_package_authorized),
                        &#34;type&#34;: &#34;proxy&#34;,
                        &#34;name&#34;: bottle_server.get(&#34;name&#34;),
                        &#34;host&#34;: bottle_server.get(&#34;host&#34;),
                        &#34;port&#34;: bottle_server.get(&#34;port&#34;),
                        &#34;path_url&#34;: j.sals.fs.join_paths(self.package.base_url,),
                        &#34;path_dest&#34;: bottle_server.get(&#34;path_dest&#34;),
                        &#34;websocket&#34;: bottle_server.get(&#34;websocket&#34;),
                        &#34;force_https&#34;: self.package.config.get(&#34;force_https&#34;, True),
                    }
                )
            else:
                path_url = j.data.text.removeprefix(bottle_server.get(&#34;path_url&#34;), &#34;/&#34;)
                default_server[&#34;locations&#34;].append(
                    {
                        &#34;is_auth&#34;: bottle_server.get(&#34;is_auth&#34;, is_auth),
                        &#34;is_admin&#34;: bottle_server.get(&#34;is_admin&#34;, is_admin),
                        &#34;is_package_authorized&#34;: bottle_server.get(&#34;is_package_authorized&#34;, is_package_authorized),
                        &#34;type&#34;: &#34;proxy&#34;,
                        &#34;name&#34;: bottle_server.get(&#34;name&#34;),
                        &#34;host&#34;: &#34;0.0.0.0&#34;,
                        &#34;port&#34;: 31000,
                        &#34;path_url&#34;: j.sals.fs.join_paths(self.package.base_url, path_url),
                        &#34;path_dest&#34;: f&#34;/{self.package.name}{bottle_server.get(&#39;path_dest&#39;)}&#34;,
                        &#34;websocket&#34;: bottle_server.get(&#34;websocket&#34;),
                        &#34;force_https&#34;: self.package.config.get(&#34;force_https&#34;, True),
                    }
                )

        if self.package.actors_dir:
            default_server[&#34;locations&#34;].append(
                {
                    &#34;is_auth&#34;: is_auth,
                    &#34;is_admin&#34;: is_admin,
                    &#34;is_package_authorized&#34;: is_package_authorized,
                    &#34;type&#34;: &#34;proxy&#34;,
                    &#34;name&#34;: &#34;actors&#34;,
                    &#34;host&#34;: GEDIS_HTTP_HOST,
                    &#34;port&#34;: GEDIS_HTTP_PORT,
                    &#34;path_url&#34;: j.sals.fs.join_paths(self.package.base_url, &#34;actors&#34;),
                    &#34;path_dest&#34;: self.package.base_url,
                    &#34;force_https&#34;: self.package.config.get(&#34;force_https&#34;, True),
                }
            )

        if self.package.chats_dir:
            default_server[&#34;locations&#34;].append(
                {
                    &#34;is_auth&#34;: is_auth,
                    &#34;is_admin&#34;: is_admin,
                    &#34;is_package_authorized&#34;: is_package_authorized,
                    &#34;type&#34;: &#34;proxy&#34;,
                    &#34;name&#34;: &#34;chats&#34;,
                    &#34;host&#34;: CHATFLOW_SERVER_HOST,
                    &#34;port&#34;: CHATFLOW_SERVER_PORT,
                    &#34;path_url&#34;: j.sals.fs.join_paths(self.package.base_url, &#34;chats&#34;),
                    &#34;path_dest&#34;: f&#34;/chatflows{self.package.base_url}/chats&#34;,  # TODO: temperoary fix for auth package
                    &#34;force_https&#34;: self.package.config.get(&#34;force_https&#34;, True),
                }
            )

        return [default_server]

    def apply(self, write_config=True):
        default_ports = [PORTS.HTTP, PORTS.HTTPS]
        servers = self.default_config + self.package.config.get(&#34;servers&#34;, [])
        for server in servers:
            ports = server.get(&#34;ports&#34;, default_ports) or default_ports
            for port in ports:
                server_name = server.get(&#34;name&#34;)
                if server_name != &#34;default&#34;:
                    server_name = f&#34;{self.package.name}_{server_name}&#34;

                website = self.nginx.get_website(server_name, port=port)
                website.ssl = server.get(&#34;ssl&#34;, port == PORTS.HTTPS)
                website.includes = server.get(&#34;includes&#34;, [])
                website.domain = server.get(&#34;domain&#34;, self.default_config[0].get(&#34;domain&#34;))
                website.letsencryptemail = server.get(
                    &#34;letsencryptemail&#34;, self.default_config[0].get(&#34;letsencryptemail&#34;)
                )
                website.acme_server_type = server.get(
                    &#34;acme_server_type&#34;, self.default_config[0].get(&#34;acme_server_type&#34;)
                )
                website.acme_server_url = server.get(&#34;acme_server_url&#34;, self.default_config[0].get(&#34;acme_server_url&#34;))
                if server.get(&#34;key_path&#34;):
                    website.key_path = server[&#34;key_path&#34;]
                if server.get(&#34;cert_path&#34;):
                    website.cert_path = server[&#34;cert_path&#34;]
                if server.get(&#34;fullchain_path&#34;):
                    website.fullchain_path = server[&#34;fullchain_path&#34;]

                for location in server.get(&#34;locations&#34;, []):
                    loc = None

                    location_name = location.get(&#34;name&#34;)
                    location_name = f&#34;{self.package.name}_{location_name}&#34;
                    location_type = location.get(&#34;type&#34;, &#34;static&#34;)

                    if location_type == &#34;static&#34;:
                        loc = website.get_static_location(location_name)
                        loc.spa = location.get(&#34;spa&#34;, False)
                        loc.index = location.get(&#34;index&#34;)
                        loc.path_location = location.get(&#34;path_location&#34;)

                    elif location_type == &#34;proxy&#34;:
                        loc = website.get_proxy_location(location_name)
                        loc.scheme = location.get(&#34;scheme&#34;, &#34;http&#34;)
                        loc.host = location.get(&#34;host&#34;)
                        loc.port = location.get(&#34;port&#34;, PORTS.HTTP)
                        loc.path_dest = location.get(&#34;path_dest&#34;, &#34;&#34;)
                        loc.websocket = location.get(&#34;websocket&#34;, False)
                        loc.proxy_buffering = location.get(&#34;proxy_buffering&#34;, &#34;&#34;)
                        loc.proxy_buffers = location.get(&#34;proxy_buffers&#34;)
                        loc.proxy_buffer_size = location.get(&#34;proxy_buffer_size&#34;)

                    elif location_type == &#34;custom&#34;:
                        loc = website.get_custom_location(location_name)
                        loc.custom_config = location.get(&#34;custom_config&#34;)

                    if loc:
                        loc.location_type = location_type
                        path_url = location.get(&#34;path_url&#34;, &#34;/&#34;)
                        if loc.location_type == LocationType.PROXY:
                            # proxy location needs / (as we append slash to the backend server too)
                            # and nginx always redirects to the same location with slash
                            # this way, requests will go to backend servers without double slashes...etc
                            if not path_url.endswith(&#34;/&#34;):
                                path_url += &#34;/&#34;
                        else:
                            # for other locations, slash is not required
                            if path_url != &#34;/&#34;:
                                path_url = path_url.rstrip(&#34;/&#34;)

                        loc.path_url = path_url
                        loc.force_https = location.get(&#34;force_https&#34;)
                        loc.is_auth = location.get(&#34;is_auth&#34;, False)
                        loc.is_admin = location.get(&#34;is_admin&#34;, False)
                        loc.is_package_authorized = location.get(&#34;is_package_authorized&#34;, False)
                        loc.package_name = self.package.name
                if write_config:
                    website.configure(generate_certificates=self.nginx.cert)


class Package:
    def __init__(
        self,
        path,
        default_domain,
        default_email,
        giturl=&#34;&#34;,
        kwargs=None,
        admins=None,
        default_acme_server_type=AcmeServer.LETSENCRYPT,
        default_acme_server_url=None,
    ):
        self.path = path
        self.giturl = giturl
        self._config = None
        self.name = j.sals.fs.basename(path.rstrip(&#34;/&#34;))
        self.nginx_config = NginxPackageConfig(self)
        self._module = None
        self.default_domain = default_domain
        self.default_email = default_email
        self.default_acme_server_type = default_acme_server_type
        self.default_acme_server_url = default_acme_server_url
        self.kwargs = kwargs or {}
        self.admins = admins or []

    def _load_files(self, dir_path):
        for file_path in j.sals.fs.walk_files(dir_path, recursive=False):
            file_name = j.sals.fs.basename(file_path)
            if file_name.endswith(&#34;.py&#34;):
                name = f&#34;{self.name}_{file_name[:-3]}&#34;
                yield dict(name=name, path=file_path)

    def load_config(self):
        return toml.load(self.package_config_path)

    @property
    def package_config_path(self):
        return j.sals.fs.join_paths(self.path, &#34;package.toml&#34;)

    @property
    def package_module_path(self):
        return j.sals.fs.join_paths(self.path, &#34;package.py&#34;)

    @property
    def module(self):
        if self._module is None:
            package_file_path = j.sals.fs.join_paths(self.path, &#34;package.py&#34;)
            if j.sals.fs.exists(package_file_path):
                module = imp.load_source(self.name, package_file_path)
                if not hasattr(module, self.name):
                    raise j.exceptions.Halt(f&#34;missing class ({self.name}) in the package file&#34;)

                self._module = getattr(module, self.name)()
        return self._module

    @property
    def base_url(self):
        return j.sals.fs.join_paths(&#34;/&#34;, self.name)

    @property
    def config(self):
        if not self._config:
            self._config = self.load_config()
        return self._config

    @property
    def ui_name(self):
        return self.config.get(&#34;ui_name&#34;, self.name)

    @property
    def actors_dir(self):
        actors_dir = j.sals.fs.join_paths(self.path, self.config.get(&#34;actors_dir&#34;, &#34;actors&#34;))
        if j.sals.fs.exists(actors_dir):
            return actors_dir

    @property
    def chats_dir(self):
        chats_dir = j.sals.fs.join_paths(self.path, self.config.get(&#34;chats_dir&#34;, &#34;chats&#34;))
        if j.sals.fs.exists(chats_dir):
            return chats_dir

    @property
    def services_dir(self):
        services_dir = j.sals.fs.join_paths(self.path, self.config.get(&#34;services_dir&#34;, &#34;services&#34;))
        if j.sals.fs.exists(services_dir):
            return services_dir

    @property
    def static_dirs(self):
        return self.config.get(&#34;static_dirs&#34;, [])

    @property
    def bottle_servers(self):
        return self.config.get(&#34;bottle_servers&#34;, [])

    @property
    def actors(self):
        return self._load_files(self.actors_dir)

    @property
    def services(self):
        return self._load_files(self.services_dir)

    def resolve_staticdir_location(self, static_dir):
        &#34;&#34;&#34;Resolves path for static location in case we need it
        absoulute or not

        static_dir.absolute_path true it will return the path directly
        if false will be relative to the path

        Args:
            static_dir (str): package.toml static dirs category

        Returns:
            str: package path
        &#34;&#34;&#34;
        path_location = static_dir.get(&#34;path_location&#34;)
        absolute_path = static_dir.get(&#34;absolute_path&#34;, False)
        if absolute_path:
            return j.sals.fs.expanduser(path_location)
        return j.sals.fs.expanduser(j.sals.fs.join_paths(self.path, path_location))

    def get_bottle_server(self, file_path, host, port):
        module = imp.load_source(file_path[:-3], file_path)
        return WSGIServer((host, port), StripPathMiddleware(module.app))

    def get_package_bottle_app(self, file_path):
        module = imp.load_source(file_path[:-3], file_path)
        return module.app

    def preinstall(self):
        if self.module and hasattr(self.module, &#34;preinstall&#34;):
            self.module.preinstall()

    def install(self, **kwargs):
        if self.module and hasattr(self.module, &#34;install&#34;):
            self.module.install(**kwargs)

    def uninstall(self):
        if self.module and hasattr(self.module, &#34;uninstall&#34;):
            self.module.uninstall()

    def start(self):
        if self.module and hasattr(self.module, &#34;start&#34;):
            self.module.start(**self.kwargs)

    def stop(self):
        if self.module and hasattr(self.module, &#34;stop&#34;):
            self.module.stop()

    def restart(self):
        if self.module:
            self.module.stop()
            self.module.start()

    def exists(self):
        return j.sals.fs.exists(self.package_config_path)

    def is_valid(self):
        # more constraints, but for now let&#39;s say it&#39;s not ok if the main files don&#39;t exist
        return self.exists() and not self.is_excluded()

    def is_excluded(self):
        return self.config.get(&#34;excluded&#34;, False) == True


class PackageManager(Base):
    packages = fields.Typed(dict, default=DEFAULT_PACKAGES.copy())

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self._threebot = None

    @property
    def threebot(self):
        if self._threebot is None:
            self._threebot = j.servers.threebot.get()
        return self._threebot

    def get(self, package_name):
        if package_name in self.packages:
            package_path = self.packages[package_name][&#34;path&#34;]
            package_giturl = self.packages[package_name][&#34;giturl&#34;]
            package_kwargs = self.packages[package_name].get(&#34;kwargs&#34;, {})
            package_admins = self.packages[package_name].get(&#34;admins&#34;, [])

            return Package(
                path=package_path,
                default_domain=self.threebot.domain,
                default_email=self.threebot.email,
                default_acme_server_type=self.threebot.acme_server_type,
                default_acme_server_url=self.threebot.acme_server_url,
                giturl=package_giturl,
                kwargs=package_kwargs,
                admins=package_admins,
            )

    def get_packages(self):
        all_packages = []

        # Add installed packages including outer packages
        for pkg in self.packages:
            package = self.get(pkg)

            if package and package.is_valid():
                if j.sals.fs.exists(package.path):
                    chatflows = True if package.chats_dir else False
                    all_packages.append(
                        {
                            &#34;name&#34;: pkg,
                            &#34;path&#34;: package.path,
                            &#34;giturl&#34;: package.giturl,
                            &#34;system_package&#34;: pkg in DEFAULT_PACKAGES.keys(),
                            &#34;installed&#34;: True,
                            &#34;frontend&#34;: package.config.get(&#34;frontend&#34;, False),
                            &#34;chatflows&#34;: chatflows,
                            &#34;ui_name&#34;: package.ui_name,
                        }
                    )
                else:
                    j.logger.error(f&#34;path {package.path} for {pkg} doesn&#39;t exist anymore&#34;)
            else:
                j.logger.error(&#34;pkg {pkg} is in self.packages but it&#39;s None&#34;)

        # Add uninstalled sdk packages under j.packages
        for path in set(pkgnamespace.__path__):
            for pkg in os.listdir(path):
                pkg_path = j.sals.fs.join_paths(path, pkg)
                pkgtoml_path = j.sals.fs.join_paths(pkg_path, &#34;package.toml&#34;)
                ui_name = pkg
                excluded = False
                with open(pkgtoml_path) as f:
                    conf = j.data.serializers.toml.loads(f.read())
                    ui_name = conf.get(&#34;ui_name&#34;, pkg)
                    excluded = conf.get(&#34;excluded&#34;, False)
                if pkg not in self.packages and j.sals.fs.exists(pkgtoml_path) and not excluded:
                    all_packages.append(
                        {
                            &#34;name&#34;: pkg,
                            &#34;path&#34;: j.sals.fs.dirname(getattr(j.packages, pkg).__file__),
                            &#34;giturl&#34;: &#34;&#34;,
                            &#34;system_package&#34;: pkg in DEFAULT_PACKAGES.keys(),
                            &#34;installed&#34;: False,
                            &#34;ui_name&#34;: ui_name,
                        }
                    )

        return all_packages

    def list_all(self):
        return list(self.packages.keys())

    def add(self, path: str = None, giturl: str = None, **kwargs):
        # first check if public repo
        # TODO: Check if package already exists
        if not any([path, giturl]) or all([path, giturl]):
            raise j.exceptions.Value(&#34;either path or giturl is required&#34;)
        pkg_name = &#34;&#34;
        if giturl:
            url = urlparse(giturl)
            url_parts = url.path.lstrip(&#34;/&#34;).split(&#34;/&#34;)
            if len(url_parts) == 2:
                pkg_name = url_parts[1].strip(&#34;/&#34;)
                j.logger.debug(
                    f&#34;user didn&#39;t pass a URL containing branch {giturl}, try to guess (master, main, development) in order&#34;
                )
                if j.tools.http.get(f&#34;{giturl}/tree/master&#34;).status_code == 200:
                    url_parts.extend([&#34;tree&#34;, &#34;master&#34;])
                elif j.tools.http.get(f&#34;{giturl}/tree/main&#34;).status_code == 200:
                    url_parts.extend([&#34;tree&#34;, &#34;main&#34;])
                elif j.tools.http.get(f&#34;{giturl}/tree/development&#34;).status_code == 200:
                    url_parts.extend([&#34;tree&#34;, &#34;development&#34;])
                else:
                    raise j.exceptions.Value(f&#34;couldn&#39;t guess the branch for {giturl}&#34;)
            else:
                pkg_name = url_parts[-1].strip(&#34;/&#34;)

            if len(url_parts) &lt; 4:
                raise j.exceptions.Value(f&#34;invalid git URL {giturl}&#34;)

            org, repo, _, branch = url_parts[:4]
            repo_dir = f&#34;{org}_{repo}_{pkg_name}_{branch}&#34;
            repo_path = j.sals.fs.join_paths(DOWNLOADED_PACKAGES_PATH, repo_dir)
            repo_url = f&#34;{url.scheme}://{url.hostname}/{org}/{repo}&#34;

            # delete repo dir if exists
            j.sals.fs.rmtree(repo_path)

            j.tools.git.clone_repo(url=repo_url, dest=repo_path, branch_or_tag=branch)
            toml_paths = list(
                j.sals.fs.walk(repo_path, &#34;*&#34;, filter_fun=lambda x: str(x).endswith(f&#34;{pkg_name}/package.toml&#34;))
            )
            if not toml_paths:
                raise j.exceptions.Value(f&#34;couldn&#39;t find {pkg_name}/package.toml in {repo_path}&#34;)
            path_for_package_toml = toml_paths[0]
            package_path = j.sals.fs.parent(path_for_package_toml)
            path = package_path

        admins = kwargs.pop(&#34;admins&#34;, [])

        package = Package(
            path=path,
            default_domain=self.threebot.domain,
            default_email=self.threebot.email,
            giturl=giturl,
            kwargs=kwargs,
            admins=admins,
        )

        # TODO: adding under the same name if same path and same giturl should be fine, no?
        # if package.name in self.packages:
        #     raise j.exceptions.Value(f&#34;Package with name {package.name} already exists&#34;)

        # execute package install method
        package.install(**kwargs)

        # install package if threebot is started
        if self.threebot.started:
            self.install(package)
            self.threebot.nginx.reload()
        self.packages[package.name] = {
            &#34;name&#34;: package.name,
            &#34;path&#34;: package.path,
            &#34;giturl&#34;: package.giturl,
            &#34;kwargs&#34;: package.kwargs,
            &#34;admins&#34;: package.admins,
            &#34;ui_name&#34;: package.ui_name,
        }

        self.save()

        # Return updated package info
        return {package.name: self.packages[package.name]}

    def delete(self, package_name):
        if package_name in DEFAULT_PACKAGES:
            raise j.exceptions.Value(&#34;cannot delete default packages&#34;)
        package = self.get(package_name)
        if not package:
            raise j.exceptions.NotFound(f&#34;{package_name} package not found&#34;)

        # remove bottle servers
        rack_servers = list(self.threebot.rack._servers)
        for bottle_server in rack_servers:
            if bottle_server.startswith(f&#34;{package_name}_&#34;):
                self.threebot.rack.remove(bottle_server)

        # stop background services
        if package.services_dir:
            for service in package.services:
                self.threebot.services.stop_service(service[&#34;name&#34;])

        if self.threebot.started:
            # unregister gedis actors
            gedis_actors = list(self.threebot.gedis._loaded_actors.keys())
            for actor in gedis_actors:
                if actor.startswith(f&#34;{package_name}_&#34;):
                    self.threebot.gedis._system_actor.unregister_actor(actor)

            # unload chats
            try:
                if package.chats_dir:
                    self.threebot.chatbot.unload(package.chats_dir)
            except Exception as e:
                j.logger.warning(f&#34;Couldn&#39;t unload the chats of package {package_name}, this is the exception {str(e)}&#34;)

            # reload nginx
            self.threebot.nginx.reload()

        # execute package uninstall method
        package.uninstall()

        self.packages.pop(package_name)
        self.save()

    def install(self, package):
        &#34;&#34;&#34;install and apply package configrations

        Args:
            package ([package object]): get package object using [self.get(package_name)]

        Returns:
            [dict]: [package info]
        &#34;&#34;&#34;
        sys.path.append(package.path + &#34;/../&#34;)  # TODO to be changed
        package.preinstall()
        for static_dir in package.static_dirs:
            path = package.resolve_staticdir_location(static_dir)
            if not j.sals.fs.exists(path):
                raise j.exceptions.NotFound(f&#34;Cannot find static dir {path}&#34;)

        # add bottle servers
        # we first merge all apps of a package into a single app
        # then mount this app on threebot main app
        # this will work with multiple non-standalone apps
        package_app = j.servers.appserver.make_main_app()
        for bottle_server in package.bottle_servers:
            path = j.sals.fs.join_paths(package.path, bottle_server[&#34;file_path&#34;])
            if not j.sals.fs.exists(path):
                raise j.exceptions.NotFound(f&#34;Cannot find bottle server path {path}&#34;)

            standalone = bottle_server.get(&#34;standalone&#34;, False)
            if standalone:
                bottle_wsgi_server = package.get_bottle_server(path, bottle_server[&#34;host&#34;], bottle_server[&#34;port&#34;])
                self.threebot.rack.add(f&#34;{package.name}_{bottle_server[&#39;name&#39;]}&#34;, bottle_wsgi_server)
            else:
                bottle_app = package.get_package_bottle_app(path)
                package_app.merge(bottle_app)

        if package_app.routes:
            j.logger.info(f&#34;registering {package.name} package app&#34;)
            self.threebot.mainapp.mount(f&#34;/{package.name}&#34;, package_app)

        # register gedis actors
        if package.actors_dir:
            for actor in package.actors:
                self.threebot.gedis._system_actor.register_actor(actor[&#34;name&#34;], actor[&#34;path&#34;], force_reload=True)

        # add chatflows actors
        if package.chats_dir:
            self.threebot.chatbot.load(package.chats_dir)

        # start background services
        if package.services_dir:
            for service in package.services:
                self.threebot.services.add_service(service[&#34;name&#34;], service[&#34;path&#34;])

        j.logger.info(f&#34;starting rack&#34;)
        # start servers
        self.threebot.rack.start()

        j.logger.info(f&#34;applying nginx config&#34;)
        # apply nginx configuration
        package.nginx_config.apply()

        j.logger.info(f&#34;starting package&#34;)
        # execute package start method
        package.start()

        j.logger.info(f&#34;reloading gedis&#34;)
        self.threebot.gedis_http.client.reload()
        j.logger.info(f&#34;reloading nginx&#34;)
        self.threebot.nginx.reload()

    def reload(self, package_name):
        if self.threebot.started:
            package = self.get(package_name)
            if not package:
                raise j.exceptions.NotFound(f&#34;{package_name} package not found&#34;)
            if package.services_dir:
                for service in package.services:
                    self.threebot.services.stop_service(service[&#34;name&#34;])
            self.install(package)
            self.threebot.nginx.reload()
            self.save()
        else:
            raise j.exceptions.Runtime(&#34;Can&#39;t reload package. Threebot server is not started&#34;)

        # Return updated package info
        return {package.name: self.packages[package.name]}

    def _install_all(self):
        &#34;&#34;&#34;Install and apply all the packages configurations
        This method shall not be called directly from the shell,
        it must be called only from the code on the running Gedis server
        &#34;&#34;&#34;
        all_packages = self.list_all()
        for package in all_packages:
            if package not in DEFAULT_PACKAGES:
                j.logger.info(f&#34;Configuring package {package}&#34;)
                pkg = self.get(package)
                if not pkg:
                    j.logger.error(f&#34;can&#39;t get package {package}&#34;)
                else:
                    if pkg.path and pkg.is_valid():
                        self.install(pkg)
                    else:
                        j.logger.error(f&#34;package {package} was installed before but {pkg.path} doesn&#39;t exist anymore.&#34;)

    def scan_packages_paths_in_dir(self, path):
        &#34;&#34;&#34;Scans all packages in a path in any level and returns list of package paths

        Args:
            path (str): root path that has packages on some levels

        Returns:
            List[str]: list of all packages available under the path
        &#34;&#34;&#34;
        filterfun = lambda x: str(x).endswith(&#34;package.toml&#34;)
        pkgtoml_paths = j.sals.fs.walk(path, filter_fun=filterfun)
        pkgs_paths = list(map(lambda x: x.replace(&#34;/package.toml&#34;, &#34;&#34;), pkgtoml_paths))
        return pkgs_paths

    def scan_packages_in_dir(self, path):
        &#34;&#34;&#34;Gets a dict from packages names to packages paths existing under a path that may have jumpscale packages at any level.

        Args:
            path (str): root path that has packages on some levels

        Returns:
            Dict[package_name, package_path]: dict of all packages available under the path
        &#34;&#34;&#34;
        pkgname_to_path = {}
        for p in self.scan_packages_paths_in_dir(path):
            basename = j.sals.fs.basename(p).strip()
            if basename:
                pkgname_to_path[basename] = p

        return pkgname_to_path


class ThreebotServer(Base):
    _package_manager = fields.Factory(PackageManager)
    domain = fields.String()
    email = fields.String()
    acme_server_type = fields.Enum(AcmeServer)
    acme_server_url = fields.URL()

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self._rack = None
        self._gedis = None
        self._db = None
        self._gedis_http = None
        self._services = None
        self._packages = None
        self._started = False
        self._nginx = None
        self._redis = None
        self.rack.add(GEDIS, self.gedis)
        self.rack.add(GEDIS_HTTP, self.gedis_http.gevent_server)
        self.rack.add(SERVICE_MANAGER, self.services)

    def is_running(self):
        nginx_running = self.nginx.is_running()
        redis_running = self.redis.cmd.is_running() or j.sals.nettools.wait_connection_test(
            &#34;127.0.0.1&#34;, 6379, timeout=1
        )
        gedis_running = j.sals.nettools.wait_connection_test(&#34;127.0.0.1&#34;, 16000, timeout=1)
        return nginx_running and redis_running and gedis_running

    @property
    def started(self):
        return self._started

    @property
    def nginx(self):
        if self._nginx is None:
            self._nginx = j.tools.nginx.get(&#34;default&#34;)
        return self._nginx

    @property
    def redis(self):
        if self._redis is None:
            self._redis = j.tools.redis.get(&#34;default&#34;)
        return self._redis

    @property
    def db(self):
        if self._db is None:
            self._db = j.core.db
        return self._db

    @property
    def rack(self):
        if self._rack is None:
            self._rack = j.servers.rack
        return self._rack

    @property
    def gedis(self):
        if self._gedis is None:
            self._gedis = j.servers.gedis.get(&#34;threebot&#34;)
        return self._gedis

    @property
    def gedis_http(self):
        if self._gedis_http is None:
            self._gedis_http = j.servers.gedis_http.get(&#34;threebot&#34;)
        return self._gedis_http

    @property
    def services(self):
        if self._services is None:
            self._services = j.tools.servicemanager.get(&#34;threebot&#34;)
        return self._services

    @property
    def chatbot(self):
        return self.gedis._loaded_actors.get(&#34;chatflows_chatbot&#34;)

    @property
    def packages(self):
        if self._packages is None:
            self._packages = self._package_manager.get(self.instance_name)
        return self._packages

    def check_dependencies(self):
        install_msg = &#34;Visit https://github.com/threefoldtech/js-sdk/blob/development/docs/wiki/quick_start.md for installation guide&#34;

        if not self.nginx.installed:
            raise j.exceptions.NotFound(f&#34;nginx is not installed.\n{install_msg}&#34;)

        ret = shutil.which(&#34;certbot&#34;)
        if not ret:
            raise j.exceptions.NotFound(f&#34;certbot is not installed.\n{install_msg}&#34;)

        rc, out, err = j.sals.process.execute(&#34;certbot plugins&#34;)
        if &#34;* nginx&#34; not in out:
            raise j.exceptions.NotFound(f&#34;python-certbot-nginx is not installed.\n{install_msg}&#34;)

        if not self.redis.installed:
            raise j.exceptions.NotFound(f&#34;redis is not installed.\n{install_msg}&#34;)

        ret = shutil.which(&#34;tmux&#34;)
        if not ret:
            raise j.exceptions.NotFound(f&#34;tmux is not installed.\n{install_msg}&#34;)

        ret = shutil.which(&#34;git&#34;)
        if not ret:
            raise j.exceptions.NotFound(f&#34;git is not installed.\n{install_msg}&#34;)

    def start(self, wait: bool = False, cert: bool = True):
        # start default servers in the rack
        # handle signals
        for signal_type in (signal.SIGTERM, signal.SIGINT, signal.SIGKILL):
            gevent.signal_handler(signal_type, self.stop)

        # mark app as started
        if self.is_running():
            return

        self.check_dependencies()

        self.redis.start()
        self.nginx.start()
        j.sals.nginx.get(self.nginx.server_name).cert = cert
        self.mainapp = j.servers.appserver.make_main_app()

        self.rack.start()
        j.logger.register(f&#34;threebot_{self.instance_name}&#34;)
        # add default packages
        for package_name in DEFAULT_PACKAGES:
            j.logger.info(f&#34;Configuring package {package_name}&#34;)
            try:
                package = self.packages.get(package_name)
                self.packages.install(package)
            except Exception as e:
                self.stop()
                raise j.core.exceptions.Runtime(
                    f&#34;Error happened during getting or installing {package_name} package, the detailed error is {str(e)}&#34;
                ) from e

        # install all package

        j.logger.info(&#34;Adding packages&#34;)
        self.packages._install_all()
        j.logger.info(&#34;jsappserver&#34;)
        self.jsappserver = WSGIServer((&#34;localhost&#34;, 31000), apply_main_middlewares(self.mainapp))
        j.logger.info(&#34;rack add&#34;)
        self.rack.add(f&#34;appserver&#34;, self.jsappserver)

        j.logger.info(&#34;Reloading nginx&#34;)
        self.nginx.reload()

        # mark server as started
        self._started = True
        j.logger.info(f&#34;routes: {self.mainapp.routes}&#34;)
        j.logger.info(f&#34;Threebot is running at http://localhost:{PORTS.HTTP} and https://localhost:{PORTS.HTTPS}&#34;)
        self.rack.start(wait=wait)  # to keep the server running

    def stop(self):
        server_packages = self.packages.list_all()
        for package_name in server_packages:
            package = self.packages.get(package_name)
            package.stop()
        self.nginx.stop()
        # mark app as stopped, do this before stopping redis
        j.logger.unregister()
        self.rack.stop()
        self.redis.stop()
        self._started = False</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="jumpscale.servers.threebot.threebot.NginxPackageConfig"><code class="flex name class">
<span>class <span class="ident">NginxPackageConfig</span></span>
<span>(</span><span>package)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class NginxPackageConfig:
    def __init__(self, package):
        self.package = package
        self.nginx = j.sals.nginx.get(&#34;main&#34;)

    @property
    def default_config(self):
        default_server = {
            &#34;name&#34;: &#34;default&#34;,
            &#34;ports&#34;: self.package.config.get(&#34;ports&#34;),
            &#34;locations&#34;: self.package.config.get(&#34;locations&#34;, []),
            &#34;domain&#34;: self.package.default_domain,
            &#34;letsencryptemail&#34;: self.package.default_email,
            &#34;acme_server_type&#34;: self.package.default_acme_server_type,
            &#34;acme_server_url&#34;: self.package.default_acme_server_url,
        }

        is_auth = self.package.config.get(&#34;is_auth&#34;, True)
        is_admin = self.package.config.get(&#34;is_admin&#34;, True)
        is_package_authorized = self.package.config.get(&#34;is_package_authorized&#34;, False)

        for static_dir in self.package.static_dirs:
            path_url = j.data.text.removeprefix(static_dir.get(&#34;path_url&#34;), &#34;/&#34;)
            default_server[&#34;locations&#34;].append(
                {
                    &#34;is_auth&#34;: static_dir.get(&#34;is_auth&#34;, is_auth),
                    &#34;is_admin&#34;: static_dir.get(&#34;is_admin&#34;, is_admin),
                    &#34;is_package_authorized&#34;: static_dir.get(&#34;is_package_authorized&#34;, is_package_authorized),
                    &#34;type&#34;: &#34;static&#34;,
                    &#34;name&#34;: static_dir.get(&#34;name&#34;),
                    &#34;spa&#34;: static_dir.get(&#34;spa&#34;),
                    &#34;index&#34;: static_dir.get(&#34;index&#34;),
                    &#34;path_url&#34;: j.sals.fs.join_paths(self.package.base_url, path_url),
                    &#34;path_location&#34;: self.package.resolve_staticdir_location(static_dir),
                    &#34;force_https&#34;: self.package.config.get(&#34;force_https&#34;, True),
                }
            )

        for bottle_server in self.package.bottle_servers:
            path_url = j.data.text.removeprefix(bottle_server.get(&#34;path_url&#34;), &#34;/&#34;)
            if hasattr(bottle_server, &#34;standalone&#34;) and bottle_server.standalone:
                default_server[&#34;locations&#34;].append(
                    {
                        &#34;is_auth&#34;: bottle_server.get(&#34;is_auth&#34;, is_auth),
                        &#34;is_admin&#34;: bottle_server.get(&#34;is_admin&#34;, is_admin),
                        &#34;is_package_authorized&#34;: bottle_server.get(&#34;is_package_authorized&#34;, is_package_authorized),
                        &#34;type&#34;: &#34;proxy&#34;,
                        &#34;name&#34;: bottle_server.get(&#34;name&#34;),
                        &#34;host&#34;: bottle_server.get(&#34;host&#34;),
                        &#34;port&#34;: bottle_server.get(&#34;port&#34;),
                        &#34;path_url&#34;: j.sals.fs.join_paths(self.package.base_url,),
                        &#34;path_dest&#34;: bottle_server.get(&#34;path_dest&#34;),
                        &#34;websocket&#34;: bottle_server.get(&#34;websocket&#34;),
                        &#34;force_https&#34;: self.package.config.get(&#34;force_https&#34;, True),
                    }
                )
            else:
                path_url = j.data.text.removeprefix(bottle_server.get(&#34;path_url&#34;), &#34;/&#34;)
                default_server[&#34;locations&#34;].append(
                    {
                        &#34;is_auth&#34;: bottle_server.get(&#34;is_auth&#34;, is_auth),
                        &#34;is_admin&#34;: bottle_server.get(&#34;is_admin&#34;, is_admin),
                        &#34;is_package_authorized&#34;: bottle_server.get(&#34;is_package_authorized&#34;, is_package_authorized),
                        &#34;type&#34;: &#34;proxy&#34;,
                        &#34;name&#34;: bottle_server.get(&#34;name&#34;),
                        &#34;host&#34;: &#34;0.0.0.0&#34;,
                        &#34;port&#34;: 31000,
                        &#34;path_url&#34;: j.sals.fs.join_paths(self.package.base_url, path_url),
                        &#34;path_dest&#34;: f&#34;/{self.package.name}{bottle_server.get(&#39;path_dest&#39;)}&#34;,
                        &#34;websocket&#34;: bottle_server.get(&#34;websocket&#34;),
                        &#34;force_https&#34;: self.package.config.get(&#34;force_https&#34;, True),
                    }
                )

        if self.package.actors_dir:
            default_server[&#34;locations&#34;].append(
                {
                    &#34;is_auth&#34;: is_auth,
                    &#34;is_admin&#34;: is_admin,
                    &#34;is_package_authorized&#34;: is_package_authorized,
                    &#34;type&#34;: &#34;proxy&#34;,
                    &#34;name&#34;: &#34;actors&#34;,
                    &#34;host&#34;: GEDIS_HTTP_HOST,
                    &#34;port&#34;: GEDIS_HTTP_PORT,
                    &#34;path_url&#34;: j.sals.fs.join_paths(self.package.base_url, &#34;actors&#34;),
                    &#34;path_dest&#34;: self.package.base_url,
                    &#34;force_https&#34;: self.package.config.get(&#34;force_https&#34;, True),
                }
            )

        if self.package.chats_dir:
            default_server[&#34;locations&#34;].append(
                {
                    &#34;is_auth&#34;: is_auth,
                    &#34;is_admin&#34;: is_admin,
                    &#34;is_package_authorized&#34;: is_package_authorized,
                    &#34;type&#34;: &#34;proxy&#34;,
                    &#34;name&#34;: &#34;chats&#34;,
                    &#34;host&#34;: CHATFLOW_SERVER_HOST,
                    &#34;port&#34;: CHATFLOW_SERVER_PORT,
                    &#34;path_url&#34;: j.sals.fs.join_paths(self.package.base_url, &#34;chats&#34;),
                    &#34;path_dest&#34;: f&#34;/chatflows{self.package.base_url}/chats&#34;,  # TODO: temperoary fix for auth package
                    &#34;force_https&#34;: self.package.config.get(&#34;force_https&#34;, True),
                }
            )

        return [default_server]

    def apply(self, write_config=True):
        default_ports = [PORTS.HTTP, PORTS.HTTPS]
        servers = self.default_config + self.package.config.get(&#34;servers&#34;, [])
        for server in servers:
            ports = server.get(&#34;ports&#34;, default_ports) or default_ports
            for port in ports:
                server_name = server.get(&#34;name&#34;)
                if server_name != &#34;default&#34;:
                    server_name = f&#34;{self.package.name}_{server_name}&#34;

                website = self.nginx.get_website(server_name, port=port)
                website.ssl = server.get(&#34;ssl&#34;, port == PORTS.HTTPS)
                website.includes = server.get(&#34;includes&#34;, [])
                website.domain = server.get(&#34;domain&#34;, self.default_config[0].get(&#34;domain&#34;))
                website.letsencryptemail = server.get(
                    &#34;letsencryptemail&#34;, self.default_config[0].get(&#34;letsencryptemail&#34;)
                )
                website.acme_server_type = server.get(
                    &#34;acme_server_type&#34;, self.default_config[0].get(&#34;acme_server_type&#34;)
                )
                website.acme_server_url = server.get(&#34;acme_server_url&#34;, self.default_config[0].get(&#34;acme_server_url&#34;))
                if server.get(&#34;key_path&#34;):
                    website.key_path = server[&#34;key_path&#34;]
                if server.get(&#34;cert_path&#34;):
                    website.cert_path = server[&#34;cert_path&#34;]
                if server.get(&#34;fullchain_path&#34;):
                    website.fullchain_path = server[&#34;fullchain_path&#34;]

                for location in server.get(&#34;locations&#34;, []):
                    loc = None

                    location_name = location.get(&#34;name&#34;)
                    location_name = f&#34;{self.package.name}_{location_name}&#34;
                    location_type = location.get(&#34;type&#34;, &#34;static&#34;)

                    if location_type == &#34;static&#34;:
                        loc = website.get_static_location(location_name)
                        loc.spa = location.get(&#34;spa&#34;, False)
                        loc.index = location.get(&#34;index&#34;)
                        loc.path_location = location.get(&#34;path_location&#34;)

                    elif location_type == &#34;proxy&#34;:
                        loc = website.get_proxy_location(location_name)
                        loc.scheme = location.get(&#34;scheme&#34;, &#34;http&#34;)
                        loc.host = location.get(&#34;host&#34;)
                        loc.port = location.get(&#34;port&#34;, PORTS.HTTP)
                        loc.path_dest = location.get(&#34;path_dest&#34;, &#34;&#34;)
                        loc.websocket = location.get(&#34;websocket&#34;, False)
                        loc.proxy_buffering = location.get(&#34;proxy_buffering&#34;, &#34;&#34;)
                        loc.proxy_buffers = location.get(&#34;proxy_buffers&#34;)
                        loc.proxy_buffer_size = location.get(&#34;proxy_buffer_size&#34;)

                    elif location_type == &#34;custom&#34;:
                        loc = website.get_custom_location(location_name)
                        loc.custom_config = location.get(&#34;custom_config&#34;)

                    if loc:
                        loc.location_type = location_type
                        path_url = location.get(&#34;path_url&#34;, &#34;/&#34;)
                        if loc.location_type == LocationType.PROXY:
                            # proxy location needs / (as we append slash to the backend server too)
                            # and nginx always redirects to the same location with slash
                            # this way, requests will go to backend servers without double slashes...etc
                            if not path_url.endswith(&#34;/&#34;):
                                path_url += &#34;/&#34;
                        else:
                            # for other locations, slash is not required
                            if path_url != &#34;/&#34;:
                                path_url = path_url.rstrip(&#34;/&#34;)

                        loc.path_url = path_url
                        loc.force_https = location.get(&#34;force_https&#34;)
                        loc.is_auth = location.get(&#34;is_auth&#34;, False)
                        loc.is_admin = location.get(&#34;is_admin&#34;, False)
                        loc.is_package_authorized = location.get(&#34;is_package_authorized&#34;, False)
                        loc.package_name = self.package.name
                if write_config:
                    website.configure(generate_certificates=self.nginx.cert)</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="jumpscale.servers.threebot.threebot.NginxPackageConfig.default_config"><code class="name">var <span class="ident">default_config</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def default_config(self):
    default_server = {
        &#34;name&#34;: &#34;default&#34;,
        &#34;ports&#34;: self.package.config.get(&#34;ports&#34;),
        &#34;locations&#34;: self.package.config.get(&#34;locations&#34;, []),
        &#34;domain&#34;: self.package.default_domain,
        &#34;letsencryptemail&#34;: self.package.default_email,
        &#34;acme_server_type&#34;: self.package.default_acme_server_type,
        &#34;acme_server_url&#34;: self.package.default_acme_server_url,
    }

    is_auth = self.package.config.get(&#34;is_auth&#34;, True)
    is_admin = self.package.config.get(&#34;is_admin&#34;, True)
    is_package_authorized = self.package.config.get(&#34;is_package_authorized&#34;, False)

    for static_dir in self.package.static_dirs:
        path_url = j.data.text.removeprefix(static_dir.get(&#34;path_url&#34;), &#34;/&#34;)
        default_server[&#34;locations&#34;].append(
            {
                &#34;is_auth&#34;: static_dir.get(&#34;is_auth&#34;, is_auth),
                &#34;is_admin&#34;: static_dir.get(&#34;is_admin&#34;, is_admin),
                &#34;is_package_authorized&#34;: static_dir.get(&#34;is_package_authorized&#34;, is_package_authorized),
                &#34;type&#34;: &#34;static&#34;,
                &#34;name&#34;: static_dir.get(&#34;name&#34;),
                &#34;spa&#34;: static_dir.get(&#34;spa&#34;),
                &#34;index&#34;: static_dir.get(&#34;index&#34;),
                &#34;path_url&#34;: j.sals.fs.join_paths(self.package.base_url, path_url),
                &#34;path_location&#34;: self.package.resolve_staticdir_location(static_dir),
                &#34;force_https&#34;: self.package.config.get(&#34;force_https&#34;, True),
            }
        )

    for bottle_server in self.package.bottle_servers:
        path_url = j.data.text.removeprefix(bottle_server.get(&#34;path_url&#34;), &#34;/&#34;)
        if hasattr(bottle_server, &#34;standalone&#34;) and bottle_server.standalone:
            default_server[&#34;locations&#34;].append(
                {
                    &#34;is_auth&#34;: bottle_server.get(&#34;is_auth&#34;, is_auth),
                    &#34;is_admin&#34;: bottle_server.get(&#34;is_admin&#34;, is_admin),
                    &#34;is_package_authorized&#34;: bottle_server.get(&#34;is_package_authorized&#34;, is_package_authorized),
                    &#34;type&#34;: &#34;proxy&#34;,
                    &#34;name&#34;: bottle_server.get(&#34;name&#34;),
                    &#34;host&#34;: bottle_server.get(&#34;host&#34;),
                    &#34;port&#34;: bottle_server.get(&#34;port&#34;),
                    &#34;path_url&#34;: j.sals.fs.join_paths(self.package.base_url,),
                    &#34;path_dest&#34;: bottle_server.get(&#34;path_dest&#34;),
                    &#34;websocket&#34;: bottle_server.get(&#34;websocket&#34;),
                    &#34;force_https&#34;: self.package.config.get(&#34;force_https&#34;, True),
                }
            )
        else:
            path_url = j.data.text.removeprefix(bottle_server.get(&#34;path_url&#34;), &#34;/&#34;)
            default_server[&#34;locations&#34;].append(
                {
                    &#34;is_auth&#34;: bottle_server.get(&#34;is_auth&#34;, is_auth),
                    &#34;is_admin&#34;: bottle_server.get(&#34;is_admin&#34;, is_admin),
                    &#34;is_package_authorized&#34;: bottle_server.get(&#34;is_package_authorized&#34;, is_package_authorized),
                    &#34;type&#34;: &#34;proxy&#34;,
                    &#34;name&#34;: bottle_server.get(&#34;name&#34;),
                    &#34;host&#34;: &#34;0.0.0.0&#34;,
                    &#34;port&#34;: 31000,
                    &#34;path_url&#34;: j.sals.fs.join_paths(self.package.base_url, path_url),
                    &#34;path_dest&#34;: f&#34;/{self.package.name}{bottle_server.get(&#39;path_dest&#39;)}&#34;,
                    &#34;websocket&#34;: bottle_server.get(&#34;websocket&#34;),
                    &#34;force_https&#34;: self.package.config.get(&#34;force_https&#34;, True),
                }
            )

    if self.package.actors_dir:
        default_server[&#34;locations&#34;].append(
            {
                &#34;is_auth&#34;: is_auth,
                &#34;is_admin&#34;: is_admin,
                &#34;is_package_authorized&#34;: is_package_authorized,
                &#34;type&#34;: &#34;proxy&#34;,
                &#34;name&#34;: &#34;actors&#34;,
                &#34;host&#34;: GEDIS_HTTP_HOST,
                &#34;port&#34;: GEDIS_HTTP_PORT,
                &#34;path_url&#34;: j.sals.fs.join_paths(self.package.base_url, &#34;actors&#34;),
                &#34;path_dest&#34;: self.package.base_url,
                &#34;force_https&#34;: self.package.config.get(&#34;force_https&#34;, True),
            }
        )

    if self.package.chats_dir:
        default_server[&#34;locations&#34;].append(
            {
                &#34;is_auth&#34;: is_auth,
                &#34;is_admin&#34;: is_admin,
                &#34;is_package_authorized&#34;: is_package_authorized,
                &#34;type&#34;: &#34;proxy&#34;,
                &#34;name&#34;: &#34;chats&#34;,
                &#34;host&#34;: CHATFLOW_SERVER_HOST,
                &#34;port&#34;: CHATFLOW_SERVER_PORT,
                &#34;path_url&#34;: j.sals.fs.join_paths(self.package.base_url, &#34;chats&#34;),
                &#34;path_dest&#34;: f&#34;/chatflows{self.package.base_url}/chats&#34;,  # TODO: temperoary fix for auth package
                &#34;force_https&#34;: self.package.config.get(&#34;force_https&#34;, True),
            }
        )

    return [default_server]</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="jumpscale.servers.threebot.threebot.NginxPackageConfig.apply"><code class="name flex">
<span>def <span class="ident">apply</span></span>(<span>self, write_config=True)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def apply(self, write_config=True):
    default_ports = [PORTS.HTTP, PORTS.HTTPS]
    servers = self.default_config + self.package.config.get(&#34;servers&#34;, [])
    for server in servers:
        ports = server.get(&#34;ports&#34;, default_ports) or default_ports
        for port in ports:
            server_name = server.get(&#34;name&#34;)
            if server_name != &#34;default&#34;:
                server_name = f&#34;{self.package.name}_{server_name}&#34;

            website = self.nginx.get_website(server_name, port=port)
            website.ssl = server.get(&#34;ssl&#34;, port == PORTS.HTTPS)
            website.includes = server.get(&#34;includes&#34;, [])
            website.domain = server.get(&#34;domain&#34;, self.default_config[0].get(&#34;domain&#34;))
            website.letsencryptemail = server.get(
                &#34;letsencryptemail&#34;, self.default_config[0].get(&#34;letsencryptemail&#34;)
            )
            website.acme_server_type = server.get(
                &#34;acme_server_type&#34;, self.default_config[0].get(&#34;acme_server_type&#34;)
            )
            website.acme_server_url = server.get(&#34;acme_server_url&#34;, self.default_config[0].get(&#34;acme_server_url&#34;))
            if server.get(&#34;key_path&#34;):
                website.key_path = server[&#34;key_path&#34;]
            if server.get(&#34;cert_path&#34;):
                website.cert_path = server[&#34;cert_path&#34;]
            if server.get(&#34;fullchain_path&#34;):
                website.fullchain_path = server[&#34;fullchain_path&#34;]

            for location in server.get(&#34;locations&#34;, []):
                loc = None

                location_name = location.get(&#34;name&#34;)
                location_name = f&#34;{self.package.name}_{location_name}&#34;
                location_type = location.get(&#34;type&#34;, &#34;static&#34;)

                if location_type == &#34;static&#34;:
                    loc = website.get_static_location(location_name)
                    loc.spa = location.get(&#34;spa&#34;, False)
                    loc.index = location.get(&#34;index&#34;)
                    loc.path_location = location.get(&#34;path_location&#34;)

                elif location_type == &#34;proxy&#34;:
                    loc = website.get_proxy_location(location_name)
                    loc.scheme = location.get(&#34;scheme&#34;, &#34;http&#34;)
                    loc.host = location.get(&#34;host&#34;)
                    loc.port = location.get(&#34;port&#34;, PORTS.HTTP)
                    loc.path_dest = location.get(&#34;path_dest&#34;, &#34;&#34;)
                    loc.websocket = location.get(&#34;websocket&#34;, False)
                    loc.proxy_buffering = location.get(&#34;proxy_buffering&#34;, &#34;&#34;)
                    loc.proxy_buffers = location.get(&#34;proxy_buffers&#34;)
                    loc.proxy_buffer_size = location.get(&#34;proxy_buffer_size&#34;)

                elif location_type == &#34;custom&#34;:
                    loc = website.get_custom_location(location_name)
                    loc.custom_config = location.get(&#34;custom_config&#34;)

                if loc:
                    loc.location_type = location_type
                    path_url = location.get(&#34;path_url&#34;, &#34;/&#34;)
                    if loc.location_type == LocationType.PROXY:
                        # proxy location needs / (as we append slash to the backend server too)
                        # and nginx always redirects to the same location with slash
                        # this way, requests will go to backend servers without double slashes...etc
                        if not path_url.endswith(&#34;/&#34;):
                            path_url += &#34;/&#34;
                    else:
                        # for other locations, slash is not required
                        if path_url != &#34;/&#34;:
                            path_url = path_url.rstrip(&#34;/&#34;)

                    loc.path_url = path_url
                    loc.force_https = location.get(&#34;force_https&#34;)
                    loc.is_auth = location.get(&#34;is_auth&#34;, False)
                    loc.is_admin = location.get(&#34;is_admin&#34;, False)
                    loc.is_package_authorized = location.get(&#34;is_package_authorized&#34;, False)
                    loc.package_name = self.package.name
            if write_config:
                website.configure(generate_certificates=self.nginx.cert)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="jumpscale.servers.threebot.threebot.Package"><code class="flex name class">
<span>class <span class="ident">Package</span></span>
<span>(</span><span>path, default_domain, default_email, giturl='', kwargs=None, admins=None, default_acme_server_type=AcmeServer.LETSENCRYPT, default_acme_server_url=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Package:
    def __init__(
        self,
        path,
        default_domain,
        default_email,
        giturl=&#34;&#34;,
        kwargs=None,
        admins=None,
        default_acme_server_type=AcmeServer.LETSENCRYPT,
        default_acme_server_url=None,
    ):
        self.path = path
        self.giturl = giturl
        self._config = None
        self.name = j.sals.fs.basename(path.rstrip(&#34;/&#34;))
        self.nginx_config = NginxPackageConfig(self)
        self._module = None
        self.default_domain = default_domain
        self.default_email = default_email
        self.default_acme_server_type = default_acme_server_type
        self.default_acme_server_url = default_acme_server_url
        self.kwargs = kwargs or {}
        self.admins = admins or []

    def _load_files(self, dir_path):
        for file_path in j.sals.fs.walk_files(dir_path, recursive=False):
            file_name = j.sals.fs.basename(file_path)
            if file_name.endswith(&#34;.py&#34;):
                name = f&#34;{self.name}_{file_name[:-3]}&#34;
                yield dict(name=name, path=file_path)

    def load_config(self):
        return toml.load(self.package_config_path)

    @property
    def package_config_path(self):
        return j.sals.fs.join_paths(self.path, &#34;package.toml&#34;)

    @property
    def package_module_path(self):
        return j.sals.fs.join_paths(self.path, &#34;package.py&#34;)

    @property
    def module(self):
        if self._module is None:
            package_file_path = j.sals.fs.join_paths(self.path, &#34;package.py&#34;)
            if j.sals.fs.exists(package_file_path):
                module = imp.load_source(self.name, package_file_path)
                if not hasattr(module, self.name):
                    raise j.exceptions.Halt(f&#34;missing class ({self.name}) in the package file&#34;)

                self._module = getattr(module, self.name)()
        return self._module

    @property
    def base_url(self):
        return j.sals.fs.join_paths(&#34;/&#34;, self.name)

    @property
    def config(self):
        if not self._config:
            self._config = self.load_config()
        return self._config

    @property
    def ui_name(self):
        return self.config.get(&#34;ui_name&#34;, self.name)

    @property
    def actors_dir(self):
        actors_dir = j.sals.fs.join_paths(self.path, self.config.get(&#34;actors_dir&#34;, &#34;actors&#34;))
        if j.sals.fs.exists(actors_dir):
            return actors_dir

    @property
    def chats_dir(self):
        chats_dir = j.sals.fs.join_paths(self.path, self.config.get(&#34;chats_dir&#34;, &#34;chats&#34;))
        if j.sals.fs.exists(chats_dir):
            return chats_dir

    @property
    def services_dir(self):
        services_dir = j.sals.fs.join_paths(self.path, self.config.get(&#34;services_dir&#34;, &#34;services&#34;))
        if j.sals.fs.exists(services_dir):
            return services_dir

    @property
    def static_dirs(self):
        return self.config.get(&#34;static_dirs&#34;, [])

    @property
    def bottle_servers(self):
        return self.config.get(&#34;bottle_servers&#34;, [])

    @property
    def actors(self):
        return self._load_files(self.actors_dir)

    @property
    def services(self):
        return self._load_files(self.services_dir)

    def resolve_staticdir_location(self, static_dir):
        &#34;&#34;&#34;Resolves path for static location in case we need it
        absoulute or not

        static_dir.absolute_path true it will return the path directly
        if false will be relative to the path

        Args:
            static_dir (str): package.toml static dirs category

        Returns:
            str: package path
        &#34;&#34;&#34;
        path_location = static_dir.get(&#34;path_location&#34;)
        absolute_path = static_dir.get(&#34;absolute_path&#34;, False)
        if absolute_path:
            return j.sals.fs.expanduser(path_location)
        return j.sals.fs.expanduser(j.sals.fs.join_paths(self.path, path_location))

    def get_bottle_server(self, file_path, host, port):
        module = imp.load_source(file_path[:-3], file_path)
        return WSGIServer((host, port), StripPathMiddleware(module.app))

    def get_package_bottle_app(self, file_path):
        module = imp.load_source(file_path[:-3], file_path)
        return module.app

    def preinstall(self):
        if self.module and hasattr(self.module, &#34;preinstall&#34;):
            self.module.preinstall()

    def install(self, **kwargs):
        if self.module and hasattr(self.module, &#34;install&#34;):
            self.module.install(**kwargs)

    def uninstall(self):
        if self.module and hasattr(self.module, &#34;uninstall&#34;):
            self.module.uninstall()

    def start(self):
        if self.module and hasattr(self.module, &#34;start&#34;):
            self.module.start(**self.kwargs)

    def stop(self):
        if self.module and hasattr(self.module, &#34;stop&#34;):
            self.module.stop()

    def restart(self):
        if self.module:
            self.module.stop()
            self.module.start()

    def exists(self):
        return j.sals.fs.exists(self.package_config_path)

    def is_valid(self):
        # more constraints, but for now let&#39;s say it&#39;s not ok if the main files don&#39;t exist
        return self.exists() and not self.is_excluded()

    def is_excluded(self):
        return self.config.get(&#34;excluded&#34;, False) == True</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="jumpscale.servers.threebot.threebot.Package.actors"><code class="name">var <span class="ident">actors</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def actors(self):
    return self._load_files(self.actors_dir)</code></pre>
</details>
</dd>
<dt id="jumpscale.servers.threebot.threebot.Package.actors_dir"><code class="name">var <span class="ident">actors_dir</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def actors_dir(self):
    actors_dir = j.sals.fs.join_paths(self.path, self.config.get(&#34;actors_dir&#34;, &#34;actors&#34;))
    if j.sals.fs.exists(actors_dir):
        return actors_dir</code></pre>
</details>
</dd>
<dt id="jumpscale.servers.threebot.threebot.Package.base_url"><code class="name">var <span class="ident">base_url</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def base_url(self):
    return j.sals.fs.join_paths(&#34;/&#34;, self.name)</code></pre>
</details>
</dd>
<dt id="jumpscale.servers.threebot.threebot.Package.bottle_servers"><code class="name">var <span class="ident">bottle_servers</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def bottle_servers(self):
    return self.config.get(&#34;bottle_servers&#34;, [])</code></pre>
</details>
</dd>
<dt id="jumpscale.servers.threebot.threebot.Package.chats_dir"><code class="name">var <span class="ident">chats_dir</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def chats_dir(self):
    chats_dir = j.sals.fs.join_paths(self.path, self.config.get(&#34;chats_dir&#34;, &#34;chats&#34;))
    if j.sals.fs.exists(chats_dir):
        return chats_dir</code></pre>
</details>
</dd>
<dt id="jumpscale.servers.threebot.threebot.Package.config"><code class="name">var <span class="ident">config</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def config(self):
    if not self._config:
        self._config = self.load_config()
    return self._config</code></pre>
</details>
</dd>
<dt id="jumpscale.servers.threebot.threebot.Package.module"><code class="name">var <span class="ident">module</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def module(self):
    if self._module is None:
        package_file_path = j.sals.fs.join_paths(self.path, &#34;package.py&#34;)
        if j.sals.fs.exists(package_file_path):
            module = imp.load_source(self.name, package_file_path)
            if not hasattr(module, self.name):
                raise j.exceptions.Halt(f&#34;missing class ({self.name}) in the package file&#34;)

            self._module = getattr(module, self.name)()
    return self._module</code></pre>
</details>
</dd>
<dt id="jumpscale.servers.threebot.threebot.Package.package_config_path"><code class="name">var <span class="ident">package_config_path</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def package_config_path(self):
    return j.sals.fs.join_paths(self.path, &#34;package.toml&#34;)</code></pre>
</details>
</dd>
<dt id="jumpscale.servers.threebot.threebot.Package.package_module_path"><code class="name">var <span class="ident">package_module_path</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def package_module_path(self):
    return j.sals.fs.join_paths(self.path, &#34;package.py&#34;)</code></pre>
</details>
</dd>
<dt id="jumpscale.servers.threebot.threebot.Package.services"><code class="name">var <span class="ident">services</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def services(self):
    return self._load_files(self.services_dir)</code></pre>
</details>
</dd>
<dt id="jumpscale.servers.threebot.threebot.Package.services_dir"><code class="name">var <span class="ident">services_dir</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def services_dir(self):
    services_dir = j.sals.fs.join_paths(self.path, self.config.get(&#34;services_dir&#34;, &#34;services&#34;))
    if j.sals.fs.exists(services_dir):
        return services_dir</code></pre>
</details>
</dd>
<dt id="jumpscale.servers.threebot.threebot.Package.static_dirs"><code class="name">var <span class="ident">static_dirs</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def static_dirs(self):
    return self.config.get(&#34;static_dirs&#34;, [])</code></pre>
</details>
</dd>
<dt id="jumpscale.servers.threebot.threebot.Package.ui_name"><code class="name">var <span class="ident">ui_name</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def ui_name(self):
    return self.config.get(&#34;ui_name&#34;, self.name)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="jumpscale.servers.threebot.threebot.Package.exists"><code class="name flex">
<span>def <span class="ident">exists</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def exists(self):
    return j.sals.fs.exists(self.package_config_path)</code></pre>
</details>
</dd>
<dt id="jumpscale.servers.threebot.threebot.Package.get_bottle_server"><code class="name flex">
<span>def <span class="ident">get_bottle_server</span></span>(<span>self, file_path, host, port)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_bottle_server(self, file_path, host, port):
    module = imp.load_source(file_path[:-3], file_path)
    return WSGIServer((host, port), StripPathMiddleware(module.app))</code></pre>
</details>
</dd>
<dt id="jumpscale.servers.threebot.threebot.Package.get_package_bottle_app"><code class="name flex">
<span>def <span class="ident">get_package_bottle_app</span></span>(<span>self, file_path)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_package_bottle_app(self, file_path):
    module = imp.load_source(file_path[:-3], file_path)
    return module.app</code></pre>
</details>
</dd>
<dt id="jumpscale.servers.threebot.threebot.Package.install"><code class="name flex">
<span>def <span class="ident">install</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def install(self, **kwargs):
    if self.module and hasattr(self.module, &#34;install&#34;):
        self.module.install(**kwargs)</code></pre>
</details>
</dd>
<dt id="jumpscale.servers.threebot.threebot.Package.is_excluded"><code class="name flex">
<span>def <span class="ident">is_excluded</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_excluded(self):
    return self.config.get(&#34;excluded&#34;, False) == True</code></pre>
</details>
</dd>
<dt id="jumpscale.servers.threebot.threebot.Package.is_valid"><code class="name flex">
<span>def <span class="ident">is_valid</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_valid(self):
    # more constraints, but for now let&#39;s say it&#39;s not ok if the main files don&#39;t exist
    return self.exists() and not self.is_excluded()</code></pre>
</details>
</dd>
<dt id="jumpscale.servers.threebot.threebot.Package.load_config"><code class="name flex">
<span>def <span class="ident">load_config</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_config(self):
    return toml.load(self.package_config_path)</code></pre>
</details>
</dd>
<dt id="jumpscale.servers.threebot.threebot.Package.preinstall"><code class="name flex">
<span>def <span class="ident">preinstall</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def preinstall(self):
    if self.module and hasattr(self.module, &#34;preinstall&#34;):
        self.module.preinstall()</code></pre>
</details>
</dd>
<dt id="jumpscale.servers.threebot.threebot.Package.resolve_staticdir_location"><code class="name flex">
<span>def <span class="ident">resolve_staticdir_location</span></span>(<span>self, static_dir)</span>
</code></dt>
<dd>
<div class="desc"><p>Resolves path for static location in case we need it
absoulute or not</p>
<p>static_dir.absolute_path true it will return the path directly
if false will be relative to the path</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>static_dir</code></strong> :&ensp;<code>str</code></dt>
<dd>package.toml static dirs category</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>package path</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def resolve_staticdir_location(self, static_dir):
    &#34;&#34;&#34;Resolves path for static location in case we need it
    absoulute or not

    static_dir.absolute_path true it will return the path directly
    if false will be relative to the path

    Args:
        static_dir (str): package.toml static dirs category

    Returns:
        str: package path
    &#34;&#34;&#34;
    path_location = static_dir.get(&#34;path_location&#34;)
    absolute_path = static_dir.get(&#34;absolute_path&#34;, False)
    if absolute_path:
        return j.sals.fs.expanduser(path_location)
    return j.sals.fs.expanduser(j.sals.fs.join_paths(self.path, path_location))</code></pre>
</details>
</dd>
<dt id="jumpscale.servers.threebot.threebot.Package.restart"><code class="name flex">
<span>def <span class="ident">restart</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def restart(self):
    if self.module:
        self.module.stop()
        self.module.start()</code></pre>
</details>
</dd>
<dt id="jumpscale.servers.threebot.threebot.Package.start"><code class="name flex">
<span>def <span class="ident">start</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def start(self):
    if self.module and hasattr(self.module, &#34;start&#34;):
        self.module.start(**self.kwargs)</code></pre>
</details>
</dd>
<dt id="jumpscale.servers.threebot.threebot.Package.stop"><code class="name flex">
<span>def <span class="ident">stop</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def stop(self):
    if self.module and hasattr(self.module, &#34;stop&#34;):
        self.module.stop()</code></pre>
</details>
</dd>
<dt id="jumpscale.servers.threebot.threebot.Package.uninstall"><code class="name flex">
<span>def <span class="ident">uninstall</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def uninstall(self):
    if self.module and hasattr(self.module, &#34;uninstall&#34;):
        self.module.uninstall()</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="jumpscale.servers.threebot.threebot.PackageManager"><code class="flex name class">
<span>class <span class="ident">PackageManager</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>A simple attribute-based namespace.</p>
<p>SimpleNamespace(**kwargs)</p>
<p>base class implementation for any class with fields which supports getting/setting raw data for any instance fields.</p>
<p>any instance can have an optional name and a parent.</p>
<pre><code class="language-python">class Person(Base):
    name = fields.String()
    age = fields.Float()

p = Person(name=&quot;ahmed&quot;, age=&quot;19&quot;)
print(p.name, p.age)
</code></pre>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>parent_</code></strong> :&ensp;<code>Base</code>, optional</dt>
<dd>parent instance. Defaults to None.</dd>
<dt><strong><code>instance_name_</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>instance name. Defaults to None.</dd>
<dt><strong><code>**values</code></strong></dt>
<dd>any given field values to initiate the instance with</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PackageManager(Base):
    packages = fields.Typed(dict, default=DEFAULT_PACKAGES.copy())

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self._threebot = None

    @property
    def threebot(self):
        if self._threebot is None:
            self._threebot = j.servers.threebot.get()
        return self._threebot

    def get(self, package_name):
        if package_name in self.packages:
            package_path = self.packages[package_name][&#34;path&#34;]
            package_giturl = self.packages[package_name][&#34;giturl&#34;]
            package_kwargs = self.packages[package_name].get(&#34;kwargs&#34;, {})
            package_admins = self.packages[package_name].get(&#34;admins&#34;, [])

            return Package(
                path=package_path,
                default_domain=self.threebot.domain,
                default_email=self.threebot.email,
                default_acme_server_type=self.threebot.acme_server_type,
                default_acme_server_url=self.threebot.acme_server_url,
                giturl=package_giturl,
                kwargs=package_kwargs,
                admins=package_admins,
            )

    def get_packages(self):
        all_packages = []

        # Add installed packages including outer packages
        for pkg in self.packages:
            package = self.get(pkg)

            if package and package.is_valid():
                if j.sals.fs.exists(package.path):
                    chatflows = True if package.chats_dir else False
                    all_packages.append(
                        {
                            &#34;name&#34;: pkg,
                            &#34;path&#34;: package.path,
                            &#34;giturl&#34;: package.giturl,
                            &#34;system_package&#34;: pkg in DEFAULT_PACKAGES.keys(),
                            &#34;installed&#34;: True,
                            &#34;frontend&#34;: package.config.get(&#34;frontend&#34;, False),
                            &#34;chatflows&#34;: chatflows,
                            &#34;ui_name&#34;: package.ui_name,
                        }
                    )
                else:
                    j.logger.error(f&#34;path {package.path} for {pkg} doesn&#39;t exist anymore&#34;)
            else:
                j.logger.error(&#34;pkg {pkg} is in self.packages but it&#39;s None&#34;)

        # Add uninstalled sdk packages under j.packages
        for path in set(pkgnamespace.__path__):
            for pkg in os.listdir(path):
                pkg_path = j.sals.fs.join_paths(path, pkg)
                pkgtoml_path = j.sals.fs.join_paths(pkg_path, &#34;package.toml&#34;)
                ui_name = pkg
                excluded = False
                with open(pkgtoml_path) as f:
                    conf = j.data.serializers.toml.loads(f.read())
                    ui_name = conf.get(&#34;ui_name&#34;, pkg)
                    excluded = conf.get(&#34;excluded&#34;, False)
                if pkg not in self.packages and j.sals.fs.exists(pkgtoml_path) and not excluded:
                    all_packages.append(
                        {
                            &#34;name&#34;: pkg,
                            &#34;path&#34;: j.sals.fs.dirname(getattr(j.packages, pkg).__file__),
                            &#34;giturl&#34;: &#34;&#34;,
                            &#34;system_package&#34;: pkg in DEFAULT_PACKAGES.keys(),
                            &#34;installed&#34;: False,
                            &#34;ui_name&#34;: ui_name,
                        }
                    )

        return all_packages

    def list_all(self):
        return list(self.packages.keys())

    def add(self, path: str = None, giturl: str = None, **kwargs):
        # first check if public repo
        # TODO: Check if package already exists
        if not any([path, giturl]) or all([path, giturl]):
            raise j.exceptions.Value(&#34;either path or giturl is required&#34;)
        pkg_name = &#34;&#34;
        if giturl:
            url = urlparse(giturl)
            url_parts = url.path.lstrip(&#34;/&#34;).split(&#34;/&#34;)
            if len(url_parts) == 2:
                pkg_name = url_parts[1].strip(&#34;/&#34;)
                j.logger.debug(
                    f&#34;user didn&#39;t pass a URL containing branch {giturl}, try to guess (master, main, development) in order&#34;
                )
                if j.tools.http.get(f&#34;{giturl}/tree/master&#34;).status_code == 200:
                    url_parts.extend([&#34;tree&#34;, &#34;master&#34;])
                elif j.tools.http.get(f&#34;{giturl}/tree/main&#34;).status_code == 200:
                    url_parts.extend([&#34;tree&#34;, &#34;main&#34;])
                elif j.tools.http.get(f&#34;{giturl}/tree/development&#34;).status_code == 200:
                    url_parts.extend([&#34;tree&#34;, &#34;development&#34;])
                else:
                    raise j.exceptions.Value(f&#34;couldn&#39;t guess the branch for {giturl}&#34;)
            else:
                pkg_name = url_parts[-1].strip(&#34;/&#34;)

            if len(url_parts) &lt; 4:
                raise j.exceptions.Value(f&#34;invalid git URL {giturl}&#34;)

            org, repo, _, branch = url_parts[:4]
            repo_dir = f&#34;{org}_{repo}_{pkg_name}_{branch}&#34;
            repo_path = j.sals.fs.join_paths(DOWNLOADED_PACKAGES_PATH, repo_dir)
            repo_url = f&#34;{url.scheme}://{url.hostname}/{org}/{repo}&#34;

            # delete repo dir if exists
            j.sals.fs.rmtree(repo_path)

            j.tools.git.clone_repo(url=repo_url, dest=repo_path, branch_or_tag=branch)
            toml_paths = list(
                j.sals.fs.walk(repo_path, &#34;*&#34;, filter_fun=lambda x: str(x).endswith(f&#34;{pkg_name}/package.toml&#34;))
            )
            if not toml_paths:
                raise j.exceptions.Value(f&#34;couldn&#39;t find {pkg_name}/package.toml in {repo_path}&#34;)
            path_for_package_toml = toml_paths[0]
            package_path = j.sals.fs.parent(path_for_package_toml)
            path = package_path

        admins = kwargs.pop(&#34;admins&#34;, [])

        package = Package(
            path=path,
            default_domain=self.threebot.domain,
            default_email=self.threebot.email,
            giturl=giturl,
            kwargs=kwargs,
            admins=admins,
        )

        # TODO: adding under the same name if same path and same giturl should be fine, no?
        # if package.name in self.packages:
        #     raise j.exceptions.Value(f&#34;Package with name {package.name} already exists&#34;)

        # execute package install method
        package.install(**kwargs)

        # install package if threebot is started
        if self.threebot.started:
            self.install(package)
            self.threebot.nginx.reload()
        self.packages[package.name] = {
            &#34;name&#34;: package.name,
            &#34;path&#34;: package.path,
            &#34;giturl&#34;: package.giturl,
            &#34;kwargs&#34;: package.kwargs,
            &#34;admins&#34;: package.admins,
            &#34;ui_name&#34;: package.ui_name,
        }

        self.save()

        # Return updated package info
        return {package.name: self.packages[package.name]}

    def delete(self, package_name):
        if package_name in DEFAULT_PACKAGES:
            raise j.exceptions.Value(&#34;cannot delete default packages&#34;)
        package = self.get(package_name)
        if not package:
            raise j.exceptions.NotFound(f&#34;{package_name} package not found&#34;)

        # remove bottle servers
        rack_servers = list(self.threebot.rack._servers)
        for bottle_server in rack_servers:
            if bottle_server.startswith(f&#34;{package_name}_&#34;):
                self.threebot.rack.remove(bottle_server)

        # stop background services
        if package.services_dir:
            for service in package.services:
                self.threebot.services.stop_service(service[&#34;name&#34;])

        if self.threebot.started:
            # unregister gedis actors
            gedis_actors = list(self.threebot.gedis._loaded_actors.keys())
            for actor in gedis_actors:
                if actor.startswith(f&#34;{package_name}_&#34;):
                    self.threebot.gedis._system_actor.unregister_actor(actor)

            # unload chats
            try:
                if package.chats_dir:
                    self.threebot.chatbot.unload(package.chats_dir)
            except Exception as e:
                j.logger.warning(f&#34;Couldn&#39;t unload the chats of package {package_name}, this is the exception {str(e)}&#34;)

            # reload nginx
            self.threebot.nginx.reload()

        # execute package uninstall method
        package.uninstall()

        self.packages.pop(package_name)
        self.save()

    def install(self, package):
        &#34;&#34;&#34;install and apply package configrations

        Args:
            package ([package object]): get package object using [self.get(package_name)]

        Returns:
            [dict]: [package info]
        &#34;&#34;&#34;
        sys.path.append(package.path + &#34;/../&#34;)  # TODO to be changed
        package.preinstall()
        for static_dir in package.static_dirs:
            path = package.resolve_staticdir_location(static_dir)
            if not j.sals.fs.exists(path):
                raise j.exceptions.NotFound(f&#34;Cannot find static dir {path}&#34;)

        # add bottle servers
        # we first merge all apps of a package into a single app
        # then mount this app on threebot main app
        # this will work with multiple non-standalone apps
        package_app = j.servers.appserver.make_main_app()
        for bottle_server in package.bottle_servers:
            path = j.sals.fs.join_paths(package.path, bottle_server[&#34;file_path&#34;])
            if not j.sals.fs.exists(path):
                raise j.exceptions.NotFound(f&#34;Cannot find bottle server path {path}&#34;)

            standalone = bottle_server.get(&#34;standalone&#34;, False)
            if standalone:
                bottle_wsgi_server = package.get_bottle_server(path, bottle_server[&#34;host&#34;], bottle_server[&#34;port&#34;])
                self.threebot.rack.add(f&#34;{package.name}_{bottle_server[&#39;name&#39;]}&#34;, bottle_wsgi_server)
            else:
                bottle_app = package.get_package_bottle_app(path)
                package_app.merge(bottle_app)

        if package_app.routes:
            j.logger.info(f&#34;registering {package.name} package app&#34;)
            self.threebot.mainapp.mount(f&#34;/{package.name}&#34;, package_app)

        # register gedis actors
        if package.actors_dir:
            for actor in package.actors:
                self.threebot.gedis._system_actor.register_actor(actor[&#34;name&#34;], actor[&#34;path&#34;], force_reload=True)

        # add chatflows actors
        if package.chats_dir:
            self.threebot.chatbot.load(package.chats_dir)

        # start background services
        if package.services_dir:
            for service in package.services:
                self.threebot.services.add_service(service[&#34;name&#34;], service[&#34;path&#34;])

        j.logger.info(f&#34;starting rack&#34;)
        # start servers
        self.threebot.rack.start()

        j.logger.info(f&#34;applying nginx config&#34;)
        # apply nginx configuration
        package.nginx_config.apply()

        j.logger.info(f&#34;starting package&#34;)
        # execute package start method
        package.start()

        j.logger.info(f&#34;reloading gedis&#34;)
        self.threebot.gedis_http.client.reload()
        j.logger.info(f&#34;reloading nginx&#34;)
        self.threebot.nginx.reload()

    def reload(self, package_name):
        if self.threebot.started:
            package = self.get(package_name)
            if not package:
                raise j.exceptions.NotFound(f&#34;{package_name} package not found&#34;)
            if package.services_dir:
                for service in package.services:
                    self.threebot.services.stop_service(service[&#34;name&#34;])
            self.install(package)
            self.threebot.nginx.reload()
            self.save()
        else:
            raise j.exceptions.Runtime(&#34;Can&#39;t reload package. Threebot server is not started&#34;)

        # Return updated package info
        return {package.name: self.packages[package.name]}

    def _install_all(self):
        &#34;&#34;&#34;Install and apply all the packages configurations
        This method shall not be called directly from the shell,
        it must be called only from the code on the running Gedis server
        &#34;&#34;&#34;
        all_packages = self.list_all()
        for package in all_packages:
            if package not in DEFAULT_PACKAGES:
                j.logger.info(f&#34;Configuring package {package}&#34;)
                pkg = self.get(package)
                if not pkg:
                    j.logger.error(f&#34;can&#39;t get package {package}&#34;)
                else:
                    if pkg.path and pkg.is_valid():
                        self.install(pkg)
                    else:
                        j.logger.error(f&#34;package {package} was installed before but {pkg.path} doesn&#39;t exist anymore.&#34;)

    def scan_packages_paths_in_dir(self, path):
        &#34;&#34;&#34;Scans all packages in a path in any level and returns list of package paths

        Args:
            path (str): root path that has packages on some levels

        Returns:
            List[str]: list of all packages available under the path
        &#34;&#34;&#34;
        filterfun = lambda x: str(x).endswith(&#34;package.toml&#34;)
        pkgtoml_paths = j.sals.fs.walk(path, filter_fun=filterfun)
        pkgs_paths = list(map(lambda x: x.replace(&#34;/package.toml&#34;, &#34;&#34;), pkgtoml_paths))
        return pkgs_paths

    def scan_packages_in_dir(self, path):
        &#34;&#34;&#34;Gets a dict from packages names to packages paths existing under a path that may have jumpscale packages at any level.

        Args:
            path (str): root path that has packages on some levels

        Returns:
            Dict[package_name, package_path]: dict of all packages available under the path
        &#34;&#34;&#34;
        pkgname_to_path = {}
        for p in self.scan_packages_paths_in_dir(path):
            basename = j.sals.fs.basename(p).strip()
            if basename:
                pkgname_to_path[basename] = p

        return pkgname_to_path</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="jumpscale.core.base.meta.Base" href="../../core/base/meta.html#jumpscale.core.base.meta.Base">Base</a></li>
<li>types.SimpleNamespace</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="jumpscale.servers.threebot.threebot.PackageManager.packages"><code class="name">var <span class="ident">packages</span></code></dt>
<dd>
<div class="desc"><p>getter method this property</p>
<p>will call <code>_get_value</code>, which would if the value is already defined
and will get the default value if not</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>any</code></dt>
<dd>the field value</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getter(self):
    &#34;&#34;&#34;
    getter method this property

    will call `_get_value`, which would if the value is already defined
    and will get the default value if not

    Returns:
        any: the field value
    &#34;&#34;&#34;
    return self._get_value(name, field)</code></pre>
</details>
</dd>
<dt id="jumpscale.servers.threebot.threebot.PackageManager.threebot"><code class="name">var <span class="ident">threebot</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def threebot(self):
    if self._threebot is None:
        self._threebot = j.servers.threebot.get()
    return self._threebot</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="jumpscale.servers.threebot.threebot.PackageManager.add"><code class="name flex">
<span>def <span class="ident">add</span></span>(<span>self, path: str = None, giturl: str = None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add(self, path: str = None, giturl: str = None, **kwargs):
    # first check if public repo
    # TODO: Check if package already exists
    if not any([path, giturl]) or all([path, giturl]):
        raise j.exceptions.Value(&#34;either path or giturl is required&#34;)
    pkg_name = &#34;&#34;
    if giturl:
        url = urlparse(giturl)
        url_parts = url.path.lstrip(&#34;/&#34;).split(&#34;/&#34;)
        if len(url_parts) == 2:
            pkg_name = url_parts[1].strip(&#34;/&#34;)
            j.logger.debug(
                f&#34;user didn&#39;t pass a URL containing branch {giturl}, try to guess (master, main, development) in order&#34;
            )
            if j.tools.http.get(f&#34;{giturl}/tree/master&#34;).status_code == 200:
                url_parts.extend([&#34;tree&#34;, &#34;master&#34;])
            elif j.tools.http.get(f&#34;{giturl}/tree/main&#34;).status_code == 200:
                url_parts.extend([&#34;tree&#34;, &#34;main&#34;])
            elif j.tools.http.get(f&#34;{giturl}/tree/development&#34;).status_code == 200:
                url_parts.extend([&#34;tree&#34;, &#34;development&#34;])
            else:
                raise j.exceptions.Value(f&#34;couldn&#39;t guess the branch for {giturl}&#34;)
        else:
            pkg_name = url_parts[-1].strip(&#34;/&#34;)

        if len(url_parts) &lt; 4:
            raise j.exceptions.Value(f&#34;invalid git URL {giturl}&#34;)

        org, repo, _, branch = url_parts[:4]
        repo_dir = f&#34;{org}_{repo}_{pkg_name}_{branch}&#34;
        repo_path = j.sals.fs.join_paths(DOWNLOADED_PACKAGES_PATH, repo_dir)
        repo_url = f&#34;{url.scheme}://{url.hostname}/{org}/{repo}&#34;

        # delete repo dir if exists
        j.sals.fs.rmtree(repo_path)

        j.tools.git.clone_repo(url=repo_url, dest=repo_path, branch_or_tag=branch)
        toml_paths = list(
            j.sals.fs.walk(repo_path, &#34;*&#34;, filter_fun=lambda x: str(x).endswith(f&#34;{pkg_name}/package.toml&#34;))
        )
        if not toml_paths:
            raise j.exceptions.Value(f&#34;couldn&#39;t find {pkg_name}/package.toml in {repo_path}&#34;)
        path_for_package_toml = toml_paths[0]
        package_path = j.sals.fs.parent(path_for_package_toml)
        path = package_path

    admins = kwargs.pop(&#34;admins&#34;, [])

    package = Package(
        path=path,
        default_domain=self.threebot.domain,
        default_email=self.threebot.email,
        giturl=giturl,
        kwargs=kwargs,
        admins=admins,
    )

    # TODO: adding under the same name if same path and same giturl should be fine, no?
    # if package.name in self.packages:
    #     raise j.exceptions.Value(f&#34;Package with name {package.name} already exists&#34;)

    # execute package install method
    package.install(**kwargs)

    # install package if threebot is started
    if self.threebot.started:
        self.install(package)
        self.threebot.nginx.reload()
    self.packages[package.name] = {
        &#34;name&#34;: package.name,
        &#34;path&#34;: package.path,
        &#34;giturl&#34;: package.giturl,
        &#34;kwargs&#34;: package.kwargs,
        &#34;admins&#34;: package.admins,
        &#34;ui_name&#34;: package.ui_name,
    }

    self.save()

    # Return updated package info
    return {package.name: self.packages[package.name]}</code></pre>
</details>
</dd>
<dt id="jumpscale.servers.threebot.threebot.PackageManager.delete"><code class="name flex">
<span>def <span class="ident">delete</span></span>(<span>self, package_name)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def delete(self, package_name):
    if package_name in DEFAULT_PACKAGES:
        raise j.exceptions.Value(&#34;cannot delete default packages&#34;)
    package = self.get(package_name)
    if not package:
        raise j.exceptions.NotFound(f&#34;{package_name} package not found&#34;)

    # remove bottle servers
    rack_servers = list(self.threebot.rack._servers)
    for bottle_server in rack_servers:
        if bottle_server.startswith(f&#34;{package_name}_&#34;):
            self.threebot.rack.remove(bottle_server)

    # stop background services
    if package.services_dir:
        for service in package.services:
            self.threebot.services.stop_service(service[&#34;name&#34;])

    if self.threebot.started:
        # unregister gedis actors
        gedis_actors = list(self.threebot.gedis._loaded_actors.keys())
        for actor in gedis_actors:
            if actor.startswith(f&#34;{package_name}_&#34;):
                self.threebot.gedis._system_actor.unregister_actor(actor)

        # unload chats
        try:
            if package.chats_dir:
                self.threebot.chatbot.unload(package.chats_dir)
        except Exception as e:
            j.logger.warning(f&#34;Couldn&#39;t unload the chats of package {package_name}, this is the exception {str(e)}&#34;)

        # reload nginx
        self.threebot.nginx.reload()

    # execute package uninstall method
    package.uninstall()

    self.packages.pop(package_name)
    self.save()</code></pre>
</details>
</dd>
<dt id="jumpscale.servers.threebot.threebot.PackageManager.get"><code class="name flex">
<span>def <span class="ident">get</span></span>(<span>self, package_name)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get(self, package_name):
    if package_name in self.packages:
        package_path = self.packages[package_name][&#34;path&#34;]
        package_giturl = self.packages[package_name][&#34;giturl&#34;]
        package_kwargs = self.packages[package_name].get(&#34;kwargs&#34;, {})
        package_admins = self.packages[package_name].get(&#34;admins&#34;, [])

        return Package(
            path=package_path,
            default_domain=self.threebot.domain,
            default_email=self.threebot.email,
            default_acme_server_type=self.threebot.acme_server_type,
            default_acme_server_url=self.threebot.acme_server_url,
            giturl=package_giturl,
            kwargs=package_kwargs,
            admins=package_admins,
        )</code></pre>
</details>
</dd>
<dt id="jumpscale.servers.threebot.threebot.PackageManager.get_packages"><code class="name flex">
<span>def <span class="ident">get_packages</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_packages(self):
    all_packages = []

    # Add installed packages including outer packages
    for pkg in self.packages:
        package = self.get(pkg)

        if package and package.is_valid():
            if j.sals.fs.exists(package.path):
                chatflows = True if package.chats_dir else False
                all_packages.append(
                    {
                        &#34;name&#34;: pkg,
                        &#34;path&#34;: package.path,
                        &#34;giturl&#34;: package.giturl,
                        &#34;system_package&#34;: pkg in DEFAULT_PACKAGES.keys(),
                        &#34;installed&#34;: True,
                        &#34;frontend&#34;: package.config.get(&#34;frontend&#34;, False),
                        &#34;chatflows&#34;: chatflows,
                        &#34;ui_name&#34;: package.ui_name,
                    }
                )
            else:
                j.logger.error(f&#34;path {package.path} for {pkg} doesn&#39;t exist anymore&#34;)
        else:
            j.logger.error(&#34;pkg {pkg} is in self.packages but it&#39;s None&#34;)

    # Add uninstalled sdk packages under j.packages
    for path in set(pkgnamespace.__path__):
        for pkg in os.listdir(path):
            pkg_path = j.sals.fs.join_paths(path, pkg)
            pkgtoml_path = j.sals.fs.join_paths(pkg_path, &#34;package.toml&#34;)
            ui_name = pkg
            excluded = False
            with open(pkgtoml_path) as f:
                conf = j.data.serializers.toml.loads(f.read())
                ui_name = conf.get(&#34;ui_name&#34;, pkg)
                excluded = conf.get(&#34;excluded&#34;, False)
            if pkg not in self.packages and j.sals.fs.exists(pkgtoml_path) and not excluded:
                all_packages.append(
                    {
                        &#34;name&#34;: pkg,
                        &#34;path&#34;: j.sals.fs.dirname(getattr(j.packages, pkg).__file__),
                        &#34;giturl&#34;: &#34;&#34;,
                        &#34;system_package&#34;: pkg in DEFAULT_PACKAGES.keys(),
                        &#34;installed&#34;: False,
                        &#34;ui_name&#34;: ui_name,
                    }
                )

    return all_packages</code></pre>
</details>
</dd>
<dt id="jumpscale.servers.threebot.threebot.PackageManager.install"><code class="name flex">
<span>def <span class="ident">install</span></span>(<span>self, package)</span>
</code></dt>
<dd>
<div class="desc"><p>install and apply package configrations</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>package</code></strong> :&ensp;<code>[package object]</code></dt>
<dd>get package object using [self.get(package_name)]</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>[dict]</code></dt>
<dd>[package info]</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def install(self, package):
    &#34;&#34;&#34;install and apply package configrations

    Args:
        package ([package object]): get package object using [self.get(package_name)]

    Returns:
        [dict]: [package info]
    &#34;&#34;&#34;
    sys.path.append(package.path + &#34;/../&#34;)  # TODO to be changed
    package.preinstall()
    for static_dir in package.static_dirs:
        path = package.resolve_staticdir_location(static_dir)
        if not j.sals.fs.exists(path):
            raise j.exceptions.NotFound(f&#34;Cannot find static dir {path}&#34;)

    # add bottle servers
    # we first merge all apps of a package into a single app
    # then mount this app on threebot main app
    # this will work with multiple non-standalone apps
    package_app = j.servers.appserver.make_main_app()
    for bottle_server in package.bottle_servers:
        path = j.sals.fs.join_paths(package.path, bottle_server[&#34;file_path&#34;])
        if not j.sals.fs.exists(path):
            raise j.exceptions.NotFound(f&#34;Cannot find bottle server path {path}&#34;)

        standalone = bottle_server.get(&#34;standalone&#34;, False)
        if standalone:
            bottle_wsgi_server = package.get_bottle_server(path, bottle_server[&#34;host&#34;], bottle_server[&#34;port&#34;])
            self.threebot.rack.add(f&#34;{package.name}_{bottle_server[&#39;name&#39;]}&#34;, bottle_wsgi_server)
        else:
            bottle_app = package.get_package_bottle_app(path)
            package_app.merge(bottle_app)

    if package_app.routes:
        j.logger.info(f&#34;registering {package.name} package app&#34;)
        self.threebot.mainapp.mount(f&#34;/{package.name}&#34;, package_app)

    # register gedis actors
    if package.actors_dir:
        for actor in package.actors:
            self.threebot.gedis._system_actor.register_actor(actor[&#34;name&#34;], actor[&#34;path&#34;], force_reload=True)

    # add chatflows actors
    if package.chats_dir:
        self.threebot.chatbot.load(package.chats_dir)

    # start background services
    if package.services_dir:
        for service in package.services:
            self.threebot.services.add_service(service[&#34;name&#34;], service[&#34;path&#34;])

    j.logger.info(f&#34;starting rack&#34;)
    # start servers
    self.threebot.rack.start()

    j.logger.info(f&#34;applying nginx config&#34;)
    # apply nginx configuration
    package.nginx_config.apply()

    j.logger.info(f&#34;starting package&#34;)
    # execute package start method
    package.start()

    j.logger.info(f&#34;reloading gedis&#34;)
    self.threebot.gedis_http.client.reload()
    j.logger.info(f&#34;reloading nginx&#34;)
    self.threebot.nginx.reload()</code></pre>
</details>
</dd>
<dt id="jumpscale.servers.threebot.threebot.PackageManager.list_all"><code class="name flex">
<span>def <span class="ident">list_all</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def list_all(self):
    return list(self.packages.keys())</code></pre>
</details>
</dd>
<dt id="jumpscale.servers.threebot.threebot.PackageManager.reload"><code class="name flex">
<span>def <span class="ident">reload</span></span>(<span>self, package_name)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reload(self, package_name):
    if self.threebot.started:
        package = self.get(package_name)
        if not package:
            raise j.exceptions.NotFound(f&#34;{package_name} package not found&#34;)
        if package.services_dir:
            for service in package.services:
                self.threebot.services.stop_service(service[&#34;name&#34;])
        self.install(package)
        self.threebot.nginx.reload()
        self.save()
    else:
        raise j.exceptions.Runtime(&#34;Can&#39;t reload package. Threebot server is not started&#34;)

    # Return updated package info
    return {package.name: self.packages[package.name]}</code></pre>
</details>
</dd>
<dt id="jumpscale.servers.threebot.threebot.PackageManager.scan_packages_in_dir"><code class="name flex">
<span>def <span class="ident">scan_packages_in_dir</span></span>(<span>self, path)</span>
</code></dt>
<dd>
<div class="desc"><p>Gets a dict from packages names to packages paths existing under a path that may have jumpscale packages at any level.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>path</code></strong> :&ensp;<code>str</code></dt>
<dd>root path that has packages on some levels</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Dict[package_name, package_path]</code></dt>
<dd>dict of all packages available under the path</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def scan_packages_in_dir(self, path):
    &#34;&#34;&#34;Gets a dict from packages names to packages paths existing under a path that may have jumpscale packages at any level.

    Args:
        path (str): root path that has packages on some levels

    Returns:
        Dict[package_name, package_path]: dict of all packages available under the path
    &#34;&#34;&#34;
    pkgname_to_path = {}
    for p in self.scan_packages_paths_in_dir(path):
        basename = j.sals.fs.basename(p).strip()
        if basename:
            pkgname_to_path[basename] = p

    return pkgname_to_path</code></pre>
</details>
</dd>
<dt id="jumpscale.servers.threebot.threebot.PackageManager.scan_packages_paths_in_dir"><code class="name flex">
<span>def <span class="ident">scan_packages_paths_in_dir</span></span>(<span>self, path)</span>
</code></dt>
<dd>
<div class="desc"><p>Scans all packages in a path in any level and returns list of package paths</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>path</code></strong> :&ensp;<code>str</code></dt>
<dd>root path that has packages on some levels</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>List[str]</code></dt>
<dd>list of all packages available under the path</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def scan_packages_paths_in_dir(self, path):
    &#34;&#34;&#34;Scans all packages in a path in any level and returns list of package paths

    Args:
        path (str): root path that has packages on some levels

    Returns:
        List[str]: list of all packages available under the path
    &#34;&#34;&#34;
    filterfun = lambda x: str(x).endswith(&#34;package.toml&#34;)
    pkgtoml_paths = j.sals.fs.walk(path, filter_fun=filterfun)
    pkgs_paths = list(map(lambda x: x.replace(&#34;/package.toml&#34;, &#34;&#34;), pkgtoml_paths))
    return pkgs_paths</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="jumpscale.core.base.meta.Base" href="../../core/base/meta.html#jumpscale.core.base.meta.Base">Base</a></b></code>:
<ul class="hlist">
<li><code><a title="jumpscale.core.base.meta.Base.from_dict" href="../../core/base/meta.html#jumpscale.core.base.meta.Base.from_dict">from_dict</a></code></li>
<li><code><a title="jumpscale.core.base.meta.Base.to_dict" href="../../core/base/meta.html#jumpscale.core.base.meta.Base.to_dict">to_dict</a></code></li>
<li><code><a title="jumpscale.core.base.meta.Base.validate" href="../../core/base/meta.html#jumpscale.core.base.meta.Base.validate">validate</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="jumpscale.servers.threebot.threebot.ThreebotServer"><code class="flex name class">
<span>class <span class="ident">ThreebotServer</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>A simple attribute-based namespace.</p>
<p>SimpleNamespace(**kwargs)</p>
<p>base class implementation for any class with fields which supports getting/setting raw data for any instance fields.</p>
<p>any instance can have an optional name and a parent.</p>
<pre><code class="language-python">class Person(Base):
    name = fields.String()
    age = fields.Float()

p = Person(name=&quot;ahmed&quot;, age=&quot;19&quot;)
print(p.name, p.age)
</code></pre>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>parent_</code></strong> :&ensp;<code>Base</code>, optional</dt>
<dd>parent instance. Defaults to None.</dd>
<dt><strong><code>instance_name_</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>instance name. Defaults to None.</dd>
<dt><strong><code>**values</code></strong></dt>
<dd>any given field values to initiate the instance with</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ThreebotServer(Base):
    _package_manager = fields.Factory(PackageManager)
    domain = fields.String()
    email = fields.String()
    acme_server_type = fields.Enum(AcmeServer)
    acme_server_url = fields.URL()

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self._rack = None
        self._gedis = None
        self._db = None
        self._gedis_http = None
        self._services = None
        self._packages = None
        self._started = False
        self._nginx = None
        self._redis = None
        self.rack.add(GEDIS, self.gedis)
        self.rack.add(GEDIS_HTTP, self.gedis_http.gevent_server)
        self.rack.add(SERVICE_MANAGER, self.services)

    def is_running(self):
        nginx_running = self.nginx.is_running()
        redis_running = self.redis.cmd.is_running() or j.sals.nettools.wait_connection_test(
            &#34;127.0.0.1&#34;, 6379, timeout=1
        )
        gedis_running = j.sals.nettools.wait_connection_test(&#34;127.0.0.1&#34;, 16000, timeout=1)
        return nginx_running and redis_running and gedis_running

    @property
    def started(self):
        return self._started

    @property
    def nginx(self):
        if self._nginx is None:
            self._nginx = j.tools.nginx.get(&#34;default&#34;)
        return self._nginx

    @property
    def redis(self):
        if self._redis is None:
            self._redis = j.tools.redis.get(&#34;default&#34;)
        return self._redis

    @property
    def db(self):
        if self._db is None:
            self._db = j.core.db
        return self._db

    @property
    def rack(self):
        if self._rack is None:
            self._rack = j.servers.rack
        return self._rack

    @property
    def gedis(self):
        if self._gedis is None:
            self._gedis = j.servers.gedis.get(&#34;threebot&#34;)
        return self._gedis

    @property
    def gedis_http(self):
        if self._gedis_http is None:
            self._gedis_http = j.servers.gedis_http.get(&#34;threebot&#34;)
        return self._gedis_http

    @property
    def services(self):
        if self._services is None:
            self._services = j.tools.servicemanager.get(&#34;threebot&#34;)
        return self._services

    @property
    def chatbot(self):
        return self.gedis._loaded_actors.get(&#34;chatflows_chatbot&#34;)

    @property
    def packages(self):
        if self._packages is None:
            self._packages = self._package_manager.get(self.instance_name)
        return self._packages

    def check_dependencies(self):
        install_msg = &#34;Visit https://github.com/threefoldtech/js-sdk/blob/development/docs/wiki/quick_start.md for installation guide&#34;

        if not self.nginx.installed:
            raise j.exceptions.NotFound(f&#34;nginx is not installed.\n{install_msg}&#34;)

        ret = shutil.which(&#34;certbot&#34;)
        if not ret:
            raise j.exceptions.NotFound(f&#34;certbot is not installed.\n{install_msg}&#34;)

        rc, out, err = j.sals.process.execute(&#34;certbot plugins&#34;)
        if &#34;* nginx&#34; not in out:
            raise j.exceptions.NotFound(f&#34;python-certbot-nginx is not installed.\n{install_msg}&#34;)

        if not self.redis.installed:
            raise j.exceptions.NotFound(f&#34;redis is not installed.\n{install_msg}&#34;)

        ret = shutil.which(&#34;tmux&#34;)
        if not ret:
            raise j.exceptions.NotFound(f&#34;tmux is not installed.\n{install_msg}&#34;)

        ret = shutil.which(&#34;git&#34;)
        if not ret:
            raise j.exceptions.NotFound(f&#34;git is not installed.\n{install_msg}&#34;)

    def start(self, wait: bool = False, cert: bool = True):
        # start default servers in the rack
        # handle signals
        for signal_type in (signal.SIGTERM, signal.SIGINT, signal.SIGKILL):
            gevent.signal_handler(signal_type, self.stop)

        # mark app as started
        if self.is_running():
            return

        self.check_dependencies()

        self.redis.start()
        self.nginx.start()
        j.sals.nginx.get(self.nginx.server_name).cert = cert
        self.mainapp = j.servers.appserver.make_main_app()

        self.rack.start()
        j.logger.register(f&#34;threebot_{self.instance_name}&#34;)
        # add default packages
        for package_name in DEFAULT_PACKAGES:
            j.logger.info(f&#34;Configuring package {package_name}&#34;)
            try:
                package = self.packages.get(package_name)
                self.packages.install(package)
            except Exception as e:
                self.stop()
                raise j.core.exceptions.Runtime(
                    f&#34;Error happened during getting or installing {package_name} package, the detailed error is {str(e)}&#34;
                ) from e

        # install all package

        j.logger.info(&#34;Adding packages&#34;)
        self.packages._install_all()
        j.logger.info(&#34;jsappserver&#34;)
        self.jsappserver = WSGIServer((&#34;localhost&#34;, 31000), apply_main_middlewares(self.mainapp))
        j.logger.info(&#34;rack add&#34;)
        self.rack.add(f&#34;appserver&#34;, self.jsappserver)

        j.logger.info(&#34;Reloading nginx&#34;)
        self.nginx.reload()

        # mark server as started
        self._started = True
        j.logger.info(f&#34;routes: {self.mainapp.routes}&#34;)
        j.logger.info(f&#34;Threebot is running at http://localhost:{PORTS.HTTP} and https://localhost:{PORTS.HTTPS}&#34;)
        self.rack.start(wait=wait)  # to keep the server running

    def stop(self):
        server_packages = self.packages.list_all()
        for package_name in server_packages:
            package = self.packages.get(package_name)
            package.stop()
        self.nginx.stop()
        # mark app as stopped, do this before stopping redis
        j.logger.unregister()
        self.rack.stop()
        self.redis.stop()
        self._started = False</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="jumpscale.core.base.meta.Base" href="../../core/base/meta.html#jumpscale.core.base.meta.Base">Base</a></li>
<li>types.SimpleNamespace</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="jumpscale.servers.threebot.threebot.ThreebotServer.acme_server_type"><code class="name">var <span class="ident">acme_server_type</span></code></dt>
<dd>
<div class="desc"><p>getter method this property</p>
<p>will call <code>_get_value</code>, which would if the value is already defined
and will get the default value if not</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>any</code></dt>
<dd>the field value</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getter(self):
    &#34;&#34;&#34;
    getter method this property

    will call `_get_value`, which would if the value is already defined
    and will get the default value if not

    Returns:
        any: the field value
    &#34;&#34;&#34;
    return self._get_value(name, field)</code></pre>
</details>
</dd>
<dt id="jumpscale.servers.threebot.threebot.ThreebotServer.acme_server_url"><code class="name">var <span class="ident">acme_server_url</span></code></dt>
<dd>
<div class="desc"><p>getter method this property</p>
<p>will call <code>_get_value</code>, which would if the value is already defined
and will get the default value if not</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>any</code></dt>
<dd>the field value</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getter(self):
    &#34;&#34;&#34;
    getter method this property

    will call `_get_value`, which would if the value is already defined
    and will get the default value if not

    Returns:
        any: the field value
    &#34;&#34;&#34;
    return self._get_value(name, field)</code></pre>
</details>
</dd>
<dt id="jumpscale.servers.threebot.threebot.ThreebotServer.chatbot"><code class="name">var <span class="ident">chatbot</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def chatbot(self):
    return self.gedis._loaded_actors.get(&#34;chatflows_chatbot&#34;)</code></pre>
</details>
</dd>
<dt id="jumpscale.servers.threebot.threebot.ThreebotServer.db"><code class="name">var <span class="ident">db</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def db(self):
    if self._db is None:
        self._db = j.core.db
    return self._db</code></pre>
</details>
</dd>
<dt id="jumpscale.servers.threebot.threebot.ThreebotServer.domain"><code class="name">var <span class="ident">domain</span></code></dt>
<dd>
<div class="desc"><p>getter method this property</p>
<p>will call <code>_get_value</code>, which would if the value is already defined
and will get the default value if not</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>any</code></dt>
<dd>the field value</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getter(self):
    &#34;&#34;&#34;
    getter method this property

    will call `_get_value`, which would if the value is already defined
    and will get the default value if not

    Returns:
        any: the field value
    &#34;&#34;&#34;
    return self._get_value(name, field)</code></pre>
</details>
</dd>
<dt id="jumpscale.servers.threebot.threebot.ThreebotServer.email"><code class="name">var <span class="ident">email</span></code></dt>
<dd>
<div class="desc"><p>getter method this property</p>
<p>will call <code>_get_value</code>, which would if the value is already defined
and will get the default value if not</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>any</code></dt>
<dd>the field value</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getter(self):
    &#34;&#34;&#34;
    getter method this property

    will call `_get_value`, which would if the value is already defined
    and will get the default value if not

    Returns:
        any: the field value
    &#34;&#34;&#34;
    return self._get_value(name, field)</code></pre>
</details>
</dd>
<dt id="jumpscale.servers.threebot.threebot.ThreebotServer.gedis"><code class="name">var <span class="ident">gedis</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def gedis(self):
    if self._gedis is None:
        self._gedis = j.servers.gedis.get(&#34;threebot&#34;)
    return self._gedis</code></pre>
</details>
</dd>
<dt id="jumpscale.servers.threebot.threebot.ThreebotServer.gedis_http"><code class="name">var <span class="ident">gedis_http</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def gedis_http(self):
    if self._gedis_http is None:
        self._gedis_http = j.servers.gedis_http.get(&#34;threebot&#34;)
    return self._gedis_http</code></pre>
</details>
</dd>
<dt id="jumpscale.servers.threebot.threebot.ThreebotServer.nginx"><code class="name">var <span class="ident">nginx</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def nginx(self):
    if self._nginx is None:
        self._nginx = j.tools.nginx.get(&#34;default&#34;)
    return self._nginx</code></pre>
</details>
</dd>
<dt id="jumpscale.servers.threebot.threebot.ThreebotServer.packages"><code class="name">var <span class="ident">packages</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def packages(self):
    if self._packages is None:
        self._packages = self._package_manager.get(self.instance_name)
    return self._packages</code></pre>
</details>
</dd>
<dt id="jumpscale.servers.threebot.threebot.ThreebotServer.rack"><code class="name">var <span class="ident">rack</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def rack(self):
    if self._rack is None:
        self._rack = j.servers.rack
    return self._rack</code></pre>
</details>
</dd>
<dt id="jumpscale.servers.threebot.threebot.ThreebotServer.redis"><code class="name">var <span class="ident">redis</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def redis(self):
    if self._redis is None:
        self._redis = j.tools.redis.get(&#34;default&#34;)
    return self._redis</code></pre>
</details>
</dd>
<dt id="jumpscale.servers.threebot.threebot.ThreebotServer.services"><code class="name">var <span class="ident">services</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def services(self):
    if self._services is None:
        self._services = j.tools.servicemanager.get(&#34;threebot&#34;)
    return self._services</code></pre>
</details>
</dd>
<dt id="jumpscale.servers.threebot.threebot.ThreebotServer.started"><code class="name">var <span class="ident">started</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def started(self):
    return self._started</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="jumpscale.servers.threebot.threebot.ThreebotServer.check_dependencies"><code class="name flex">
<span>def <span class="ident">check_dependencies</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_dependencies(self):
    install_msg = &#34;Visit https://github.com/threefoldtech/js-sdk/blob/development/docs/wiki/quick_start.md for installation guide&#34;

    if not self.nginx.installed:
        raise j.exceptions.NotFound(f&#34;nginx is not installed.\n{install_msg}&#34;)

    ret = shutil.which(&#34;certbot&#34;)
    if not ret:
        raise j.exceptions.NotFound(f&#34;certbot is not installed.\n{install_msg}&#34;)

    rc, out, err = j.sals.process.execute(&#34;certbot plugins&#34;)
    if &#34;* nginx&#34; not in out:
        raise j.exceptions.NotFound(f&#34;python-certbot-nginx is not installed.\n{install_msg}&#34;)

    if not self.redis.installed:
        raise j.exceptions.NotFound(f&#34;redis is not installed.\n{install_msg}&#34;)

    ret = shutil.which(&#34;tmux&#34;)
    if not ret:
        raise j.exceptions.NotFound(f&#34;tmux is not installed.\n{install_msg}&#34;)

    ret = shutil.which(&#34;git&#34;)
    if not ret:
        raise j.exceptions.NotFound(f&#34;git is not installed.\n{install_msg}&#34;)</code></pre>
</details>
</dd>
<dt id="jumpscale.servers.threebot.threebot.ThreebotServer.is_running"><code class="name flex">
<span>def <span class="ident">is_running</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_running(self):
    nginx_running = self.nginx.is_running()
    redis_running = self.redis.cmd.is_running() or j.sals.nettools.wait_connection_test(
        &#34;127.0.0.1&#34;, 6379, timeout=1
    )
    gedis_running = j.sals.nettools.wait_connection_test(&#34;127.0.0.1&#34;, 16000, timeout=1)
    return nginx_running and redis_running and gedis_running</code></pre>
</details>
</dd>
<dt id="jumpscale.servers.threebot.threebot.ThreebotServer.start"><code class="name flex">
<span>def <span class="ident">start</span></span>(<span>self, wait: bool = False, cert: bool = True)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def start(self, wait: bool = False, cert: bool = True):
    # start default servers in the rack
    # handle signals
    for signal_type in (signal.SIGTERM, signal.SIGINT, signal.SIGKILL):
        gevent.signal_handler(signal_type, self.stop)

    # mark app as started
    if self.is_running():
        return

    self.check_dependencies()

    self.redis.start()
    self.nginx.start()
    j.sals.nginx.get(self.nginx.server_name).cert = cert
    self.mainapp = j.servers.appserver.make_main_app()

    self.rack.start()
    j.logger.register(f&#34;threebot_{self.instance_name}&#34;)
    # add default packages
    for package_name in DEFAULT_PACKAGES:
        j.logger.info(f&#34;Configuring package {package_name}&#34;)
        try:
            package = self.packages.get(package_name)
            self.packages.install(package)
        except Exception as e:
            self.stop()
            raise j.core.exceptions.Runtime(
                f&#34;Error happened during getting or installing {package_name} package, the detailed error is {str(e)}&#34;
            ) from e

    # install all package

    j.logger.info(&#34;Adding packages&#34;)
    self.packages._install_all()
    j.logger.info(&#34;jsappserver&#34;)
    self.jsappserver = WSGIServer((&#34;localhost&#34;, 31000), apply_main_middlewares(self.mainapp))
    j.logger.info(&#34;rack add&#34;)
    self.rack.add(f&#34;appserver&#34;, self.jsappserver)

    j.logger.info(&#34;Reloading nginx&#34;)
    self.nginx.reload()

    # mark server as started
    self._started = True
    j.logger.info(f&#34;routes: {self.mainapp.routes}&#34;)
    j.logger.info(f&#34;Threebot is running at http://localhost:{PORTS.HTTP} and https://localhost:{PORTS.HTTPS}&#34;)
    self.rack.start(wait=wait)  # to keep the server running</code></pre>
</details>
</dd>
<dt id="jumpscale.servers.threebot.threebot.ThreebotServer.stop"><code class="name flex">
<span>def <span class="ident">stop</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def stop(self):
    server_packages = self.packages.list_all()
    for package_name in server_packages:
        package = self.packages.get(package_name)
        package.stop()
    self.nginx.stop()
    # mark app as stopped, do this before stopping redis
    j.logger.unregister()
    self.rack.stop()
    self.redis.stop()
    self._started = False</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="jumpscale.core.base.meta.Base" href="../../core/base/meta.html#jumpscale.core.base.meta.Base">Base</a></b></code>:
<ul class="hlist">
<li><code><a title="jumpscale.core.base.meta.Base.from_dict" href="../../core/base/meta.html#jumpscale.core.base.meta.Base.from_dict">from_dict</a></code></li>
<li><code><a title="jumpscale.core.base.meta.Base.to_dict" href="../../core/base/meta.html#jumpscale.core.base.meta.Base.to_dict">to_dict</a></code></li>
<li><code><a title="jumpscale.core.base.meta.Base.validate" href="../../core/base/meta.html#jumpscale.core.base.meta.Base.validate">validate</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="jumpscale.servers.threebot" href="index.html">jumpscale.servers.threebot</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="jumpscale.servers.threebot.threebot.NginxPackageConfig" href="#jumpscale.servers.threebot.threebot.NginxPackageConfig">NginxPackageConfig</a></code></h4>
<ul class="">
<li><code><a title="jumpscale.servers.threebot.threebot.NginxPackageConfig.apply" href="#jumpscale.servers.threebot.threebot.NginxPackageConfig.apply">apply</a></code></li>
<li><code><a title="jumpscale.servers.threebot.threebot.NginxPackageConfig.default_config" href="#jumpscale.servers.threebot.threebot.NginxPackageConfig.default_config">default_config</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="jumpscale.servers.threebot.threebot.Package" href="#jumpscale.servers.threebot.threebot.Package">Package</a></code></h4>
<ul class="">
<li><code><a title="jumpscale.servers.threebot.threebot.Package.actors" href="#jumpscale.servers.threebot.threebot.Package.actors">actors</a></code></li>
<li><code><a title="jumpscale.servers.threebot.threebot.Package.actors_dir" href="#jumpscale.servers.threebot.threebot.Package.actors_dir">actors_dir</a></code></li>
<li><code><a title="jumpscale.servers.threebot.threebot.Package.base_url" href="#jumpscale.servers.threebot.threebot.Package.base_url">base_url</a></code></li>
<li><code><a title="jumpscale.servers.threebot.threebot.Package.bottle_servers" href="#jumpscale.servers.threebot.threebot.Package.bottle_servers">bottle_servers</a></code></li>
<li><code><a title="jumpscale.servers.threebot.threebot.Package.chats_dir" href="#jumpscale.servers.threebot.threebot.Package.chats_dir">chats_dir</a></code></li>
<li><code><a title="jumpscale.servers.threebot.threebot.Package.config" href="#jumpscale.servers.threebot.threebot.Package.config">config</a></code></li>
<li><code><a title="jumpscale.servers.threebot.threebot.Package.exists" href="#jumpscale.servers.threebot.threebot.Package.exists">exists</a></code></li>
<li><code><a title="jumpscale.servers.threebot.threebot.Package.get_bottle_server" href="#jumpscale.servers.threebot.threebot.Package.get_bottle_server">get_bottle_server</a></code></li>
<li><code><a title="jumpscale.servers.threebot.threebot.Package.get_package_bottle_app" href="#jumpscale.servers.threebot.threebot.Package.get_package_bottle_app">get_package_bottle_app</a></code></li>
<li><code><a title="jumpscale.servers.threebot.threebot.Package.install" href="#jumpscale.servers.threebot.threebot.Package.install">install</a></code></li>
<li><code><a title="jumpscale.servers.threebot.threebot.Package.is_excluded" href="#jumpscale.servers.threebot.threebot.Package.is_excluded">is_excluded</a></code></li>
<li><code><a title="jumpscale.servers.threebot.threebot.Package.is_valid" href="#jumpscale.servers.threebot.threebot.Package.is_valid">is_valid</a></code></li>
<li><code><a title="jumpscale.servers.threebot.threebot.Package.load_config" href="#jumpscale.servers.threebot.threebot.Package.load_config">load_config</a></code></li>
<li><code><a title="jumpscale.servers.threebot.threebot.Package.module" href="#jumpscale.servers.threebot.threebot.Package.module">module</a></code></li>
<li><code><a title="jumpscale.servers.threebot.threebot.Package.package_config_path" href="#jumpscale.servers.threebot.threebot.Package.package_config_path">package_config_path</a></code></li>
<li><code><a title="jumpscale.servers.threebot.threebot.Package.package_module_path" href="#jumpscale.servers.threebot.threebot.Package.package_module_path">package_module_path</a></code></li>
<li><code><a title="jumpscale.servers.threebot.threebot.Package.preinstall" href="#jumpscale.servers.threebot.threebot.Package.preinstall">preinstall</a></code></li>
<li><code><a title="jumpscale.servers.threebot.threebot.Package.resolve_staticdir_location" href="#jumpscale.servers.threebot.threebot.Package.resolve_staticdir_location">resolve_staticdir_location</a></code></li>
<li><code><a title="jumpscale.servers.threebot.threebot.Package.restart" href="#jumpscale.servers.threebot.threebot.Package.restart">restart</a></code></li>
<li><code><a title="jumpscale.servers.threebot.threebot.Package.services" href="#jumpscale.servers.threebot.threebot.Package.services">services</a></code></li>
<li><code><a title="jumpscale.servers.threebot.threebot.Package.services_dir" href="#jumpscale.servers.threebot.threebot.Package.services_dir">services_dir</a></code></li>
<li><code><a title="jumpscale.servers.threebot.threebot.Package.start" href="#jumpscale.servers.threebot.threebot.Package.start">start</a></code></li>
<li><code><a title="jumpscale.servers.threebot.threebot.Package.static_dirs" href="#jumpscale.servers.threebot.threebot.Package.static_dirs">static_dirs</a></code></li>
<li><code><a title="jumpscale.servers.threebot.threebot.Package.stop" href="#jumpscale.servers.threebot.threebot.Package.stop">stop</a></code></li>
<li><code><a title="jumpscale.servers.threebot.threebot.Package.ui_name" href="#jumpscale.servers.threebot.threebot.Package.ui_name">ui_name</a></code></li>
<li><code><a title="jumpscale.servers.threebot.threebot.Package.uninstall" href="#jumpscale.servers.threebot.threebot.Package.uninstall">uninstall</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="jumpscale.servers.threebot.threebot.PackageManager" href="#jumpscale.servers.threebot.threebot.PackageManager">PackageManager</a></code></h4>
<ul class="">
<li><code><a title="jumpscale.servers.threebot.threebot.PackageManager.add" href="#jumpscale.servers.threebot.threebot.PackageManager.add">add</a></code></li>
<li><code><a title="jumpscale.servers.threebot.threebot.PackageManager.delete" href="#jumpscale.servers.threebot.threebot.PackageManager.delete">delete</a></code></li>
<li><code><a title="jumpscale.servers.threebot.threebot.PackageManager.get" href="#jumpscale.servers.threebot.threebot.PackageManager.get">get</a></code></li>
<li><code><a title="jumpscale.servers.threebot.threebot.PackageManager.get_packages" href="#jumpscale.servers.threebot.threebot.PackageManager.get_packages">get_packages</a></code></li>
<li><code><a title="jumpscale.servers.threebot.threebot.PackageManager.install" href="#jumpscale.servers.threebot.threebot.PackageManager.install">install</a></code></li>
<li><code><a title="jumpscale.servers.threebot.threebot.PackageManager.list_all" href="#jumpscale.servers.threebot.threebot.PackageManager.list_all">list_all</a></code></li>
<li><code><a title="jumpscale.servers.threebot.threebot.PackageManager.packages" href="#jumpscale.servers.threebot.threebot.PackageManager.packages">packages</a></code></li>
<li><code><a title="jumpscale.servers.threebot.threebot.PackageManager.reload" href="#jumpscale.servers.threebot.threebot.PackageManager.reload">reload</a></code></li>
<li><code><a title="jumpscale.servers.threebot.threebot.PackageManager.scan_packages_in_dir" href="#jumpscale.servers.threebot.threebot.PackageManager.scan_packages_in_dir">scan_packages_in_dir</a></code></li>
<li><code><a title="jumpscale.servers.threebot.threebot.PackageManager.scan_packages_paths_in_dir" href="#jumpscale.servers.threebot.threebot.PackageManager.scan_packages_paths_in_dir">scan_packages_paths_in_dir</a></code></li>
<li><code><a title="jumpscale.servers.threebot.threebot.PackageManager.threebot" href="#jumpscale.servers.threebot.threebot.PackageManager.threebot">threebot</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="jumpscale.servers.threebot.threebot.ThreebotServer" href="#jumpscale.servers.threebot.threebot.ThreebotServer">ThreebotServer</a></code></h4>
<ul class="two-column">
<li><code><a title="jumpscale.servers.threebot.threebot.ThreebotServer.acme_server_type" href="#jumpscale.servers.threebot.threebot.ThreebotServer.acme_server_type">acme_server_type</a></code></li>
<li><code><a title="jumpscale.servers.threebot.threebot.ThreebotServer.acme_server_url" href="#jumpscale.servers.threebot.threebot.ThreebotServer.acme_server_url">acme_server_url</a></code></li>
<li><code><a title="jumpscale.servers.threebot.threebot.ThreebotServer.chatbot" href="#jumpscale.servers.threebot.threebot.ThreebotServer.chatbot">chatbot</a></code></li>
<li><code><a title="jumpscale.servers.threebot.threebot.ThreebotServer.check_dependencies" href="#jumpscale.servers.threebot.threebot.ThreebotServer.check_dependencies">check_dependencies</a></code></li>
<li><code><a title="jumpscale.servers.threebot.threebot.ThreebotServer.db" href="#jumpscale.servers.threebot.threebot.ThreebotServer.db">db</a></code></li>
<li><code><a title="jumpscale.servers.threebot.threebot.ThreebotServer.domain" href="#jumpscale.servers.threebot.threebot.ThreebotServer.domain">domain</a></code></li>
<li><code><a title="jumpscale.servers.threebot.threebot.ThreebotServer.email" href="#jumpscale.servers.threebot.threebot.ThreebotServer.email">email</a></code></li>
<li><code><a title="jumpscale.servers.threebot.threebot.ThreebotServer.gedis" href="#jumpscale.servers.threebot.threebot.ThreebotServer.gedis">gedis</a></code></li>
<li><code><a title="jumpscale.servers.threebot.threebot.ThreebotServer.gedis_http" href="#jumpscale.servers.threebot.threebot.ThreebotServer.gedis_http">gedis_http</a></code></li>
<li><code><a title="jumpscale.servers.threebot.threebot.ThreebotServer.is_running" href="#jumpscale.servers.threebot.threebot.ThreebotServer.is_running">is_running</a></code></li>
<li><code><a title="jumpscale.servers.threebot.threebot.ThreebotServer.nginx" href="#jumpscale.servers.threebot.threebot.ThreebotServer.nginx">nginx</a></code></li>
<li><code><a title="jumpscale.servers.threebot.threebot.ThreebotServer.packages" href="#jumpscale.servers.threebot.threebot.ThreebotServer.packages">packages</a></code></li>
<li><code><a title="jumpscale.servers.threebot.threebot.ThreebotServer.rack" href="#jumpscale.servers.threebot.threebot.ThreebotServer.rack">rack</a></code></li>
<li><code><a title="jumpscale.servers.threebot.threebot.ThreebotServer.redis" href="#jumpscale.servers.threebot.threebot.ThreebotServer.redis">redis</a></code></li>
<li><code><a title="jumpscale.servers.threebot.threebot.ThreebotServer.services" href="#jumpscale.servers.threebot.threebot.ThreebotServer.services">services</a></code></li>
<li><code><a title="jumpscale.servers.threebot.threebot.ThreebotServer.start" href="#jumpscale.servers.threebot.threebot.ThreebotServer.start">start</a></code></li>
<li><code><a title="jumpscale.servers.threebot.threebot.ThreebotServer.started" href="#jumpscale.servers.threebot.threebot.ThreebotServer.started">started</a></code></li>
<li><code><a title="jumpscale.servers.threebot.threebot.ThreebotServer.stop" href="#jumpscale.servers.threebot.threebot.ThreebotServer.stop">stop</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>