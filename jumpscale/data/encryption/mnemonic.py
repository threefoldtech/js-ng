import os
import hashlib

from .exceptions import FailedChecksumError


wordlist = []

with open(os.path.join(os.path.dirname(__file__), "wordlist.txt"), "r") as f:
    wordlist = [line.strip() for line in f.readlines()]

# Todo: change default value of wordlist -> fakes
def generate_mnemonic(strength=256, wordlist=wordlist):
    """Generate random mnemonic

    Args:
        strength (int, optional): The number of bits of the generated key. Defaults to 256.
        wordlist (list[str], optional): The Word list used to generate the mnemonic. Defaults to wordlist.

    Returns:
        str: A string of space separated words representing the mnemonic.
    """
    ent = entropy(strength)
    return key_to_mnemonic(ent)


def entropy(strength=256, wordlist=wordlist):
    """Returns random bytes of length strengh/8.

    Args:
        strength (int, optional): The number of bits in the randomly created array. Defaults to 256.
        wordlist (list[str], optional): The Word list used to generate the mnemonic. Defaults to wordlist.

    Returns:
        bytes: The generated bytes.
    """
    return os.urandom(strength // 8)


def mnemonic_to_key(mnemonic, wordlist=wordlist):
    """Convert mnemonic to key

    Args:
        mnemonic (str): A string of space separated words representing the mnemonic.
        wordlist (list[string], optional): The Word list used to generate the mnemonic. Defaults to wordlist.

    Raises:
        FailedChecksumError: Thrown when the checksum validation fails.

    Returns:
        bytes: The key
    """
    words = mnemonic.split(" ")
    indexes = list(map(lambda x: _word_index(x, wordlist), words))
    total_length = len(indexes) * 11
    strength = total_length * 32 // 33
    binary_string = to_bin(indexes, 11)
    data = binary_string[0:strength]
    decrypted = bytes([int(data[i : i + 8], 2) for i in range(0, len(data), 8)])
    if not _verify_checksum(decrypted, binary_string[strength:]):
        raise FailedChecksumError("The received package is corrupt.")
    return decrypted


def _verify_checksum(data, checksum):
    """Verify the passed checksum matches the data checksum

    Args:
        data (bytes): The data represented as bytes.
        checksum (bytes): The checksum to be checked.

    Returns:
        bool: True if the checksum matches that of the data.
    """
    sha256_hash = hashlib.sha256(data).digest()
    return to_bin(sha256_hash)[0 : len(data) * 8 // 32] == checksum


def _word_index(word, wordlist=wordlist):
    """Returns the index of the word in the wordlist

    Args:
        word (str): The word to be searched for.
        wordlist (list[str], optional): The word list to be searched in. Defaults to wordlist.

    Returns:
        int: The index of the word.
    """
    lo, hi = 0, len(wordlist) - 1
    while lo < hi:
        mid = (lo + hi) // 2
        if word <= wordlist[mid]:
            hi = mid
        else:
            lo = mid + 1
    return lo


def key_to_mnemonic(key, wordlist=wordlist):
    """Convert the passed key to memorizable mnemonic.

    Args:
        key (bytes): The key to be encoded.
        wordlist (list[str], optional): The wordlist used to generate the mnemonic. Defaults to wordlist.

    Returns:
        str: A string of space separated words representing the mnemonic
    """
    sha256_hash = hashlib.sha256(key).hexdigest().encode()
    strength = len(key) * 8
    checksum_length = strength // 32
    total_length = strength + checksum_length
    binary_string = (to_bin(key) + to_bin(sha256_hash)[0:checksum_length])[0:total_length]
    sentence = ""
    for i in range(total_length // 11):
        sentence += " " + wordlist[int(binary_string[i * 11 : (i + 1) * 11], 2)]
    return sentence[1:]


def to_bin(arr, bytelen=8):
    """Converts an iterable object containing ascii codes to a string of the joint binary representation of each item where each of them is of length bytelen

    Args:
        arr (iterable): The array to be converted
        bytelen (int, optional): The length of the to-be-created binary string of each item. Defaults to 8.

    Returns:
        string: The binary string representing the array
    """
    result = ""
    for c in arr:
        result += ("0" * bytelen + bin(c)[2:])[-bytelen:]
    return result
